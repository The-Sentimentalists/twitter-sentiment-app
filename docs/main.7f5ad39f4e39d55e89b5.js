(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{0:function(t,e,n){t.exports=n("zUnb")},1:function(t,e){},2:function(t,e){},3:function(t,e){},4:function(t,e){},5:function(t,e){},B9Yq:function(t,e){t.exports=function(){throw new Error("define cannot be used indirect")}},EVdn:function(t,e,n){var r;!function(e,n){"use strict";"object"==typeof t.exports?t.exports=e.document?n(e,!0):function(t){if(!t.document)throw new Error("jQuery requires a window with a document");return n(t)}:n(e)}("undefined"!=typeof window?window:this,(function(n,s){"use strict";var i=[],o=Object.getPrototypeOf,a=i.slice,l=i.flat?function(t){return i.flat.call(t)}:function(t){return i.concat.apply([],t)},u=i.push,c=i.indexOf,h={},d=h.toString,p=h.hasOwnProperty,f=p.toString,m=f.call(Object),g={},y=function(t){return"function"==typeof t&&"number"!=typeof t.nodeType},b=function(t){return null!=t&&t===t.window},v=n.document,x={type:!0,src:!0,nonce:!0,noModule:!0};function w(t,e,n){var r,s,i=(n=n||v).createElement("script");if(i.text=t,e)for(r in x)(s=e[r]||e.getAttribute&&e.getAttribute(r))&&i.setAttribute(r,s);n.head.appendChild(i).parentNode.removeChild(i)}function C(t){return null==t?t+"":"object"==typeof t||"function"==typeof t?h[d.call(t)]||"object":typeof t}var S=function(t,e){return new S.fn.init(t,e)};function _(t){var e=!!t&&"length"in t&&t.length,n=C(t);return!y(t)&&!b(t)&&("array"===n||0===e||"number"==typeof e&&e>0&&e-1 in t)}S.fn=S.prototype={jquery:"3.5.1",constructor:S,length:0,toArray:function(){return a.call(this)},get:function(t){return null==t?a.call(this):t<0?this[t+this.length]:this[t]},pushStack:function(t){var e=S.merge(this.constructor(),t);return e.prevObject=this,e},each:function(t){return S.each(this,t)},map:function(t){return this.pushStack(S.map(this,(function(e,n){return t.call(e,n,e)})))},slice:function(){return this.pushStack(a.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,(function(t,e){return(e+1)%2})))},odd:function(){return this.pushStack(S.grep(this,(function(t,e){return e%2})))},eq:function(t){var e=this.length,n=+t+(t<0?e:0);return this.pushStack(n>=0&&n<e?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:i.sort,splice:i.splice},S.extend=S.fn.extend=function(){var t,e,n,r,s,i,o=arguments[0]||{},a=1,l=arguments.length,u=!1;for("boolean"==typeof o&&(u=o,o=arguments[a]||{},a++),"object"==typeof o||y(o)||(o={}),a===l&&(o=this,a--);a<l;a++)if(null!=(t=arguments[a]))for(e in t)r=t[e],"__proto__"!==e&&o!==r&&(u&&r&&(S.isPlainObject(r)||(s=Array.isArray(r)))?(n=o[e],i=s&&!Array.isArray(n)?[]:s||S.isPlainObject(n)?n:{},s=!1,o[e]=S.extend(u,i,r)):void 0!==r&&(o[e]=r));return o},S.extend({expando:"jQuery"+("3.5.1"+Math.random()).replace(/\D/g,""),isReady:!0,error:function(t){throw new Error(t)},noop:function(){},isPlainObject:function(t){var e,n;return!(!t||"[object Object]"!==d.call(t)||(e=o(t))&&("function"!=typeof(n=p.call(e,"constructor")&&e.constructor)||f.call(n)!==m))},isEmptyObject:function(t){var e;for(e in t)return!1;return!0},globalEval:function(t,e,n){w(t,{nonce:e&&e.nonce},n)},each:function(t,e){var n,r=0;if(_(t))for(n=t.length;r<n&&!1!==e.call(t[r],r,t[r]);r++);else for(r in t)if(!1===e.call(t[r],r,t[r]))break;return t},makeArray:function(t,e){var n=e||[];return null!=t&&(_(Object(t))?S.merge(n,"string"==typeof t?[t]:t):u.call(n,t)),n},inArray:function(t,e,n){return null==e?-1:c.call(e,t,n)},merge:function(t,e){for(var n=+e.length,r=0,s=t.length;r<n;r++)t[s++]=e[r];return t.length=s,t},grep:function(t,e,n){for(var r=[],s=0,i=t.length,o=!n;s<i;s++)!e(t[s],s)!==o&&r.push(t[s]);return r},map:function(t,e,n){var r,s,i=0,o=[];if(_(t))for(r=t.length;i<r;i++)null!=(s=e(t[i],i,n))&&o.push(s);else for(i in t)null!=(s=e(t[i],i,n))&&o.push(s);return l(o)},guid:1,support:g}),"function"==typeof Symbol&&(S.fn[Symbol.iterator]=i[Symbol.iterator]),S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),(function(t,e){h["[object "+e+"]"]=e.toLowerCase()}));var E=function(t){var e,n,r,s,i,o,a,l,u,c,h,d,p,f,m,g,y,b,v,x="sizzle"+1*new Date,w=t.document,C=0,S=0,_=lt(),E=lt(),k=lt(),A=lt(),I=function(t,e){return t===e&&(h=!0),0},N={}.hasOwnProperty,T=[],R=T.pop,$=T.push,D=T.push,O=T.slice,F=function(t,e){for(var n=0,r=t.length;n<r;n++)if(t[n]===e)return n;return-1},M="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",P="(?:\\\\[\\da-fA-F]{1,6}"+L+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",z="\\["+L+"*("+P+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+P+"))|)"+L+"*\\]",B=":("+P+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+z+")*)|.*)\\)|)",V=new RegExp(L+"+","g"),U=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),W=new RegExp("^"+L+"*,"+L+"*"),j=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),H=new RegExp(L+"|>"),q=new RegExp(B),G=new RegExp("^"+P+"$"),K={ID:new RegExp("^#("+P+")"),CLASS:new RegExp("^\\.("+P+")"),TAG:new RegExp("^("+P+"|[*])"),ATTR:new RegExp("^"+z),PSEUDO:new RegExp("^"+B),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+M+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},X=/HTML$/i,Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,J=/^[^{]+\{\s*\[native \w/,Q=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,tt=/[+~]/,et=new RegExp("\\\\[\\da-fA-F]{1,6}"+L+"?|\\\\([^\\r\\n\\f])","g"),nt=function(t,e){var n="0x"+t.slice(1)-65536;return e||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},rt=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,st=function(t,e){return e?"\0"===t?"\ufffd":t.slice(0,-1)+"\\"+t.charCodeAt(t.length-1).toString(16)+" ":"\\"+t},it=function(){d()},ot=xt((function(t){return!0===t.disabled&&"fieldset"===t.nodeName.toLowerCase()}),{dir:"parentNode",next:"legend"});try{D.apply(T=O.call(w.childNodes),w.childNodes)}catch(Et){D={apply:T.length?function(t,e){$.apply(t,O.call(e))}:function(t,e){for(var n=t.length,r=0;t[n++]=e[r++];);t.length=n-1}}}function at(t,e,r,s){var i,a,u,c,h,f,y,b=e&&e.ownerDocument,w=e?e.nodeType:9;if(r=r||[],"string"!=typeof t||!t||1!==w&&9!==w&&11!==w)return r;if(!s&&(d(e),e=e||p,m)){if(11!==w&&(h=Q.exec(t)))if(i=h[1]){if(9===w){if(!(u=e.getElementById(i)))return r;if(u.id===i)return r.push(u),r}else if(b&&(u=b.getElementById(i))&&v(e,u)&&u.id===i)return r.push(u),r}else{if(h[2])return D.apply(r,e.getElementsByTagName(t)),r;if((i=h[3])&&n.getElementsByClassName&&e.getElementsByClassName)return D.apply(r,e.getElementsByClassName(i)),r}if(n.qsa&&!A[t+" "]&&(!g||!g.test(t))&&(1!==w||"object"!==e.nodeName.toLowerCase())){if(y=t,b=e,1===w&&(H.test(t)||j.test(t))){for((b=tt.test(t)&&yt(e.parentNode)||e)===e&&n.scope||((c=e.getAttribute("id"))?c=c.replace(rt,st):e.setAttribute("id",c=x)),a=(f=o(t)).length;a--;)f[a]=(c?"#"+c:":scope")+" "+vt(f[a]);y=f.join(",")}try{return D.apply(r,b.querySelectorAll(y)),r}catch(C){A(t,!0)}finally{c===x&&e.removeAttribute("id")}}}return l(t.replace(U,"$1"),e,r,s)}function lt(){var t=[];return function e(n,s){return t.push(n+" ")>r.cacheLength&&delete e[t.shift()],e[n+" "]=s}}function ut(t){return t[x]=!0,t}function ct(t){var e=p.createElement("fieldset");try{return!!t(e)}catch(Et){return!1}finally{e.parentNode&&e.parentNode.removeChild(e),e=null}}function ht(t,e){for(var n=t.split("|"),s=n.length;s--;)r.attrHandle[n[s]]=e}function dt(t,e){var n=e&&t,r=n&&1===t.nodeType&&1===e.nodeType&&t.sourceIndex-e.sourceIndex;if(r)return r;if(n)for(;n=n.nextSibling;)if(n===e)return-1;return t?1:-1}function pt(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function ft(t){return function(e){var n=e.nodeName.toLowerCase();return("input"===n||"button"===n)&&e.type===t}}function mt(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ot(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function gt(t){return ut((function(e){return e=+e,ut((function(n,r){for(var s,i=t([],n.length,e),o=i.length;o--;)n[s=i[o]]&&(n[s]=!(r[s]=n[s]))}))}))}function yt(t){return t&&void 0!==t.getElementsByTagName&&t}for(e in n=at.support={},i=at.isXML=function(t){var e=(t.ownerDocument||t).documentElement;return!X.test(t.namespaceURI||e&&e.nodeName||"HTML")},d=at.setDocument=function(t){var e,s,o=t?t.ownerDocument||t:w;return o!=p&&9===o.nodeType&&o.documentElement?(f=(p=o).documentElement,m=!i(p),w!=p&&(s=p.defaultView)&&s.top!==s&&(s.addEventListener?s.addEventListener("unload",it,!1):s.attachEvent&&s.attachEvent("onunload",it)),n.scope=ct((function(t){return f.appendChild(t).appendChild(p.createElement("div")),void 0!==t.querySelectorAll&&!t.querySelectorAll(":scope fieldset div").length})),n.attributes=ct((function(t){return t.className="i",!t.getAttribute("className")})),n.getElementsByTagName=ct((function(t){return t.appendChild(p.createComment("")),!t.getElementsByTagName("*").length})),n.getElementsByClassName=J.test(p.getElementsByClassName),n.getById=ct((function(t){return f.appendChild(t).id=x,!p.getElementsByName||!p.getElementsByName(x).length})),n.getById?(r.filter.ID=function(t){var e=t.replace(et,nt);return function(t){return t.getAttribute("id")===e}},r.find.ID=function(t,e){if(void 0!==e.getElementById&&m){var n=e.getElementById(t);return n?[n]:[]}}):(r.filter.ID=function(t){var e=t.replace(et,nt);return function(t){var n=void 0!==t.getAttributeNode&&t.getAttributeNode("id");return n&&n.value===e}},r.find.ID=function(t,e){if(void 0!==e.getElementById&&m){var n,r,s,i=e.getElementById(t);if(i){if((n=i.getAttributeNode("id"))&&n.value===t)return[i];for(s=e.getElementsByName(t),r=0;i=s[r++];)if((n=i.getAttributeNode("id"))&&n.value===t)return[i]}return[]}}),r.find.TAG=n.getElementsByTagName?function(t,e){return void 0!==e.getElementsByTagName?e.getElementsByTagName(t):n.qsa?e.querySelectorAll(t):void 0}:function(t,e){var n,r=[],s=0,i=e.getElementsByTagName(t);if("*"===t){for(;n=i[s++];)1===n.nodeType&&r.push(n);return r}return i},r.find.CLASS=n.getElementsByClassName&&function(t,e){if(void 0!==e.getElementsByClassName&&m)return e.getElementsByClassName(t)},y=[],g=[],(n.qsa=J.test(p.querySelectorAll))&&(ct((function(t){var e;f.appendChild(t).innerHTML="<a id='"+x+"'></a><select id='"+x+"-\r\\' msallowcapture=''><option selected=''></option></select>",t.querySelectorAll("[msallowcapture^='']").length&&g.push("[*^$]="+L+"*(?:''|\"\")"),t.querySelectorAll("[selected]").length||g.push("\\["+L+"*(?:value|"+M+")"),t.querySelectorAll("[id~="+x+"-]").length||g.push("~="),(e=p.createElement("input")).setAttribute("name",""),t.appendChild(e),t.querySelectorAll("[name='']").length||g.push("\\["+L+"*name"+L+"*="+L+"*(?:''|\"\")"),t.querySelectorAll(":checked").length||g.push(":checked"),t.querySelectorAll("a#"+x+"+*").length||g.push(".#.+[+~]"),t.querySelectorAll("\\\f"),g.push("[\\r\\n\\f]")})),ct((function(t){t.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var e=p.createElement("input");e.setAttribute("type","hidden"),t.appendChild(e).setAttribute("name","D"),t.querySelectorAll("[name=d]").length&&g.push("name"+L+"*[*^$|!~]?="),2!==t.querySelectorAll(":enabled").length&&g.push(":enabled",":disabled"),f.appendChild(t).disabled=!0,2!==t.querySelectorAll(":disabled").length&&g.push(":enabled",":disabled"),t.querySelectorAll("*,:x"),g.push(",.*:")}))),(n.matchesSelector=J.test(b=f.matches||f.webkitMatchesSelector||f.mozMatchesSelector||f.oMatchesSelector||f.msMatchesSelector))&&ct((function(t){n.disconnectedMatch=b.call(t,"*"),b.call(t,"[s!='']:x"),y.push("!=",B)})),g=g.length&&new RegExp(g.join("|")),y=y.length&&new RegExp(y.join("|")),e=J.test(f.compareDocumentPosition),v=e||J.test(f.contains)?function(t,e){var n=9===t.nodeType?t.documentElement:t,r=e&&e.parentNode;return t===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):t.compareDocumentPosition&&16&t.compareDocumentPosition(r)))}:function(t,e){if(e)for(;e=e.parentNode;)if(e===t)return!0;return!1},I=e?function(t,e){if(t===e)return h=!0,0;var r=!t.compareDocumentPosition-!e.compareDocumentPosition;return r||(1&(r=(t.ownerDocument||t)==(e.ownerDocument||e)?t.compareDocumentPosition(e):1)||!n.sortDetached&&e.compareDocumentPosition(t)===r?t==p||t.ownerDocument==w&&v(w,t)?-1:e==p||e.ownerDocument==w&&v(w,e)?1:c?F(c,t)-F(c,e):0:4&r?-1:1)}:function(t,e){if(t===e)return h=!0,0;var n,r=0,s=t.parentNode,i=e.parentNode,o=[t],a=[e];if(!s||!i)return t==p?-1:e==p?1:s?-1:i?1:c?F(c,t)-F(c,e):0;if(s===i)return dt(t,e);for(n=t;n=n.parentNode;)o.unshift(n);for(n=e;n=n.parentNode;)a.unshift(n);for(;o[r]===a[r];)r++;return r?dt(o[r],a[r]):o[r]==w?-1:a[r]==w?1:0},p):p},at.matches=function(t,e){return at(t,null,null,e)},at.matchesSelector=function(t,e){if(d(t),n.matchesSelector&&m&&!A[e+" "]&&(!y||!y.test(e))&&(!g||!g.test(e)))try{var r=b.call(t,e);if(r||n.disconnectedMatch||t.document&&11!==t.document.nodeType)return r}catch(Et){A(e,!0)}return at(e,p,null,[t]).length>0},at.contains=function(t,e){return(t.ownerDocument||t)!=p&&d(t),v(t,e)},at.attr=function(t,e){(t.ownerDocument||t)!=p&&d(t);var s=r.attrHandle[e.toLowerCase()],i=s&&N.call(r.attrHandle,e.toLowerCase())?s(t,e,!m):void 0;return void 0!==i?i:n.attributes||!m?t.getAttribute(e):(i=t.getAttributeNode(e))&&i.specified?i.value:null},at.escape=function(t){return(t+"").replace(rt,st)},at.error=function(t){throw new Error("Syntax error, unrecognized expression: "+t)},at.uniqueSort=function(t){var e,r=[],s=0,i=0;if(h=!n.detectDuplicates,c=!n.sortStable&&t.slice(0),t.sort(I),h){for(;e=t[i++];)e===t[i]&&(s=r.push(i));for(;s--;)t.splice(r[s],1)}return c=null,t},s=at.getText=function(t){var e,n="",r=0,i=t.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof t.textContent)return t.textContent;for(t=t.firstChild;t;t=t.nextSibling)n+=s(t)}else if(3===i||4===i)return t.nodeValue}else for(;e=t[r++];)n+=s(e);return n},(r=at.selectors={cacheLength:50,createPseudo:ut,match:K,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(t){return t[1]=t[1].replace(et,nt),t[3]=(t[3]||t[4]||t[5]||"").replace(et,nt),"~="===t[2]&&(t[3]=" "+t[3]+" "),t.slice(0,4)},CHILD:function(t){return t[1]=t[1].toLowerCase(),"nth"===t[1].slice(0,3)?(t[3]||at.error(t[0]),t[4]=+(t[4]?t[5]+(t[6]||1):2*("even"===t[3]||"odd"===t[3])),t[5]=+(t[7]+t[8]||"odd"===t[3])):t[3]&&at.error(t[0]),t},PSEUDO:function(t){var e,n=!t[6]&&t[2];return K.CHILD.test(t[0])?null:(t[3]?t[2]=t[4]||t[5]||"":n&&q.test(n)&&(e=o(n,!0))&&(e=n.indexOf(")",n.length-e)-n.length)&&(t[0]=t[0].slice(0,e),t[2]=n.slice(0,e)),t.slice(0,3))}},filter:{TAG:function(t){var e=t.replace(et,nt).toLowerCase();return"*"===t?function(){return!0}:function(t){return t.nodeName&&t.nodeName.toLowerCase()===e}},CLASS:function(t){var e=_[t+" "];return e||(e=new RegExp("(^|"+L+")"+t+"("+L+"|$)"))&&_(t,(function(t){return e.test("string"==typeof t.className&&t.className||void 0!==t.getAttribute&&t.getAttribute("class")||"")}))},ATTR:function(t,e,n){return function(r){var s=at.attr(r,t);return null==s?"!="===e:!e||(s+="","="===e?s===n:"!="===e?s!==n:"^="===e?n&&0===s.indexOf(n):"*="===e?n&&s.indexOf(n)>-1:"$="===e?n&&s.slice(-n.length)===n:"~="===e?(" "+s.replace(V," ")+" ").indexOf(n)>-1:"|="===e&&(s===n||s.slice(0,n.length+1)===n+"-"))}},CHILD:function(t,e,n,r,s){var i="nth"!==t.slice(0,3),o="last"!==t.slice(-4),a="of-type"===e;return 1===r&&0===s?function(t){return!!t.parentNode}:function(e,n,l){var u,c,h,d,p,f,m=i!==o?"nextSibling":"previousSibling",g=e.parentNode,y=a&&e.nodeName.toLowerCase(),b=!l&&!a,v=!1;if(g){if(i){for(;m;){for(d=e;d=d[m];)if(a?d.nodeName.toLowerCase()===y:1===d.nodeType)return!1;f=m="only"===t&&!f&&"nextSibling"}return!0}if(f=[o?g.firstChild:g.lastChild],o&&b){for(v=(p=(u=(c=(h=(d=g)[x]||(d[x]={}))[d.uniqueID]||(h[d.uniqueID]={}))[t]||[])[0]===C&&u[1])&&u[2],d=p&&g.childNodes[p];d=++p&&d&&d[m]||(v=p=0)||f.pop();)if(1===d.nodeType&&++v&&d===e){c[t]=[C,p,v];break}}else if(b&&(v=p=(u=(c=(h=(d=e)[x]||(d[x]={}))[d.uniqueID]||(h[d.uniqueID]={}))[t]||[])[0]===C&&u[1]),!1===v)for(;(d=++p&&d&&d[m]||(v=p=0)||f.pop())&&((a?d.nodeName.toLowerCase()!==y:1!==d.nodeType)||!++v||(b&&((c=(h=d[x]||(d[x]={}))[d.uniqueID]||(h[d.uniqueID]={}))[t]=[C,v]),d!==e)););return(v-=s)===r||v%r==0&&v/r>=0}}},PSEUDO:function(t,e){var n,s=r.pseudos[t]||r.setFilters[t.toLowerCase()]||at.error("unsupported pseudo: "+t);return s[x]?s(e):s.length>1?(n=[t,t,"",e],r.setFilters.hasOwnProperty(t.toLowerCase())?ut((function(t,n){for(var r,i=s(t,e),o=i.length;o--;)t[r=F(t,i[o])]=!(n[r]=i[o])})):function(t){return s(t,0,n)}):s}},pseudos:{not:ut((function(t){var e=[],n=[],r=a(t.replace(U,"$1"));return r[x]?ut((function(t,e,n,s){for(var i,o=r(t,null,s,[]),a=t.length;a--;)(i=o[a])&&(t[a]=!(e[a]=i))})):function(t,s,i){return e[0]=t,r(e,null,i,n),e[0]=null,!n.pop()}})),has:ut((function(t){return function(e){return at(t,e).length>0}})),contains:ut((function(t){return t=t.replace(et,nt),function(e){return(e.textContent||s(e)).indexOf(t)>-1}})),lang:ut((function(t){return G.test(t||"")||at.error("unsupported lang: "+t),t=t.replace(et,nt).toLowerCase(),function(e){var n;do{if(n=m?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(n=n.toLowerCase())===t||0===n.indexOf(t+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}})),target:function(e){var n=t.location&&t.location.hash;return n&&n.slice(1)===e.id},root:function(t){return t===f},focus:function(t){return t===p.activeElement&&(!p.hasFocus||p.hasFocus())&&!!(t.type||t.href||~t.tabIndex)},enabled:mt(!1),disabled:mt(!0),checked:function(t){var e=t.nodeName.toLowerCase();return"input"===e&&!!t.checked||"option"===e&&!!t.selected},selected:function(t){return!0===t.selected},empty:function(t){for(t=t.firstChild;t;t=t.nextSibling)if(t.nodeType<6)return!1;return!0},parent:function(t){return!r.pseudos.empty(t)},header:function(t){return Z.test(t.nodeName)},input:function(t){return Y.test(t.nodeName)},button:function(t){var e=t.nodeName.toLowerCase();return"input"===e&&"button"===t.type||"button"===e},text:function(t){var e;return"input"===t.nodeName.toLowerCase()&&"text"===t.type&&(null==(e=t.getAttribute("type"))||"text"===e.toLowerCase())},first:gt((function(){return[0]})),last:gt((function(t,e){return[e-1]})),eq:gt((function(t,e,n){return[n<0?n+e:n]})),even:gt((function(t,e){for(var n=0;n<e;n+=2)t.push(n);return t})),odd:gt((function(t,e){for(var n=1;n<e;n+=2)t.push(n);return t})),lt:gt((function(t,e,n){for(var r=n<0?n+e:n>e?e:n;--r>=0;)t.push(r);return t})),gt:gt((function(t,e,n){for(var r=n<0?n+e:n;++r<e;)t.push(r);return t}))}}).pseudos.nth=r.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})r.pseudos[e]=pt(e);for(e in{submit:!0,reset:!0})r.pseudos[e]=ft(e);function bt(){}function vt(t){for(var e=0,n=t.length,r="";e<n;e++)r+=t[e].value;return r}function xt(t,e,n){var r=e.dir,s=e.next,i=s||r,o=n&&"parentNode"===i,a=S++;return e.first?function(e,n,s){for(;e=e[r];)if(1===e.nodeType||o)return t(e,n,s);return!1}:function(e,n,l){var u,c,h,d=[C,a];if(l){for(;e=e[r];)if((1===e.nodeType||o)&&t(e,n,l))return!0}else for(;e=e[r];)if(1===e.nodeType||o)if(c=(h=e[x]||(e[x]={}))[e.uniqueID]||(h[e.uniqueID]={}),s&&s===e.nodeName.toLowerCase())e=e[r]||e;else{if((u=c[i])&&u[0]===C&&u[1]===a)return d[2]=u[2];if(c[i]=d,d[2]=t(e,n,l))return!0}return!1}}function wt(t){return t.length>1?function(e,n,r){for(var s=t.length;s--;)if(!t[s](e,n,r))return!1;return!0}:t[0]}function Ct(t,e,n,r,s){for(var i,o=[],a=0,l=t.length,u=null!=e;a<l;a++)(i=t[a])&&(n&&!n(i,r,s)||(o.push(i),u&&e.push(a)));return o}function St(t,e,n,r,s,i){return r&&!r[x]&&(r=St(r)),s&&!s[x]&&(s=St(s,i)),ut((function(i,o,a,l){var u,c,h,d=[],p=[],f=o.length,m=i||function(t,e,n){for(var r=0,s=e.length;r<s;r++)at(t,e[r],n);return n}(e||"*",a.nodeType?[a]:a,[]),g=!t||!i&&e?m:Ct(m,d,t,a,l),y=n?s||(i?t:f||r)?[]:o:g;if(n&&n(g,y,a,l),r)for(u=Ct(y,p),r(u,[],a,l),c=u.length;c--;)(h=u[c])&&(y[p[c]]=!(g[p[c]]=h));if(i){if(s||t){if(s){for(u=[],c=y.length;c--;)(h=y[c])&&u.push(g[c]=h);s(null,y=[],u,l)}for(c=y.length;c--;)(h=y[c])&&(u=s?F(i,h):d[c])>-1&&(i[u]=!(o[u]=h))}}else y=Ct(y===o?y.splice(f,y.length):y),s?s(null,o,y,l):D.apply(o,y)}))}function _t(t){for(var e,n,s,i=t.length,o=r.relative[t[0].type],a=o||r.relative[" "],l=o?1:0,c=xt((function(t){return t===e}),a,!0),h=xt((function(t){return F(e,t)>-1}),a,!0),d=[function(t,n,r){var s=!o&&(r||n!==u)||((e=n).nodeType?c(t,n,r):h(t,n,r));return e=null,s}];l<i;l++)if(n=r.relative[t[l].type])d=[xt(wt(d),n)];else{if((n=r.filter[t[l].type].apply(null,t[l].matches))[x]){for(s=++l;s<i&&!r.relative[t[s].type];s++);return St(l>1&&wt(d),l>1&&vt(t.slice(0,l-1).concat({value:" "===t[l-2].type?"*":""})).replace(U,"$1"),n,l<s&&_t(t.slice(l,s)),s<i&&_t(t=t.slice(s)),s<i&&vt(t))}d.push(n)}return wt(d)}return bt.prototype=r.filters=r.pseudos,r.setFilters=new bt,o=at.tokenize=function(t,e){var n,s,i,o,a,l,u,c=E[t+" "];if(c)return e?0:c.slice(0);for(a=t,l=[],u=r.preFilter;a;){for(o in n&&!(s=W.exec(a))||(s&&(a=a.slice(s[0].length)||a),l.push(i=[])),n=!1,(s=j.exec(a))&&(n=s.shift(),i.push({value:n,type:s[0].replace(U," ")}),a=a.slice(n.length)),r.filter)!(s=K[o].exec(a))||u[o]&&!(s=u[o](s))||(n=s.shift(),i.push({value:n,type:o,matches:s}),a=a.slice(n.length));if(!n)break}return e?a.length:a?at.error(t):E(t,l).slice(0)},a=at.compile=function(t,e){var n,s=[],i=[],a=k[t+" "];if(!a){for(e||(e=o(t)),n=e.length;n--;)(a=_t(e[n]))[x]?s.push(a):i.push(a);(a=k(t,function(t,e){var n=e.length>0,s=t.length>0,i=function(i,o,a,l,c){var h,f,g,y=0,b="0",v=i&&[],x=[],w=u,S=i||s&&r.find.TAG("*",c),_=C+=null==w?1:Math.random()||.1,E=S.length;for(c&&(u=o==p||o||c);b!==E&&null!=(h=S[b]);b++){if(s&&h){for(f=0,o||h.ownerDocument==p||(d(h),a=!m);g=t[f++];)if(g(h,o||p,a)){l.push(h);break}c&&(C=_)}n&&((h=!g&&h)&&y--,i&&v.push(h))}if(y+=b,n&&b!==y){for(f=0;g=e[f++];)g(v,x,o,a);if(i){if(y>0)for(;b--;)v[b]||x[b]||(x[b]=R.call(l));x=Ct(x)}D.apply(l,x),c&&!i&&x.length>0&&y+e.length>1&&at.uniqueSort(l)}return c&&(C=_,u=w),v};return n?ut(i):i}(i,s))).selector=t}return a},l=at.select=function(t,e,n,s){var i,l,u,c,h,d="function"==typeof t&&t,p=!s&&o(t=d.selector||t);if(n=n||[],1===p.length){if((l=p[0]=p[0].slice(0)).length>2&&"ID"===(u=l[0]).type&&9===e.nodeType&&m&&r.relative[l[1].type]){if(!(e=(r.find.ID(u.matches[0].replace(et,nt),e)||[])[0]))return n;d&&(e=e.parentNode),t=t.slice(l.shift().value.length)}for(i=K.needsContext.test(t)?0:l.length;i--&&!r.relative[c=(u=l[i]).type];)if((h=r.find[c])&&(s=h(u.matches[0].replace(et,nt),tt.test(l[0].type)&&yt(e.parentNode)||e))){if(l.splice(i,1),!(t=s.length&&vt(l)))return D.apply(n,s),n;break}}return(d||a(t,p))(s,e,!m,n,!e||tt.test(t)&&yt(e.parentNode)||e),n},n.sortStable=x.split("").sort(I).join("")===x,n.detectDuplicates=!!h,d(),n.sortDetached=ct((function(t){return 1&t.compareDocumentPosition(p.createElement("fieldset"))})),ct((function(t){return t.innerHTML="<a href='#'></a>","#"===t.firstChild.getAttribute("href")}))||ht("type|href|height|width",(function(t,e,n){if(!n)return t.getAttribute(e,"type"===e.toLowerCase()?1:2)})),n.attributes&&ct((function(t){return t.innerHTML="<input/>",t.firstChild.setAttribute("value",""),""===t.firstChild.getAttribute("value")}))||ht("value",(function(t,e,n){if(!n&&"input"===t.nodeName.toLowerCase())return t.defaultValue})),ct((function(t){return null==t.getAttribute("disabled")}))||ht(M,(function(t,e,n){var r;if(!n)return!0===t[e]?e.toLowerCase():(r=t.getAttributeNode(e))&&r.specified?r.value:null})),at}(n);S.find=E,S.expr=E.selectors,S.expr[":"]=S.expr.pseudos,S.uniqueSort=S.unique=E.uniqueSort,S.text=E.getText,S.isXMLDoc=E.isXML,S.contains=E.contains,S.escapeSelector=E.escape;var k=function(t,e,n){for(var r=[],s=void 0!==n;(t=t[e])&&9!==t.nodeType;)if(1===t.nodeType){if(s&&S(t).is(n))break;r.push(t)}return r},A=function(t,e){for(var n=[];t;t=t.nextSibling)1===t.nodeType&&t!==e&&n.push(t);return n},I=S.expr.match.needsContext;function N(t,e){return t.nodeName&&t.nodeName.toLowerCase()===e.toLowerCase()}var T=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function R(t,e,n){return y(e)?S.grep(t,(function(t,r){return!!e.call(t,r,t)!==n})):e.nodeType?S.grep(t,(function(t){return t===e!==n})):"string"!=typeof e?S.grep(t,(function(t){return c.call(e,t)>-1!==n})):S.filter(e,t,n)}S.filter=function(t,e,n){var r=e[0];return n&&(t=":not("+t+")"),1===e.length&&1===r.nodeType?S.find.matchesSelector(r,t)?[r]:[]:S.find.matches(t,S.grep(e,(function(t){return 1===t.nodeType})))},S.fn.extend({find:function(t){var e,n,r=this.length,s=this;if("string"!=typeof t)return this.pushStack(S(t).filter((function(){for(e=0;e<r;e++)if(S.contains(s[e],this))return!0})));for(n=this.pushStack([]),e=0;e<r;e++)S.find(t,s[e],n);return r>1?S.uniqueSort(n):n},filter:function(t){return this.pushStack(R(this,t||[],!1))},not:function(t){return this.pushStack(R(this,t||[],!0))},is:function(t){return!!R(this,"string"==typeof t&&I.test(t)?S(t):t||[],!1).length}});var $,D=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(S.fn.init=function(t,e,n){var r,s;if(!t)return this;if(n=n||$,"string"==typeof t){if(!(r="<"===t[0]&&">"===t[t.length-1]&&t.length>=3?[null,t,null]:D.exec(t))||!r[1]&&e)return!e||e.jquery?(e||n).find(t):this.constructor(e).find(t);if(r[1]){if(S.merge(this,S.parseHTML(r[1],(e=e instanceof S?e[0]:e)&&e.nodeType?e.ownerDocument||e:v,!0)),T.test(r[1])&&S.isPlainObject(e))for(r in e)y(this[r])?this[r](e[r]):this.attr(r,e[r]);return this}return(s=v.getElementById(r[2]))&&(this[0]=s,this.length=1),this}return t.nodeType?(this[0]=t,this.length=1,this):y(t)?void 0!==n.ready?n.ready(t):t(S):S.makeArray(t,this)}).prototype=S.fn,$=S(v);var O=/^(?:parents|prev(?:Until|All))/,F={children:!0,contents:!0,next:!0,prev:!0};function M(t,e){for(;(t=t[e])&&1!==t.nodeType;);return t}S.fn.extend({has:function(t){var e=S(t,this),n=e.length;return this.filter((function(){for(var t=0;t<n;t++)if(S.contains(this,e[t]))return!0}))},closest:function(t,e){var n,r=0,s=this.length,i=[],o="string"!=typeof t&&S(t);if(!I.test(t))for(;r<s;r++)for(n=this[r];n&&n!==e;n=n.parentNode)if(n.nodeType<11&&(o?o.index(n)>-1:1===n.nodeType&&S.find.matchesSelector(n,t))){i.push(n);break}return this.pushStack(i.length>1?S.uniqueSort(i):i)},index:function(t){return t?"string"==typeof t?c.call(S(t),this[0]):c.call(this,t.jquery?t[0]:t):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(t,e){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(t,e))))},addBack:function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}}),S.each({parent:function(t){var e=t.parentNode;return e&&11!==e.nodeType?e:null},parents:function(t){return k(t,"parentNode")},parentsUntil:function(t,e,n){return k(t,"parentNode",n)},next:function(t){return M(t,"nextSibling")},prev:function(t){return M(t,"previousSibling")},nextAll:function(t){return k(t,"nextSibling")},prevAll:function(t){return k(t,"previousSibling")},nextUntil:function(t,e,n){return k(t,"nextSibling",n)},prevUntil:function(t,e,n){return k(t,"previousSibling",n)},siblings:function(t){return A((t.parentNode||{}).firstChild,t)},children:function(t){return A(t.firstChild)},contents:function(t){return null!=t.contentDocument&&o(t.contentDocument)?t.contentDocument:(N(t,"template")&&(t=t.content||t),S.merge([],t.childNodes))}},(function(t,e){S.fn[t]=function(n,r){var s=S.map(this,e,n);return"Until"!==t.slice(-5)&&(r=n),r&&"string"==typeof r&&(s=S.filter(r,s)),this.length>1&&(F[t]||S.uniqueSort(s),O.test(t)&&s.reverse()),this.pushStack(s)}}));var L=/[^\x20\t\r\n\f]+/g;function P(t){return t}function z(t){throw t}function B(t,e,n,r){var s;try{t&&y(s=t.promise)?s.call(t).done(e).fail(n):t&&y(s=t.then)?s.call(t,e,n):e.apply(void 0,[t].slice(r))}catch(t){n.apply(void 0,[t])}}S.Callbacks=function(t){t="string"==typeof t?function(t){var e={};return S.each(t.match(L)||[],(function(t,n){e[n]=!0})),e}(t):S.extend({},t);var e,n,r,s,i=[],o=[],a=-1,l=function(){for(s=s||t.once,r=e=!0;o.length;a=-1)for(n=o.shift();++a<i.length;)!1===i[a].apply(n[0],n[1])&&t.stopOnFalse&&(a=i.length,n=!1);t.memory||(n=!1),e=!1,s&&(i=n?[]:"")},u={add:function(){return i&&(n&&!e&&(a=i.length-1,o.push(n)),function e(n){S.each(n,(function(n,r){y(r)?t.unique&&u.has(r)||i.push(r):r&&r.length&&"string"!==C(r)&&e(r)}))}(arguments),n&&!e&&l()),this},remove:function(){return S.each(arguments,(function(t,e){for(var n;(n=S.inArray(e,i,n))>-1;)i.splice(n,1),n<=a&&a--})),this},has:function(t){return t?S.inArray(t,i)>-1:i.length>0},empty:function(){return i&&(i=[]),this},disable:function(){return s=o=[],i=n="",this},disabled:function(){return!i},lock:function(){return s=o=[],n||e||(i=n=""),this},locked:function(){return!!s},fireWith:function(t,n){return s||(n=[t,(n=n||[]).slice?n.slice():n],o.push(n),e||l()),this},fire:function(){return u.fireWith(this,arguments),this},fired:function(){return!!r}};return u},S.extend({Deferred:function(t){var e=[["notify","progress",S.Callbacks("memory"),S.Callbacks("memory"),2],["resolve","done",S.Callbacks("once memory"),S.Callbacks("once memory"),0,"resolved"],["reject","fail",S.Callbacks("once memory"),S.Callbacks("once memory"),1,"rejected"]],r="pending",s={state:function(){return r},always:function(){return i.done(arguments).fail(arguments),this},catch:function(t){return s.then(null,t)},pipe:function(){var t=arguments;return S.Deferred((function(n){S.each(e,(function(e,r){var s=y(t[r[4]])&&t[r[4]];i[r[1]]((function(){var t=s&&s.apply(this,arguments);t&&y(t.promise)?t.promise().progress(n.notify).done(n.resolve).fail(n.reject):n[r[0]+"With"](this,s?[t]:arguments)}))})),t=null})).promise()},then:function(t,r,s){var i=0;function o(t,e,r,s){return function(){var a=this,l=arguments,u=function(){var n,u;if(!(t<i)){if((n=r.apply(a,l))===e.promise())throw new TypeError("Thenable self-resolution");y(u=n&&("object"==typeof n||"function"==typeof n)&&n.then)?s?u.call(n,o(i,e,P,s),o(i,e,z,s)):(i++,u.call(n,o(i,e,P,s),o(i,e,z,s),o(i,e,P,e.notifyWith))):(r!==P&&(a=void 0,l=[n]),(s||e.resolveWith)(a,l))}},c=s?u:function(){try{u()}catch(n){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(n,c.stackTrace),t+1>=i&&(r!==z&&(a=void 0,l=[n]),e.rejectWith(a,l))}};t?c():(S.Deferred.getStackHook&&(c.stackTrace=S.Deferred.getStackHook()),n.setTimeout(c))}}return S.Deferred((function(n){e[0][3].add(o(0,n,y(s)?s:P,n.notifyWith)),e[1][3].add(o(0,n,y(t)?t:P)),e[2][3].add(o(0,n,y(r)?r:z))})).promise()},promise:function(t){return null!=t?S.extend(t,s):s}},i={};return S.each(e,(function(t,n){var o=n[2],a=n[5];s[n[1]]=o.add,a&&o.add((function(){r=a}),e[3-t][2].disable,e[3-t][3].disable,e[0][2].lock,e[0][3].lock),o.add(n[3].fire),i[n[0]]=function(){return i[n[0]+"With"](this===i?void 0:this,arguments),this},i[n[0]+"With"]=o.fireWith})),s.promise(i),t&&t.call(i,i),i},when:function(t){var e=arguments.length,n=e,r=Array(n),s=a.call(arguments),i=S.Deferred(),o=function(t){return function(n){r[t]=this,s[t]=arguments.length>1?a.call(arguments):n,--e||i.resolveWith(r,s)}};if(e<=1&&(B(t,i.done(o(n)).resolve,i.reject,!e),"pending"===i.state()||y(s[n]&&s[n].then)))return i.then();for(;n--;)B(s[n],o(n),i.reject);return i.promise()}});var V=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;S.Deferred.exceptionHook=function(t,e){n.console&&n.console.warn&&t&&V.test(t.name)&&n.console.warn("jQuery.Deferred exception: "+t.message,t.stack,e)},S.readyException=function(t){n.setTimeout((function(){throw t}))};var U=S.Deferred();function W(){v.removeEventListener("DOMContentLoaded",W),n.removeEventListener("load",W),S.ready()}S.fn.ready=function(t){return U.then(t).catch((function(t){S.readyException(t)})),this},S.extend({isReady:!1,readyWait:1,ready:function(t){(!0===t?--S.readyWait:S.isReady)||(S.isReady=!0,!0!==t&&--S.readyWait>0||U.resolveWith(v,[S]))}}),S.ready.then=U.then,"complete"===v.readyState||"loading"!==v.readyState&&!v.documentElement.doScroll?n.setTimeout(S.ready):(v.addEventListener("DOMContentLoaded",W),n.addEventListener("load",W));var j=function(t,e,n,r,s,i,o){var a=0,l=t.length,u=null==n;if("object"===C(n))for(a in s=!0,n)j(t,e,a,n[a],!0,i,o);else if(void 0!==r&&(s=!0,y(r)||(o=!0),u&&(o?(e.call(t,r),e=null):(u=e,e=function(t,e,n){return u.call(S(t),n)})),e))for(;a<l;a++)e(t[a],n,o?r:r.call(t[a],a,e(t[a],n)));return s?t:u?e.call(t):l?e(t[0],n):i},H=/^-ms-/,q=/-([a-z])/g;function G(t,e){return e.toUpperCase()}function K(t){return t.replace(H,"ms-").replace(q,G)}var X=function(t){return 1===t.nodeType||9===t.nodeType||!+t.nodeType};function Y(){this.expando=S.expando+Y.uid++}Y.uid=1,Y.prototype={cache:function(t){var e=t[this.expando];return e||(e={},X(t)&&(t.nodeType?t[this.expando]=e:Object.defineProperty(t,this.expando,{value:e,configurable:!0}))),e},set:function(t,e,n){var r,s=this.cache(t);if("string"==typeof e)s[K(e)]=n;else for(r in e)s[K(r)]=e[r];return s},get:function(t,e){return void 0===e?this.cache(t):t[this.expando]&&t[this.expando][K(e)]},access:function(t,e,n){return void 0===e||e&&"string"==typeof e&&void 0===n?this.get(t,e):(this.set(t,e,n),void 0!==n?n:e)},remove:function(t,e){var n,r=t[this.expando];if(void 0!==r){if(void 0!==e){n=(e=Array.isArray(e)?e.map(K):(e=K(e))in r?[e]:e.match(L)||[]).length;for(;n--;)delete r[e[n]]}(void 0===e||S.isEmptyObject(r))&&(t.nodeType?t[this.expando]=void 0:delete t[this.expando])}},hasData:function(t){var e=t[this.expando];return void 0!==e&&!S.isEmptyObject(e)}};var Z=new Y,J=new Y,Q=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,tt=/[A-Z]/g;function et(t,e,n){var r;if(void 0===n&&1===t.nodeType)if(r="data-"+e.replace(tt,"-$&").toLowerCase(),"string"==typeof(n=t.getAttribute(r))){try{n=function(t){return"true"===t||"false"!==t&&("null"===t?null:t===+t+""?+t:Q.test(t)?JSON.parse(t):t)}(n)}catch(s){}J.set(t,e,n)}else n=void 0;return n}S.extend({hasData:function(t){return J.hasData(t)||Z.hasData(t)},data:function(t,e,n){return J.access(t,e,n)},removeData:function(t,e){J.remove(t,e)},_data:function(t,e,n){return Z.access(t,e,n)},_removeData:function(t,e){Z.remove(t,e)}}),S.fn.extend({data:function(t,e){var n,r,s,i=this[0],o=i&&i.attributes;if(void 0===t){if(this.length&&(s=J.get(i),1===i.nodeType&&!Z.get(i,"hasDataAttrs"))){for(n=o.length;n--;)o[n]&&0===(r=o[n].name).indexOf("data-")&&(r=K(r.slice(5)),et(i,r,s[r]));Z.set(i,"hasDataAttrs",!0)}return s}return"object"==typeof t?this.each((function(){J.set(this,t)})):j(this,(function(e){var n;if(i&&void 0===e)return void 0!==(n=J.get(i,t))||void 0!==(n=et(i,t))?n:void 0;this.each((function(){J.set(this,t,e)}))}),null,e,arguments.length>1,null,!0)},removeData:function(t){return this.each((function(){J.remove(this,t)}))}}),S.extend({queue:function(t,e,n){var r;if(t)return r=Z.get(t,e=(e||"fx")+"queue"),n&&(!r||Array.isArray(n)?r=Z.access(t,e,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(t,e){var n=S.queue(t,e=e||"fx"),r=n.length,s=n.shift(),i=S._queueHooks(t,e);"inprogress"===s&&(s=n.shift(),r--),s&&("fx"===e&&n.unshift("inprogress"),delete i.stop,s.call(t,(function(){S.dequeue(t,e)}),i)),!r&&i&&i.empty.fire()},_queueHooks:function(t,e){var n=e+"queueHooks";return Z.get(t,n)||Z.access(t,n,{empty:S.Callbacks("once memory").add((function(){Z.remove(t,[e+"queue",n])}))})}}),S.fn.extend({queue:function(t,e){var n=2;return"string"!=typeof t&&(e=t,t="fx",n--),arguments.length<n?S.queue(this[0],t):void 0===e?this:this.each((function(){var n=S.queue(this,t,e);S._queueHooks(this,t),"fx"===t&&"inprogress"!==n[0]&&S.dequeue(this,t)}))},dequeue:function(t){return this.each((function(){S.dequeue(this,t)}))},clearQueue:function(t){return this.queue(t||"fx",[])},promise:function(t,e){var n,r=1,s=S.Deferred(),i=this,o=this.length,a=function(){--r||s.resolveWith(i,[i])};for("string"!=typeof t&&(e=t,t=void 0),t=t||"fx";o--;)(n=Z.get(i[o],t+"queueHooks"))&&n.empty&&(r++,n.empty.add(a));return a(),s.promise(e)}});var nt=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,rt=new RegExp("^(?:([+-])=|)("+nt+")([a-z%]*)$","i"),st=["Top","Right","Bottom","Left"],it=v.documentElement,ot=function(t){return S.contains(t.ownerDocument,t)},at={composed:!0};it.getRootNode&&(ot=function(t){return S.contains(t.ownerDocument,t)||t.getRootNode(at)===t.ownerDocument});var lt=function(t,e){return"none"===(t=e||t).style.display||""===t.style.display&&ot(t)&&"none"===S.css(t,"display")};function ut(t,e,n,r){var s,i,o=20,a=r?function(){return r.cur()}:function(){return S.css(t,e,"")},l=a(),u=n&&n[3]||(S.cssNumber[e]?"":"px"),c=t.nodeType&&(S.cssNumber[e]||"px"!==u&&+l)&&rt.exec(S.css(t,e));if(c&&c[3]!==u){for(u=u||c[3],c=+(l/=2)||1;o--;)S.style(t,e,c+u),(1-i)*(1-(i=a()/l||.5))<=0&&(o=0),c/=i;S.style(t,e,(c*=2)+u),n=n||[]}return n&&(c=+c||+l||0,s=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=u,r.start=c,r.end=s)),s}var ct={};function ht(t){var e,n=t.ownerDocument,r=t.nodeName,s=ct[r];return s||(e=n.body.appendChild(n.createElement(r)),s=S.css(e,"display"),e.parentNode.removeChild(e),"none"===s&&(s="block"),ct[r]=s,s)}function dt(t,e){for(var n,r,s=[],i=0,o=t.length;i<o;i++)(r=t[i]).style&&(n=r.style.display,e?("none"===n&&(s[i]=Z.get(r,"display")||null,s[i]||(r.style.display="")),""===r.style.display&&lt(r)&&(s[i]=ht(r))):"none"!==n&&(s[i]="none",Z.set(r,"display",n)));for(i=0;i<o;i++)null!=s[i]&&(t[i].style.display=s[i]);return t}S.fn.extend({show:function(){return dt(this,!0)},hide:function(){return dt(this)},toggle:function(t){return"boolean"==typeof t?t?this.show():this.hide():this.each((function(){lt(this)?S(this).show():S(this).hide()}))}});var pt,ft,mt=/^(?:checkbox|radio)$/i,gt=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,yt=/^$|^module$|\/(?:java|ecma)script/i;pt=v.createDocumentFragment().appendChild(v.createElement("div")),(ft=v.createElement("input")).setAttribute("type","radio"),ft.setAttribute("checked","checked"),ft.setAttribute("name","t"),pt.appendChild(ft),g.checkClone=pt.cloneNode(!0).cloneNode(!0).lastChild.checked,pt.innerHTML="<textarea>x</textarea>",g.noCloneChecked=!!pt.cloneNode(!0).lastChild.defaultValue,pt.innerHTML="<option></option>",g.option=!!pt.lastChild;var bt={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function vt(t,e){var n;return n=void 0!==t.getElementsByTagName?t.getElementsByTagName(e||"*"):void 0!==t.querySelectorAll?t.querySelectorAll(e||"*"):[],void 0===e||e&&N(t,e)?S.merge([t],n):n}function xt(t,e){for(var n=0,r=t.length;n<r;n++)Z.set(t[n],"globalEval",!e||Z.get(e[n],"globalEval"))}bt.tbody=bt.tfoot=bt.colgroup=bt.caption=bt.thead,bt.th=bt.td,g.option||(bt.optgroup=bt.option=[1,"<select multiple='multiple'>","</select>"]);var wt=/<|&#?\w+;/;function Ct(t,e,n,r,s){for(var i,o,a,l,u,c,h=e.createDocumentFragment(),d=[],p=0,f=t.length;p<f;p++)if((i=t[p])||0===i)if("object"===C(i))S.merge(d,i.nodeType?[i]:i);else if(wt.test(i)){for(o=o||h.appendChild(e.createElement("div")),a=(gt.exec(i)||["",""])[1].toLowerCase(),o.innerHTML=(l=bt[a]||bt._default)[1]+S.htmlPrefilter(i)+l[2],c=l[0];c--;)o=o.lastChild;S.merge(d,o.childNodes),(o=h.firstChild).textContent=""}else d.push(e.createTextNode(i));for(h.textContent="",p=0;i=d[p++];)if(r&&S.inArray(i,r)>-1)s&&s.push(i);else if(u=ot(i),o=vt(h.appendChild(i),"script"),u&&xt(o),n)for(c=0;i=o[c++];)yt.test(i.type||"")&&n.push(i);return h}var St=/^key/,_t=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Et=/^([^.]*)(?:\.(.+)|)/;function kt(){return!0}function At(){return!1}function It(t,e){return t===function(){try{return v.activeElement}catch(t){}}()==("focus"===e)}function Nt(t,e,n,r,s,i){var o,a;if("object"==typeof e){for(a in"string"!=typeof n&&(r=r||n,n=void 0),e)Nt(t,a,n,r,e[a],i);return t}if(null==r&&null==s?(s=n,r=n=void 0):null==s&&("string"==typeof n?(s=r,r=void 0):(s=r,r=n,n=void 0)),!1===s)s=At;else if(!s)return t;return 1===i&&(o=s,(s=function(t){return S().off(t),o.apply(this,arguments)}).guid=o.guid||(o.guid=S.guid++)),t.each((function(){S.event.add(this,e,s,r,n)}))}function Tt(t,e,n){n?(Z.set(t,e,!1),S.event.add(t,e,{namespace:!1,handler:function(t){var r,s,i=Z.get(this,e);if(1&t.isTrigger&&this[e]){if(i.length)(S.event.special[e]||{}).delegateType&&t.stopPropagation();else if(i=a.call(arguments),Z.set(this,e,i),r=n(this,e),this[e](),i!==(s=Z.get(this,e))||r?Z.set(this,e,!1):s={},i!==s)return t.stopImmediatePropagation(),t.preventDefault(),s.value}else i.length&&(Z.set(this,e,{value:S.event.trigger(S.extend(i[0],S.Event.prototype),i.slice(1),this)}),t.stopImmediatePropagation())}})):void 0===Z.get(t,e)&&S.event.add(t,e,kt)}S.event={global:{},add:function(t,e,n,r,s){var i,o,a,l,u,c,h,d,p,f,m,g=Z.get(t);if(X(t))for(n.handler&&(n=(i=n).handler,s=i.selector),s&&S.find.matchesSelector(it,s),n.guid||(n.guid=S.guid++),(l=g.events)||(l=g.events=Object.create(null)),(o=g.handle)||(o=g.handle=function(e){return void 0!==S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),u=(e=(e||"").match(L)||[""]).length;u--;)p=m=(a=Et.exec(e[u])||[])[1],f=(a[2]||"").split(".").sort(),p&&(h=S.event.special[p]||{},h=S.event.special[p=(s?h.delegateType:h.bindType)||p]||{},c=S.extend({type:p,origType:m,data:r,handler:n,guid:n.guid,selector:s,needsContext:s&&S.expr.match.needsContext.test(s),namespace:f.join(".")},i),(d=l[p])||((d=l[p]=[]).delegateCount=0,h.setup&&!1!==h.setup.call(t,r,f,o)||t.addEventListener&&t.addEventListener(p,o)),h.add&&(h.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),s?d.splice(d.delegateCount++,0,c):d.push(c),S.event.global[p]=!0)},remove:function(t,e,n,r,s){var i,o,a,l,u,c,h,d,p,f,m,g=Z.hasData(t)&&Z.get(t);if(g&&(l=g.events)){for(u=(e=(e||"").match(L)||[""]).length;u--;)if(p=m=(a=Et.exec(e[u])||[])[1],f=(a[2]||"").split(".").sort(),p){for(h=S.event.special[p]||{},d=l[p=(r?h.delegateType:h.bindType)||p]||[],a=a[2]&&new RegExp("(^|\\.)"+f.join("\\.(?:.*\\.|)")+"(\\.|$)"),o=i=d.length;i--;)c=d[i],!s&&m!==c.origType||n&&n.guid!==c.guid||a&&!a.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(d.splice(i,1),c.selector&&d.delegateCount--,h.remove&&h.remove.call(t,c));o&&!d.length&&(h.teardown&&!1!==h.teardown.call(t,f,g.handle)||S.removeEvent(t,p,g.handle),delete l[p])}else for(p in l)S.event.remove(t,p+e[u],n,r,!0);S.isEmptyObject(l)&&Z.remove(t,"handle events")}},dispatch:function(t){var e,n,r,s,i,o,a=new Array(arguments.length),l=S.event.fix(t),u=(Z.get(this,"events")||Object.create(null))[l.type]||[],c=S.event.special[l.type]||{};for(a[0]=l,e=1;e<arguments.length;e++)a[e]=arguments[e];if(l.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,l)){for(o=S.event.handlers.call(this,l,u),e=0;(s=o[e++])&&!l.isPropagationStopped();)for(l.currentTarget=s.elem,n=0;(i=s.handlers[n++])&&!l.isImmediatePropagationStopped();)l.rnamespace&&!1!==i.namespace&&!l.rnamespace.test(i.namespace)||(l.handleObj=i,l.data=i.data,void 0!==(r=((S.event.special[i.origType]||{}).handle||i.handler).apply(s.elem,a))&&!1===(l.result=r)&&(l.preventDefault(),l.stopPropagation()));return c.postDispatch&&c.postDispatch.call(this,l),l.result}},handlers:function(t,e){var n,r,s,i,o,a=[],l=e.delegateCount,u=t.target;if(l&&u.nodeType&&!("click"===t.type&&t.button>=1))for(;u!==this;u=u.parentNode||this)if(1===u.nodeType&&("click"!==t.type||!0!==u.disabled)){for(i=[],o={},n=0;n<l;n++)void 0===o[s=(r=e[n]).selector+" "]&&(o[s]=r.needsContext?S(s,this).index(u)>-1:S.find(s,this,null,[u]).length),o[s]&&i.push(r);i.length&&a.push({elem:u,handlers:i})}return u=this,l<e.length&&a.push({elem:u,handlers:e.slice(l)}),a},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:y(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(t){return t[S.expando]?t:new S.Event(t)},special:{load:{noBubble:!0},click:{setup:function(t){var e=this||t;return mt.test(e.type)&&e.click&&N(e,"input")&&Tt(e,"click",kt),!1},trigger:function(t){var e=this||t;return mt.test(e.type)&&e.click&&N(e,"input")&&Tt(e,"click"),!0},_default:function(t){var e=t.target;return mt.test(e.type)&&e.click&&N(e,"input")&&Z.get(e,"click")||N(e,"a")}},beforeunload:{postDispatch:function(t){void 0!==t.result&&t.originalEvent&&(t.originalEvent.returnValue=t.result)}}}},S.removeEvent=function(t,e,n){t.removeEventListener&&t.removeEventListener(e,n)},S.Event=function(t,e){if(!(this instanceof S.Event))return new S.Event(t,e);t&&t.type?(this.originalEvent=t,this.type=t.type,this.isDefaultPrevented=t.defaultPrevented||void 0===t.defaultPrevented&&!1===t.returnValue?kt:At,this.target=t.target&&3===t.target.nodeType?t.target.parentNode:t.target,this.currentTarget=t.currentTarget,this.relatedTarget=t.relatedTarget):this.type=t,e&&S.extend(this,e),this.timeStamp=t&&t.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:At,isPropagationStopped:At,isImmediatePropagationStopped:At,isSimulated:!1,preventDefault:function(){var t=this.originalEvent;this.isDefaultPrevented=kt,t&&!this.isSimulated&&t.preventDefault()},stopPropagation:function(){var t=this.originalEvent;this.isPropagationStopped=kt,t&&!this.isSimulated&&t.stopPropagation()},stopImmediatePropagation:function(){var t=this.originalEvent;this.isImmediatePropagationStopped=kt,t&&!this.isSimulated&&t.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,char:!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(t){var e=t.button;return null==t.which&&St.test(t.type)?null!=t.charCode?t.charCode:t.keyCode:!t.which&&void 0!==e&&_t.test(t.type)?1&e?1:2&e?3:4&e?2:0:t.which}},S.event.addProp),S.each({focus:"focusin",blur:"focusout"},(function(t,e){S.event.special[t]={setup:function(){return Tt(this,t,It),!1},trigger:function(){return Tt(this,t),!0},delegateType:e}})),S.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},(function(t,e){S.event.special[t]={delegateType:e,bindType:e,handle:function(t){var n,r=this,s=t.relatedTarget,i=t.handleObj;return s&&(s===r||S.contains(r,s))||(t.type=i.origType,n=i.handler.apply(this,arguments),t.type=e),n}}})),S.fn.extend({on:function(t,e,n,r){return Nt(this,t,e,n,r)},one:function(t,e,n,r){return Nt(this,t,e,n,r,1)},off:function(t,e,n){var r,s;if(t&&t.preventDefault&&t.handleObj)return r=t.handleObj,S(t.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof t){for(s in t)this.off(s,e,t[s]);return this}return!1!==e&&"function"!=typeof e||(n=e,e=void 0),!1===n&&(n=At),this.each((function(){S.event.remove(this,t,n,e)}))}});var Rt=/<script|<style|<link/i,$t=/checked\s*(?:[^=]|=\s*.checked.)/i,Dt=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Ot(t,e){return N(t,"table")&&N(11!==e.nodeType?e:e.firstChild,"tr")&&S(t).children("tbody")[0]||t}function Ft(t){return t.type=(null!==t.getAttribute("type"))+"/"+t.type,t}function Mt(t){return"true/"===(t.type||"").slice(0,5)?t.type=t.type.slice(5):t.removeAttribute("type"),t}function Lt(t,e){var n,r,s,i,o,a;if(1===e.nodeType){if(Z.hasData(t)&&(a=Z.get(t).events))for(s in Z.remove(e,"handle events"),a)for(n=0,r=a[s].length;n<r;n++)S.event.add(e,s,a[s][n]);J.hasData(t)&&(i=J.access(t),o=S.extend({},i),J.set(e,o))}}function Pt(t,e){var n=e.nodeName.toLowerCase();"input"===n&&mt.test(t.type)?e.checked=t.checked:"input"!==n&&"textarea"!==n||(e.defaultValue=t.defaultValue)}function zt(t,e,n,r){e=l(e);var s,i,o,a,u,c,h=0,d=t.length,p=d-1,f=e[0],m=y(f);if(m||d>1&&"string"==typeof f&&!g.checkClone&&$t.test(f))return t.each((function(s){var i=t.eq(s);m&&(e[0]=f.call(this,s,i.html())),zt(i,e,n,r)}));if(d&&(i=(s=Ct(e,t[0].ownerDocument,!1,t,r)).firstChild,1===s.childNodes.length&&(s=i),i||r)){for(a=(o=S.map(vt(s,"script"),Ft)).length;h<d;h++)u=s,h!==p&&(u=S.clone(u,!0,!0),a&&S.merge(o,vt(u,"script"))),n.call(t[h],u,h);if(a)for(c=o[o.length-1].ownerDocument,S.map(o,Mt),h=0;h<a;h++)yt.test((u=o[h]).type||"")&&!Z.access(u,"globalEval")&&S.contains(c,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")},c):w(u.textContent.replace(Dt,""),u,c))}return t}function Bt(t,e,n){for(var r,s=e?S.filter(e,t):t,i=0;null!=(r=s[i]);i++)n||1!==r.nodeType||S.cleanData(vt(r)),r.parentNode&&(n&&ot(r)&&xt(vt(r,"script")),r.parentNode.removeChild(r));return t}S.extend({htmlPrefilter:function(t){return t},clone:function(t,e,n){var r,s,i,o,a=t.cloneNode(!0),l=ot(t);if(!(g.noCloneChecked||1!==t.nodeType&&11!==t.nodeType||S.isXMLDoc(t)))for(o=vt(a),r=0,s=(i=vt(t)).length;r<s;r++)Pt(i[r],o[r]);if(e)if(n)for(i=i||vt(t),o=o||vt(a),r=0,s=i.length;r<s;r++)Lt(i[r],o[r]);else Lt(t,a);return(o=vt(a,"script")).length>0&&xt(o,!l&&vt(t,"script")),a},cleanData:function(t){for(var e,n,r,s=S.event.special,i=0;void 0!==(n=t[i]);i++)if(X(n)){if(e=n[Z.expando]){if(e.events)for(r in e.events)s[r]?S.event.remove(n,r):S.removeEvent(n,r,e.handle);n[Z.expando]=void 0}n[J.expando]&&(n[J.expando]=void 0)}}}),S.fn.extend({detach:function(t){return Bt(this,t,!0)},remove:function(t){return Bt(this,t)},text:function(t){return j(this,(function(t){return void 0===t?S.text(this):this.empty().each((function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=t)}))}),null,t,arguments.length)},append:function(){return zt(this,arguments,(function(t){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||Ot(this,t).appendChild(t)}))},prepend:function(){return zt(this,arguments,(function(t){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var e=Ot(this,t);e.insertBefore(t,e.firstChild)}}))},before:function(){return zt(this,arguments,(function(t){this.parentNode&&this.parentNode.insertBefore(t,this)}))},after:function(){return zt(this,arguments,(function(t){this.parentNode&&this.parentNode.insertBefore(t,this.nextSibling)}))},empty:function(){for(var t,e=0;null!=(t=this[e]);e++)1===t.nodeType&&(S.cleanData(vt(t,!1)),t.textContent="");return this},clone:function(t,e){return t=null!=t&&t,e=null==e?t:e,this.map((function(){return S.clone(this,t,e)}))},html:function(t){return j(this,(function(t){var e=this[0]||{},n=0,r=this.length;if(void 0===t&&1===e.nodeType)return e.innerHTML;if("string"==typeof t&&!Rt.test(t)&&!bt[(gt.exec(t)||["",""])[1].toLowerCase()]){t=S.htmlPrefilter(t);try{for(;n<r;n++)1===(e=this[n]||{}).nodeType&&(S.cleanData(vt(e,!1)),e.innerHTML=t);e=0}catch(s){}}e&&this.empty().append(t)}),null,t,arguments.length)},replaceWith:function(){var t=[];return zt(this,arguments,(function(e){var n=this.parentNode;S.inArray(this,t)<0&&(S.cleanData(vt(this)),n&&n.replaceChild(e,this))}),t)}}),S.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},(function(t,e){S.fn[t]=function(t){for(var n,r=[],s=S(t),i=s.length-1,o=0;o<=i;o++)n=o===i?this:this.clone(!0),S(s[o])[e](n),u.apply(r,n.get());return this.pushStack(r)}}));var Vt=new RegExp("^("+nt+")(?!px)[a-z%]+$","i"),Ut=function(t){var e=t.ownerDocument.defaultView;return e&&e.opener||(e=n),e.getComputedStyle(t)},Wt=function(t,e,n){var r,s,i={};for(s in e)i[s]=t.style[s],t.style[s]=e[s];for(s in r=n.call(t),e)t.style[s]=i[s];return r},jt=new RegExp(st.join("|"),"i");function Ht(t,e,n){var r,s,i,o,a=t.style;return(n=n||Ut(t))&&(""!==(o=n.getPropertyValue(e)||n[e])||ot(t)||(o=S.style(t,e)),!g.pixelBoxStyles()&&Vt.test(o)&&jt.test(e)&&(r=a.width,s=a.minWidth,i=a.maxWidth,a.minWidth=a.maxWidth=a.width=o,o=n.width,a.width=r,a.minWidth=s,a.maxWidth=i)),void 0!==o?o+"":o}function qt(t,e){return{get:function(){if(!t())return(this.get=e).apply(this,arguments);delete this.get}}}!function(){function t(){if(c){u.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",c.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",it.appendChild(u).appendChild(c);var t=n.getComputedStyle(c);r="1%"!==t.top,l=12===e(t.marginLeft),c.style.right="60%",o=36===e(t.right),s=36===e(t.width),c.style.position="absolute",i=12===e(c.offsetWidth/3),it.removeChild(u),c=null}}function e(t){return Math.round(parseFloat(t))}var r,s,i,o,a,l,u=v.createElement("div"),c=v.createElement("div");c.style&&(c.style.backgroundClip="content-box",c.cloneNode(!0).style.backgroundClip="",g.clearCloneStyle="content-box"===c.style.backgroundClip,S.extend(g,{boxSizingReliable:function(){return t(),s},pixelBoxStyles:function(){return t(),o},pixelPosition:function(){return t(),r},reliableMarginLeft:function(){return t(),l},scrollboxSize:function(){return t(),i},reliableTrDimensions:function(){var t,e,r,s;return null==a&&(t=v.createElement("table"),e=v.createElement("tr"),r=v.createElement("div"),t.style.cssText="position:absolute;left:-11111px",e.style.height="1px",r.style.height="9px",it.appendChild(t).appendChild(e).appendChild(r),s=n.getComputedStyle(e),a=parseInt(s.height)>3,it.removeChild(t)),a}}))}();var Gt=["Webkit","Moz","ms"],Kt=v.createElement("div").style,Xt={};function Yt(t){return S.cssProps[t]||Xt[t]||(t in Kt?t:Xt[t]=function(t){for(var e=t[0].toUpperCase()+t.slice(1),n=Gt.length;n--;)if((t=Gt[n]+e)in Kt)return t}(t)||t)}var Zt=/^(none|table(?!-c[ea]).+)/,Jt=/^--/,Qt={position:"absolute",visibility:"hidden",display:"block"},te={letterSpacing:"0",fontWeight:"400"};function ee(t,e,n){var r=rt.exec(e);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):e}function ne(t,e,n,r,s,i){var o="width"===e?1:0,a=0,l=0;if(n===(r?"border":"content"))return 0;for(;o<4;o+=2)"margin"===n&&(l+=S.css(t,n+st[o],!0,s)),r?("content"===n&&(l-=S.css(t,"padding"+st[o],!0,s)),"margin"!==n&&(l-=S.css(t,"border"+st[o]+"Width",!0,s))):(l+=S.css(t,"padding"+st[o],!0,s),"padding"!==n?l+=S.css(t,"border"+st[o]+"Width",!0,s):a+=S.css(t,"border"+st[o]+"Width",!0,s));return!r&&i>=0&&(l+=Math.max(0,Math.ceil(t["offset"+e[0].toUpperCase()+e.slice(1)]-i-l-a-.5))||0),l}function re(t,e,n){var r=Ut(t),s=(!g.boxSizingReliable()||n)&&"border-box"===S.css(t,"boxSizing",!1,r),i=s,o=Ht(t,e,r),a="offset"+e[0].toUpperCase()+e.slice(1);if(Vt.test(o)){if(!n)return o;o="auto"}return(!g.boxSizingReliable()&&s||!g.reliableTrDimensions()&&N(t,"tr")||"auto"===o||!parseFloat(o)&&"inline"===S.css(t,"display",!1,r))&&t.getClientRects().length&&(s="border-box"===S.css(t,"boxSizing",!1,r),(i=a in t)&&(o=t[a])),(o=parseFloat(o)||0)+ne(t,e,n||(s?"border":"content"),i,r,o)+"px"}function se(t,e,n,r,s){return new se.prototype.init(t,e,n,r,s)}S.extend({cssHooks:{opacity:{get:function(t,e){if(e){var n=Ht(t,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(t,e,n,r){if(t&&3!==t.nodeType&&8!==t.nodeType&&t.style){var s,i,o,a=K(e),l=Jt.test(e),u=t.style;if(l||(e=Yt(a)),o=S.cssHooks[e]||S.cssHooks[a],void 0===n)return o&&"get"in o&&void 0!==(s=o.get(t,!1,r))?s:u[e];"string"==(i=typeof n)&&(s=rt.exec(n))&&s[1]&&(n=ut(t,e,s),i="number"),null!=n&&n==n&&("number"!==i||l||(n+=s&&s[3]||(S.cssNumber[a]?"":"px")),g.clearCloneStyle||""!==n||0!==e.indexOf("background")||(u[e]="inherit"),o&&"set"in o&&void 0===(n=o.set(t,n,r))||(l?u.setProperty(e,n):u[e]=n))}},css:function(t,e,n,r){var s,i,o,a=K(e);return Jt.test(e)||(e=Yt(a)),(o=S.cssHooks[e]||S.cssHooks[a])&&"get"in o&&(s=o.get(t,!0,n)),void 0===s&&(s=Ht(t,e,r)),"normal"===s&&e in te&&(s=te[e]),""===n||n?(i=parseFloat(s),!0===n||isFinite(i)?i||0:s):s}}),S.each(["height","width"],(function(t,e){S.cssHooks[e]={get:function(t,n,r){if(n)return!Zt.test(S.css(t,"display"))||t.getClientRects().length&&t.getBoundingClientRect().width?re(t,e,r):Wt(t,Qt,(function(){return re(t,e,r)}))},set:function(t,n,r){var s,i=Ut(t),o=!g.scrollboxSize()&&"absolute"===i.position,a=(o||r)&&"border-box"===S.css(t,"boxSizing",!1,i),l=r?ne(t,e,r,a,i):0;return a&&o&&(l-=Math.ceil(t["offset"+e[0].toUpperCase()+e.slice(1)]-parseFloat(i[e])-ne(t,e,"border",!1,i)-.5)),l&&(s=rt.exec(n))&&"px"!==(s[3]||"px")&&(t.style[e]=n,n=S.css(t,e)),ee(0,n,l)}}})),S.cssHooks.marginLeft=qt(g.reliableMarginLeft,(function(t,e){if(e)return(parseFloat(Ht(t,"marginLeft"))||t.getBoundingClientRect().left-Wt(t,{marginLeft:0},(function(){return t.getBoundingClientRect().left})))+"px"})),S.each({margin:"",padding:"",border:"Width"},(function(t,e){S.cssHooks[t+e]={expand:function(n){for(var r=0,s={},i="string"==typeof n?n.split(" "):[n];r<4;r++)s[t+st[r]+e]=i[r]||i[r-2]||i[0];return s}},"margin"!==t&&(S.cssHooks[t+e].set=ee)})),S.fn.extend({css:function(t,e){return j(this,(function(t,e,n){var r,s,i={},o=0;if(Array.isArray(e)){for(r=Ut(t),s=e.length;o<s;o++)i[e[o]]=S.css(t,e[o],!1,r);return i}return void 0!==n?S.style(t,e,n):S.css(t,e)}),t,e,arguments.length>1)}}),S.Tween=se,(se.prototype={constructor:se,init:function(t,e,n,r,s,i){this.elem=t,this.prop=n,this.easing=s||S.easing._default,this.options=e,this.start=this.now=this.cur(),this.end=r,this.unit=i||(S.cssNumber[n]?"":"px")},cur:function(){var t=se.propHooks[this.prop];return t&&t.get?t.get(this):se.propHooks._default.get(this)},run:function(t){var e,n=se.propHooks[this.prop];return this.pos=e=this.options.duration?S.easing[this.easing](t,this.options.duration*t,0,1,this.options.duration):t,this.now=(this.end-this.start)*e+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):se.propHooks._default.set(this),this}}).init.prototype=se.prototype,(se.propHooks={_default:{get:function(t){var e;return 1!==t.elem.nodeType||null!=t.elem[t.prop]&&null==t.elem.style[t.prop]?t.elem[t.prop]:(e=S.css(t.elem,t.prop,""))&&"auto"!==e?e:0},set:function(t){S.fx.step[t.prop]?S.fx.step[t.prop](t):1!==t.elem.nodeType||!S.cssHooks[t.prop]&&null==t.elem.style[Yt(t.prop)]?t.elem[t.prop]=t.now:S.style(t.elem,t.prop,t.now+t.unit)}}}).scrollTop=se.propHooks.scrollLeft={set:function(t){t.elem.nodeType&&t.elem.parentNode&&(t.elem[t.prop]=t.now)}},S.easing={linear:function(t){return t},swing:function(t){return.5-Math.cos(t*Math.PI)/2},_default:"swing"},S.fx=se.prototype.init,S.fx.step={};var ie,oe,ae=/^(?:toggle|show|hide)$/,le=/queueHooks$/;function ue(){oe&&(!1===v.hidden&&n.requestAnimationFrame?n.requestAnimationFrame(ue):n.setTimeout(ue,S.fx.interval),S.fx.tick())}function ce(){return n.setTimeout((function(){ie=void 0})),ie=Date.now()}function he(t,e){var n,r=0,s={height:t};for(e=e?1:0;r<4;r+=2-e)s["margin"+(n=st[r])]=s["padding"+n]=t;return e&&(s.opacity=s.width=t),s}function de(t,e,n){for(var r,s=(pe.tweeners[e]||[]).concat(pe.tweeners["*"]),i=0,o=s.length;i<o;i++)if(r=s[i].call(n,e,t))return r}function pe(t,e,n){var r,s,i=0,o=pe.prefilters.length,a=S.Deferred().always((function(){delete l.elem})),l=function(){if(s)return!1;for(var e=ie||ce(),n=Math.max(0,u.startTime+u.duration-e),r=1-(n/u.duration||0),i=0,o=u.tweens.length;i<o;i++)u.tweens[i].run(r);return a.notifyWith(t,[u,r,n]),r<1&&o?n:(o||a.notifyWith(t,[u,1,0]),a.resolveWith(t,[u]),!1)},u=a.promise({elem:t,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},n),originalProperties:e,originalOptions:n,startTime:ie||ce(),duration:n.duration,tweens:[],createTween:function(e,n){var r=S.Tween(t,u.opts,e,n,u.opts.specialEasing[e]||u.opts.easing);return u.tweens.push(r),r},stop:function(e){var n=0,r=e?u.tweens.length:0;if(s)return this;for(s=!0;n<r;n++)u.tweens[n].run(1);return e?(a.notifyWith(t,[u,1,0]),a.resolveWith(t,[u,e])):a.rejectWith(t,[u,e]),this}}),c=u.props;for(function(t,e){var n,r,s,i,o;for(n in t)if(s=e[r=K(n)],i=t[n],Array.isArray(i)&&(s=i[1],i=t[n]=i[0]),n!==r&&(t[r]=i,delete t[n]),(o=S.cssHooks[r])&&"expand"in o)for(n in i=o.expand(i),delete t[r],i)n in t||(t[n]=i[n],e[n]=s);else e[r]=s}(c,u.opts.specialEasing);i<o;i++)if(r=pe.prefilters[i].call(u,t,c,u.opts))return y(r.stop)&&(S._queueHooks(u.elem,u.opts.queue).stop=r.stop.bind(r)),r;return S.map(c,de,u),y(u.opts.start)&&u.opts.start.call(t,u),u.progress(u.opts.progress).done(u.opts.done,u.opts.complete).fail(u.opts.fail).always(u.opts.always),S.fx.timer(S.extend(l,{elem:t,anim:u,queue:u.opts.queue})),u}S.Animation=S.extend(pe,{tweeners:{"*":[function(t,e){var n=this.createTween(t,e);return ut(n.elem,t,rt.exec(e),n),n}]},tweener:function(t,e){y(t)?(e=t,t=["*"]):t=t.match(L);for(var n,r=0,s=t.length;r<s;r++)(pe.tweeners[n=t[r]]=pe.tweeners[n]||[]).unshift(e)},prefilters:[function(t,e,n){var r,s,i,o,a,l,u,c,h="width"in e||"height"in e,d=this,p={},f=t.style,m=t.nodeType&&lt(t),g=Z.get(t,"fxshow");for(r in n.queue||(null==(o=S._queueHooks(t,"fx")).unqueued&&(o.unqueued=0,a=o.empty.fire,o.empty.fire=function(){o.unqueued||a()}),o.unqueued++,d.always((function(){d.always((function(){o.unqueued--,S.queue(t,"fx").length||o.empty.fire()}))}))),e)if(ae.test(s=e[r])){if(delete e[r],i=i||"toggle"===s,s===(m?"hide":"show")){if("show"!==s||!g||void 0===g[r])continue;m=!0}p[r]=g&&g[r]||S.style(t,r)}if((l=!S.isEmptyObject(e))||!S.isEmptyObject(p))for(r in h&&1===t.nodeType&&(n.overflow=[f.overflow,f.overflowX,f.overflowY],null==(u=g&&g.display)&&(u=Z.get(t,"display")),"none"===(c=S.css(t,"display"))&&(u?c=u:(dt([t],!0),u=t.style.display||u,c=S.css(t,"display"),dt([t]))),("inline"===c||"inline-block"===c&&null!=u)&&"none"===S.css(t,"float")&&(l||(d.done((function(){f.display=u})),null==u&&(u="none"===(c=f.display)?"":c)),f.display="inline-block")),n.overflow&&(f.overflow="hidden",d.always((function(){f.overflow=n.overflow[0],f.overflowX=n.overflow[1],f.overflowY=n.overflow[2]}))),l=!1,p)l||(g?"hidden"in g&&(m=g.hidden):g=Z.access(t,"fxshow",{display:u}),i&&(g.hidden=!m),m&&dt([t],!0),d.done((function(){for(r in m||dt([t]),Z.remove(t,"fxshow"),p)S.style(t,r,p[r])}))),l=de(m?g[r]:0,r,d),r in g||(g[r]=l.start,m&&(l.end=l.start,l.start=0))}],prefilter:function(t,e){e?pe.prefilters.unshift(t):pe.prefilters.push(t)}}),S.speed=function(t,e,n){var r=t&&"object"==typeof t?S.extend({},t):{complete:n||!n&&e||y(t)&&t,duration:t,easing:n&&e||e&&!y(e)&&e};return S.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration=r.duration in S.fx.speeds?S.fx.speeds[r.duration]:S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){y(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(t,e,n,r){return this.filter(lt).css("opacity",0).show().end().animate({opacity:e},t,n,r)},animate:function(t,e,n,r){var s=S.isEmptyObject(t),i=S.speed(e,n,r),o=function(){var e=pe(this,S.extend({},t),i);(s||Z.get(this,"finish"))&&e.stop(!0)};return o.finish=o,s||!1===i.queue?this.each(o):this.queue(i.queue,o)},stop:function(t,e,n){var r=function(t){var e=t.stop;delete t.stop,e(n)};return"string"!=typeof t&&(n=e,e=t,t=void 0),e&&this.queue(t||"fx",[]),this.each((function(){var e=!0,s=null!=t&&t+"queueHooks",i=S.timers,o=Z.get(this);if(s)o[s]&&o[s].stop&&r(o[s]);else for(s in o)o[s]&&o[s].stop&&le.test(s)&&r(o[s]);for(s=i.length;s--;)i[s].elem!==this||null!=t&&i[s].queue!==t||(i[s].anim.stop(n),e=!1,i.splice(s,1));!e&&n||S.dequeue(this,t)}))},finish:function(t){return!1!==t&&(t=t||"fx"),this.each((function(){var e,n=Z.get(this),r=n[t+"queue"],s=n[t+"queueHooks"],i=S.timers,o=r?r.length:0;for(n.finish=!0,S.queue(this,t,[]),s&&s.stop&&s.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===t&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)r[e]&&r[e].finish&&r[e].finish.call(this);delete n.finish}))}}),S.each(["toggle","show","hide"],(function(t,e){var n=S.fn[e];S.fn[e]=function(t,r,s){return null==t||"boolean"==typeof t?n.apply(this,arguments):this.animate(he(e,!0),t,r,s)}})),S.each({slideDown:he("show"),slideUp:he("hide"),slideToggle:he("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},(function(t,e){S.fn[t]=function(t,n,r){return this.animate(e,t,n,r)}})),S.timers=[],S.fx.tick=function(){var t,e=0,n=S.timers;for(ie=Date.now();e<n.length;e++)(t=n[e])()||n[e]!==t||n.splice(e--,1);n.length||S.fx.stop(),ie=void 0},S.fx.timer=function(t){S.timers.push(t),S.fx.start()},S.fx.interval=13,S.fx.start=function(){oe||(oe=!0,ue())},S.fx.stop=function(){oe=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(t,e){return t=S.fx&&S.fx.speeds[t]||t,this.queue(e=e||"fx",(function(e,r){var s=n.setTimeout(e,t);r.stop=function(){n.clearTimeout(s)}}))},function(){var t=v.createElement("input"),e=v.createElement("select").appendChild(v.createElement("option"));t.type="checkbox",g.checkOn=""!==t.value,g.optSelected=e.selected,(t=v.createElement("input")).value="t",t.type="radio",g.radioValue="t"===t.value}();var fe,me=S.expr.attrHandle;S.fn.extend({attr:function(t,e){return j(this,S.attr,t,e,arguments.length>1)},removeAttr:function(t){return this.each((function(){S.removeAttr(this,t)}))}}),S.extend({attr:function(t,e,n){var r,s,i=t.nodeType;if(3!==i&&8!==i&&2!==i)return void 0===t.getAttribute?S.prop(t,e,n):(1===i&&S.isXMLDoc(t)||(s=S.attrHooks[e.toLowerCase()]||(S.expr.match.bool.test(e)?fe:void 0)),void 0!==n?null===n?void S.removeAttr(t,e):s&&"set"in s&&void 0!==(r=s.set(t,n,e))?r:(t.setAttribute(e,n+""),n):s&&"get"in s&&null!==(r=s.get(t,e))?r:null==(r=S.find.attr(t,e))?void 0:r)},attrHooks:{type:{set:function(t,e){if(!g.radioValue&&"radio"===e&&N(t,"input")){var n=t.value;return t.setAttribute("type",e),n&&(t.value=n),e}}}},removeAttr:function(t,e){var n,r=0,s=e&&e.match(L);if(s&&1===t.nodeType)for(;n=s[r++];)t.removeAttribute(n)}}),fe={set:function(t,e,n){return!1===e?S.removeAttr(t,n):t.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(/\w+/g),(function(t,e){var n=me[e]||S.find.attr;me[e]=function(t,e,r){var s,i,o=e.toLowerCase();return r||(i=me[o],me[o]=s,s=null!=n(t,e,r)?o:null,me[o]=i),s}}));var ge=/^(?:input|select|textarea|button)$/i,ye=/^(?:a|area)$/i;function be(t){return(t.match(L)||[]).join(" ")}function ve(t){return t.getAttribute&&t.getAttribute("class")||""}function xe(t){return Array.isArray(t)?t:"string"==typeof t&&t.match(L)||[]}S.fn.extend({prop:function(t,e){return j(this,S.prop,t,e,arguments.length>1)},removeProp:function(t){return this.each((function(){delete this[S.propFix[t]||t]}))}}),S.extend({prop:function(t,e,n){var r,s,i=t.nodeType;if(3!==i&&8!==i&&2!==i)return 1===i&&S.isXMLDoc(t)||(s=S.propHooks[e=S.propFix[e]||e]),void 0!==n?s&&"set"in s&&void 0!==(r=s.set(t,n,e))?r:t[e]=n:s&&"get"in s&&null!==(r=s.get(t,e))?r:t[e]},propHooks:{tabIndex:{get:function(t){var e=S.find.attr(t,"tabindex");return e?parseInt(e,10):ge.test(t.nodeName)||ye.test(t.nodeName)&&t.href?0:-1}}},propFix:{for:"htmlFor",class:"className"}}),g.optSelected||(S.propHooks.selected={get:function(t){return null},set:function(t){}}),S.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],(function(){S.propFix[this.toLowerCase()]=this})),S.fn.extend({addClass:function(t){var e,n,r,s,i,o,a,l=0;if(y(t))return this.each((function(e){S(this).addClass(t.call(this,e,ve(this)))}));if((e=xe(t)).length)for(;n=this[l++];)if(s=ve(n),r=1===n.nodeType&&" "+be(s)+" "){for(o=0;i=e[o++];)r.indexOf(" "+i+" ")<0&&(r+=i+" ");s!==(a=be(r))&&n.setAttribute("class",a)}return this},removeClass:function(t){var e,n,r,s,i,o,a,l=0;if(y(t))return this.each((function(e){S(this).removeClass(t.call(this,e,ve(this)))}));if(!arguments.length)return this.attr("class","");if((e=xe(t)).length)for(;n=this[l++];)if(s=ve(n),r=1===n.nodeType&&" "+be(s)+" "){for(o=0;i=e[o++];)for(;r.indexOf(" "+i+" ")>-1;)r=r.replace(" "+i+" "," ");s!==(a=be(r))&&n.setAttribute("class",a)}return this},toggleClass:function(t,e){var n=typeof t,r="string"===n||Array.isArray(t);return"boolean"==typeof e&&r?e?this.addClass(t):this.removeClass(t):y(t)?this.each((function(n){S(this).toggleClass(t.call(this,n,ve(this),e),e)})):this.each((function(){var e,s,i,o;if(r)for(s=0,i=S(this),o=xe(t);e=o[s++];)i.hasClass(e)?i.removeClass(e):i.addClass(e);else void 0!==t&&"boolean"!==n||((e=ve(this))&&Z.set(this,"__className__",e),this.setAttribute&&this.setAttribute("class",e||!1===t?"":Z.get(this,"__className__")||""))}))},hasClass:function(t){var e,n,r=0;for(e=" "+t+" ";n=this[r++];)if(1===n.nodeType&&(" "+be(ve(n))+" ").indexOf(e)>-1)return!0;return!1}});var we=/\r/g;S.fn.extend({val:function(t){var e,n,r,s=this[0];return arguments.length?(r=y(t),this.each((function(n){var s;1===this.nodeType&&(null==(s=r?t.call(this,n,S(this).val()):t)?s="":"number"==typeof s?s+="":Array.isArray(s)&&(s=S.map(s,(function(t){return null==t?"":t+""}))),(e=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&"set"in e&&void 0!==e.set(this,s,"value")||(this.value=s))}))):s?(e=S.valHooks[s.type]||S.valHooks[s.nodeName.toLowerCase()])&&"get"in e&&void 0!==(n=e.get(s,"value"))?n:"string"==typeof(n=s.value)?n.replace(we,""):null==n?"":n:void 0}}),S.extend({valHooks:{option:{get:function(t){var e=S.find.attr(t,"value");return null!=e?e:be(S.text(t))}},select:{get:function(t){var e,n,r,s=t.options,i=t.selectedIndex,o="select-one"===t.type,a=o?null:[],l=o?i+1:s.length;for(r=i<0?l:o?i:0;r<l;r++)if(((n=s[r]).selected||r===i)&&!n.disabled&&(!n.parentNode.disabled||!N(n.parentNode,"optgroup"))){if(e=S(n).val(),o)return e;a.push(e)}return a},set:function(t,e){for(var n,r,s=t.options,i=S.makeArray(e),o=s.length;o--;)((r=s[o]).selected=S.inArray(S.valHooks.option.get(r),i)>-1)&&(n=!0);return n||(t.selectedIndex=-1),i}}}}),S.each(["radio","checkbox"],(function(){S.valHooks[this]={set:function(t,e){if(Array.isArray(e))return t.checked=S.inArray(S(t).val(),e)>-1}},g.checkOn||(S.valHooks[this].get=function(t){return null===t.getAttribute("value")?"on":t.value})})),g.focusin="onfocusin"in n;var Ce=/^(?:focusinfocus|focusoutblur)$/,Se=function(t){t.stopPropagation()};S.extend(S.event,{trigger:function(t,e,r,s){var i,o,a,l,u,c,h,d,f=[r||v],m=p.call(t,"type")?t.type:t,g=p.call(t,"namespace")?t.namespace.split("."):[];if(o=d=a=r=r||v,3!==r.nodeType&&8!==r.nodeType&&!Ce.test(m+S.event.triggered)&&(m.indexOf(".")>-1&&(g=m.split("."),m=g.shift(),g.sort()),u=m.indexOf(":")<0&&"on"+m,(t=t[S.expando]?t:new S.Event(m,"object"==typeof t&&t)).isTrigger=s?2:3,t.namespace=g.join("."),t.rnamespace=t.namespace?new RegExp("(^|\\.)"+g.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,t.result=void 0,t.target||(t.target=r),e=null==e?[t]:S.makeArray(e,[t]),h=S.event.special[m]||{},s||!h.trigger||!1!==h.trigger.apply(r,e))){if(!s&&!h.noBubble&&!b(r)){for(Ce.test((l=h.delegateType||m)+m)||(o=o.parentNode);o;o=o.parentNode)f.push(o),a=o;a===(r.ownerDocument||v)&&f.push(a.defaultView||a.parentWindow||n)}for(i=0;(o=f[i++])&&!t.isPropagationStopped();)d=o,t.type=i>1?l:h.bindType||m,(c=(Z.get(o,"events")||Object.create(null))[t.type]&&Z.get(o,"handle"))&&c.apply(o,e),(c=u&&o[u])&&c.apply&&X(o)&&(t.result=c.apply(o,e),!1===t.result&&t.preventDefault());return t.type=m,s||t.isDefaultPrevented()||h._default&&!1!==h._default.apply(f.pop(),e)||!X(r)||u&&y(r[m])&&!b(r)&&((a=r[u])&&(r[u]=null),S.event.triggered=m,t.isPropagationStopped()&&d.addEventListener(m,Se),r[m](),t.isPropagationStopped()&&d.removeEventListener(m,Se),S.event.triggered=void 0,a&&(r[u]=a)),t.result}},simulate:function(t,e,n){var r=S.extend(new S.Event,n,{type:t,isSimulated:!0});S.event.trigger(r,null,e)}}),S.fn.extend({trigger:function(t,e){return this.each((function(){S.event.trigger(t,e,this)}))},triggerHandler:function(t,e){var n=this[0];if(n)return S.event.trigger(t,e,n,!0)}}),g.focusin||S.each({focus:"focusin",blur:"focusout"},(function(t,e){var n=function(t){S.event.simulate(e,t.target,S.event.fix(t))};S.event.special[e]={setup:function(){var r=this.ownerDocument||this.document||this,s=Z.access(r,e);s||r.addEventListener(t,n,!0),Z.access(r,e,(s||0)+1)},teardown:function(){var r=this.ownerDocument||this.document||this,s=Z.access(r,e)-1;s?Z.access(r,e,s):(r.removeEventListener(t,n,!0),Z.remove(r,e))}}}));var _e=n.location,Ee={guid:Date.now()},ke=/\?/;S.parseXML=function(t){var e;if(!t||"string"!=typeof t)return null;try{e=(new n.DOMParser).parseFromString(t,"text/xml")}catch(r){e=void 0}return e&&!e.getElementsByTagName("parsererror").length||S.error("Invalid XML: "+t),e};var Ae=/\[\]$/,Ie=/\r?\n/g,Ne=/^(?:submit|button|image|reset|file)$/i,Te=/^(?:input|select|textarea|keygen)/i;function Re(t,e,n,r){var s;if(Array.isArray(e))S.each(e,(function(e,s){n||Ae.test(t)?r(t,s):Re(t+"["+("object"==typeof s&&null!=s?e:"")+"]",s,n,r)}));else if(n||"object"!==C(e))r(t,e);else for(s in e)Re(t+"["+s+"]",e[s],n,r)}S.param=function(t,e){var n,r=[],s=function(t,e){var n=y(e)?e():e;r[r.length]=encodeURIComponent(t)+"="+encodeURIComponent(null==n?"":n)};if(null==t)return"";if(Array.isArray(t)||t.jquery&&!S.isPlainObject(t))S.each(t,(function(){s(this.name,this.value)}));else for(n in t)Re(n,t[n],e,s);return r.join("&")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map((function(){var t=S.prop(this,"elements");return t?S.makeArray(t):this})).filter((function(){var t=this.type;return this.name&&!S(this).is(":disabled")&&Te.test(this.nodeName)&&!Ne.test(t)&&(this.checked||!mt.test(t))})).map((function(t,e){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,(function(t){return{name:e.name,value:t.replace(Ie,"\r\n")}})):{name:e.name,value:n.replace(Ie,"\r\n")}})).get()}});var $e=/%20/g,De=/#.*$/,Oe=/([?&])_=[^&]*/,Fe=/^(.*?):[ \t]*([^\r\n]*)$/gm,Me=/^(?:GET|HEAD)$/,Le=/^\/\//,Pe={},ze={},Be="*/".concat("*"),Ve=v.createElement("a");function Ue(t){return function(e,n){"string"!=typeof e&&(n=e,e="*");var r,s=0,i=e.toLowerCase().match(L)||[];if(y(n))for(;r=i[s++];)"+"===r[0]?(r=r.slice(1)||"*",(t[r]=t[r]||[]).unshift(n)):(t[r]=t[r]||[]).push(n)}}function We(t,e,n,r){var s={},i=t===ze;function o(a){var l;return s[a]=!0,S.each(t[a]||[],(function(t,a){var u=a(e,n,r);return"string"!=typeof u||i||s[u]?i?!(l=u):void 0:(e.dataTypes.unshift(u),o(u),!1)})),l}return o(e.dataTypes[0])||!s["*"]&&o("*")}function je(t,e){var n,r,s=S.ajaxSettings.flatOptions||{};for(n in e)void 0!==e[n]&&((s[n]?t:r||(r={}))[n]=e[n]);return r&&S.extend(!0,t,r),t}Ve.href=_e.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:_e.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(_e.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Be,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(t,e){return e?je(je(t,S.ajaxSettings),e):je(S.ajaxSettings,t)},ajaxPrefilter:Ue(Pe),ajaxTransport:Ue(ze),ajax:function(t,e){"object"==typeof t&&(e=t,t=void 0);var r,s,i,o,a,l,u,c,h,d,p=S.ajaxSetup({},e=e||{}),f=p.context||p,m=p.context&&(f.nodeType||f.jquery)?S(f):S.event,g=S.Deferred(),y=S.Callbacks("once memory"),b=p.statusCode||{},x={},w={},C="canceled",_={readyState:0,getResponseHeader:function(t){var e;if(u){if(!o)for(o={};e=Fe.exec(i);)o[e[1].toLowerCase()+" "]=(o[e[1].toLowerCase()+" "]||[]).concat(e[2]);e=o[t.toLowerCase()+" "]}return null==e?null:e.join(", ")},getAllResponseHeaders:function(){return u?i:null},setRequestHeader:function(t,e){return null==u&&(t=w[t.toLowerCase()]=w[t.toLowerCase()]||t,x[t]=e),this},overrideMimeType:function(t){return null==u&&(p.mimeType=t),this},statusCode:function(t){var e;if(t)if(u)_.always(t[_.status]);else for(e in t)b[e]=[b[e],t[e]];return this},abort:function(t){var e=t||C;return r&&r.abort(e),E(0,e),this}};if(g.promise(_),p.url=((t||p.url||_e.href)+"").replace(Le,_e.protocol+"//"),p.type=e.method||e.type||p.method||p.type,p.dataTypes=(p.dataType||"*").toLowerCase().match(L)||[""],null==p.crossDomain){l=v.createElement("a");try{l.href=p.url,l.href=l.href,p.crossDomain=Ve.protocol+"//"+Ve.host!=l.protocol+"//"+l.host}catch(k){p.crossDomain=!0}}if(p.data&&p.processData&&"string"!=typeof p.data&&(p.data=S.param(p.data,p.traditional)),We(Pe,p,e,_),u)return _;for(h in(c=S.event&&p.global)&&0==S.active++&&S.event.trigger("ajaxStart"),p.type=p.type.toUpperCase(),p.hasContent=!Me.test(p.type),s=p.url.replace(De,""),p.hasContent?p.data&&p.processData&&0===(p.contentType||"").indexOf("application/x-www-form-urlencoded")&&(p.data=p.data.replace($e,"+")):(d=p.url.slice(s.length),p.data&&(p.processData||"string"==typeof p.data)&&(s+=(ke.test(s)?"&":"?")+p.data,delete p.data),!1===p.cache&&(s=s.replace(Oe,"$1"),d=(ke.test(s)?"&":"?")+"_="+Ee.guid+++d),p.url=s+d),p.ifModified&&(S.lastModified[s]&&_.setRequestHeader("If-Modified-Since",S.lastModified[s]),S.etag[s]&&_.setRequestHeader("If-None-Match",S.etag[s])),(p.data&&p.hasContent&&!1!==p.contentType||e.contentType)&&_.setRequestHeader("Content-Type",p.contentType),_.setRequestHeader("Accept",p.dataTypes[0]&&p.accepts[p.dataTypes[0]]?p.accepts[p.dataTypes[0]]+("*"!==p.dataTypes[0]?", "+Be+"; q=0.01":""):p.accepts["*"]),p.headers)_.setRequestHeader(h,p.headers[h]);if(p.beforeSend&&(!1===p.beforeSend.call(f,_,p)||u))return _.abort();if(C="abort",y.add(p.complete),_.done(p.success),_.fail(p.error),r=We(ze,p,e,_)){if(_.readyState=1,c&&m.trigger("ajaxSend",[_,p]),u)return _;p.async&&p.timeout>0&&(a=n.setTimeout((function(){_.abort("timeout")}),p.timeout));try{u=!1,r.send(x,E)}catch(k){if(u)throw k;E(-1,k)}}else E(-1,"No Transport");function E(t,e,o,l){var h,d,v,x,w,C=e;u||(u=!0,a&&n.clearTimeout(a),r=void 0,i=l||"",_.readyState=t>0?4:0,h=t>=200&&t<300||304===t,o&&(x=function(t,e,n){for(var r,s,i,o,a=t.contents,l=t.dataTypes;"*"===l[0];)l.shift(),void 0===r&&(r=t.mimeType||e.getResponseHeader("Content-Type"));if(r)for(s in a)if(a[s]&&a[s].test(r)){l.unshift(s);break}if(l[0]in n)i=l[0];else{for(s in n){if(!l[0]||t.converters[s+" "+l[0]]){i=s;break}o||(o=s)}i=i||o}if(i)return i!==l[0]&&l.unshift(i),n[i]}(p,_,o)),!h&&S.inArray("script",p.dataTypes)>-1&&(p.converters["text script"]=function(){}),x=function(t,e,n,r){var s,i,o,a,l,u={},c=t.dataTypes.slice();if(c[1])for(o in t.converters)u[o.toLowerCase()]=t.converters[o];for(i=c.shift();i;)if(t.responseFields[i]&&(n[t.responseFields[i]]=e),!l&&r&&t.dataFilter&&(e=t.dataFilter(e,t.dataType)),l=i,i=c.shift())if("*"===i)i=l;else if("*"!==l&&l!==i){if(!(o=u[l+" "+i]||u["* "+i]))for(s in u)if((a=s.split(" "))[1]===i&&(o=u[l+" "+a[0]]||u["* "+a[0]])){!0===o?o=u[s]:!0!==u[s]&&(i=a[0],c.unshift(a[1]));break}if(!0!==o)if(o&&t.throws)e=o(e);else try{e=o(e)}catch(k){return{state:"parsererror",error:o?k:"No conversion from "+l+" to "+i}}}return{state:"success",data:e}}(p,x,_,h),h?(p.ifModified&&((w=_.getResponseHeader("Last-Modified"))&&(S.lastModified[s]=w),(w=_.getResponseHeader("etag"))&&(S.etag[s]=w)),204===t||"HEAD"===p.type?C="nocontent":304===t?C="notmodified":(C=x.state,d=x.data,h=!(v=x.error))):(v=C,!t&&C||(C="error",t<0&&(t=0))),_.status=t,_.statusText=(e||C)+"",h?g.resolveWith(f,[d,C,_]):g.rejectWith(f,[_,C,v]),_.statusCode(b),b=void 0,c&&m.trigger(h?"ajaxSuccess":"ajaxError",[_,p,h?d:v]),y.fireWith(f,[_,C]),c&&(m.trigger("ajaxComplete",[_,p]),--S.active||S.event.trigger("ajaxStop")))}return _},getJSON:function(t,e,n){return S.get(t,e,n,"json")},getScript:function(t,e){return S.get(t,void 0,e,"script")}}),S.each(["get","post"],(function(t,e){S[e]=function(t,n,r,s){return y(n)&&(s=s||r,r=n,n=void 0),S.ajax(S.extend({url:t,type:e,dataType:s,data:n,success:r},S.isPlainObject(t)&&t))}})),S.ajaxPrefilter((function(t){var e;for(e in t.headers)"content-type"===e.toLowerCase()&&(t.contentType=t.headers[e]||"")})),S._evalUrl=function(t,e,n){return S.ajax({url:t,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(t){S.globalEval(t,e,n)}})},S.fn.extend({wrapAll:function(t){var e;return this[0]&&(y(t)&&(t=t.call(this[0])),e=S(t,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&e.insertBefore(this[0]),e.map((function(){for(var t=this;t.firstElementChild;)t=t.firstElementChild;return t})).append(this)),this},wrapInner:function(t){return y(t)?this.each((function(e){S(this).wrapInner(t.call(this,e))})):this.each((function(){var e=S(this),n=e.contents();n.length?n.wrapAll(t):e.append(t)}))},wrap:function(t){var e=y(t);return this.each((function(n){S(this).wrapAll(e?t.call(this,n):t)}))},unwrap:function(t){return this.parent(t).not("body").each((function(){S(this).replaceWith(this.childNodes)})),this}}),S.expr.pseudos.hidden=function(t){return!S.expr.pseudos.visible(t)},S.expr.pseudos.visible=function(t){return!!(t.offsetWidth||t.offsetHeight||t.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new n.XMLHttpRequest}catch(t){}};var He={0:200,1223:204},qe=S.ajaxSettings.xhr();g.cors=!!qe&&"withCredentials"in qe,g.ajax=qe=!!qe,S.ajaxTransport((function(t){var e,r;if(g.cors||qe&&!t.crossDomain)return{send:function(s,i){var o,a=t.xhr();if(a.open(t.type,t.url,t.async,t.username,t.password),t.xhrFields)for(o in t.xhrFields)a[o]=t.xhrFields[o];for(o in t.mimeType&&a.overrideMimeType&&a.overrideMimeType(t.mimeType),t.crossDomain||s["X-Requested-With"]||(s["X-Requested-With"]="XMLHttpRequest"),s)a.setRequestHeader(o,s[o]);e=function(t){return function(){e&&(e=r=a.onload=a.onerror=a.onabort=a.ontimeout=a.onreadystatechange=null,"abort"===t?a.abort():"error"===t?"number"!=typeof a.status?i(0,"error"):i(a.status,a.statusText):i(He[a.status]||a.status,a.statusText,"text"!==(a.responseType||"text")||"string"!=typeof a.responseText?{binary:a.response}:{text:a.responseText},a.getAllResponseHeaders()))}},a.onload=e(),r=a.onerror=a.ontimeout=e("error"),void 0!==a.onabort?a.onabort=r:a.onreadystatechange=function(){4===a.readyState&&n.setTimeout((function(){e&&r()}))},e=e("abort");try{a.send(t.hasContent&&t.data||null)}catch(l){if(e)throw l}},abort:function(){e&&e()}}})),S.ajaxPrefilter((function(t){t.crossDomain&&(t.contents.script=!1)})),S.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(t){return S.globalEval(t),t}}}),S.ajaxPrefilter("script",(function(t){void 0===t.cache&&(t.cache=!1),t.crossDomain&&(t.type="GET")})),S.ajaxTransport("script",(function(t){var e,n;if(t.crossDomain||t.scriptAttrs)return{send:function(r,s){e=S("<script>").attr(t.scriptAttrs||{}).prop({charset:t.scriptCharset,src:t.url}).on("load error",n=function(t){e.remove(),n=null,t&&s("error"===t.type?404:200,t.type)}),v.head.appendChild(e[0])},abort:function(){n&&n()}}}));var Ge,Ke=[],Xe=/(=)\?(?=&|$)|\?\?/;S.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var t=Ke.pop()||S.expando+"_"+Ee.guid++;return this[t]=!0,t}}),S.ajaxPrefilter("json jsonp",(function(t,e,r){var s,i,o,a=!1!==t.jsonp&&(Xe.test(t.url)?"url":"string"==typeof t.data&&0===(t.contentType||"").indexOf("application/x-www-form-urlencoded")&&Xe.test(t.data)&&"data");if(a||"jsonp"===t.dataTypes[0])return s=t.jsonpCallback=y(t.jsonpCallback)?t.jsonpCallback():t.jsonpCallback,a?t[a]=t[a].replace(Xe,"$1"+s):!1!==t.jsonp&&(t.url+=(ke.test(t.url)?"&":"?")+t.jsonp+"="+s),t.converters["script json"]=function(){return o||S.error(s+" was not called"),o[0]},t.dataTypes[0]="json",i=n[s],n[s]=function(){o=arguments},r.always((function(){void 0===i?S(n).removeProp(s):n[s]=i,t[s]&&(t.jsonpCallback=e.jsonpCallback,Ke.push(s)),o&&y(i)&&i(o[0]),o=i=void 0})),"script"})),g.createHTMLDocument=((Ge=v.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Ge.childNodes.length),S.parseHTML=function(t,e,n){return"string"!=typeof t?[]:("boolean"==typeof e&&(n=e,e=!1),e||(g.createHTMLDocument?((r=(e=v.implementation.createHTMLDocument("")).createElement("base")).href=v.location.href,e.head.appendChild(r)):e=v),i=!n&&[],(s=T.exec(t))?[e.createElement(s[1])]:(s=Ct([t],e,i),i&&i.length&&S(i).remove(),S.merge([],s.childNodes)));var r,s,i},S.fn.load=function(t,e,n){var r,s,i,o=this,a=t.indexOf(" ");return a>-1&&(r=be(t.slice(a)),t=t.slice(0,a)),y(e)?(n=e,e=void 0):e&&"object"==typeof e&&(s="POST"),o.length>0&&S.ajax({url:t,type:s||"GET",dataType:"html",data:e}).done((function(t){i=arguments,o.html(r?S("<div>").append(S.parseHTML(t)).find(r):t)})).always(n&&function(t,e){o.each((function(){n.apply(this,i||[t.responseText,e,t])}))}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,(function(e){return t===e.elem})).length},S.offset={setOffset:function(t,e,n){var r,s,i,o,a,l,u=S.css(t,"position"),c=S(t),h={};"static"===u&&(t.style.position="relative"),a=c.offset(),i=S.css(t,"top"),l=S.css(t,"left"),("absolute"===u||"fixed"===u)&&(i+l).indexOf("auto")>-1?(o=(r=c.position()).top,s=r.left):(o=parseFloat(i)||0,s=parseFloat(l)||0),y(e)&&(e=e.call(t,n,S.extend({},a))),null!=e.top&&(h.top=e.top-a.top+o),null!=e.left&&(h.left=e.left-a.left+s),"using"in e?e.using.call(t,h):("number"==typeof h.top&&(h.top+="px"),"number"==typeof h.left&&(h.left+="px"),c.css(h))}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each((function(e){S.offset.setOffset(this,t,e)}));var e,n,r=this[0];return r?r.getClientRects().length?{top:(e=r.getBoundingClientRect()).top+(n=r.ownerDocument.defaultView).pageYOffset,left:e.left+n.pageXOffset}:{top:0,left:0}:void 0},position:function(){if(this[0]){var t,e,n,r=this[0],s={top:0,left:0};if("fixed"===S.css(r,"position"))e=r.getBoundingClientRect();else{for(e=this.offset(),n=r.ownerDocument,t=r.offsetParent||n.documentElement;t&&(t===n.body||t===n.documentElement)&&"static"===S.css(t,"position");)t=t.parentNode;t&&t!==r&&1===t.nodeType&&((s=S(t).offset()).top+=S.css(t,"borderTopWidth",!0),s.left+=S.css(t,"borderLeftWidth",!0))}return{top:e.top-s.top-S.css(r,"marginTop",!0),left:e.left-s.left-S.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map((function(){for(var t=this.offsetParent;t&&"static"===S.css(t,"position");)t=t.offsetParent;return t||it}))}}),S.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},(function(t,e){var n="pageYOffset"===e;S.fn[t]=function(r){return j(this,(function(t,r,s){var i;if(b(t)?i=t:9===t.nodeType&&(i=t.defaultView),void 0===s)return i?i[e]:t[r];i?i.scrollTo(n?i.pageXOffset:s,n?s:i.pageYOffset):t[r]=s}),t,r,arguments.length)}})),S.each(["top","left"],(function(t,e){S.cssHooks[e]=qt(g.pixelPosition,(function(t,n){if(n)return n=Ht(t,e),Vt.test(n)?S(t).position()[e]+"px":n}))})),S.each({Height:"height",Width:"width"},(function(t,e){S.each({padding:"inner"+t,content:e,"":"outer"+t},(function(n,r){S.fn[r]=function(s,i){var o=arguments.length&&(n||"boolean"!=typeof s),a=n||(!0===s||!0===i?"margin":"border");return j(this,(function(e,n,s){var i;return b(e)?0===r.indexOf("outer")?e["inner"+t]:e.document.documentElement["client"+t]:9===e.nodeType?(i=e.documentElement,Math.max(e.body["scroll"+t],i["scroll"+t],e.body["offset"+t],i["offset"+t],i["client"+t])):void 0===s?S.css(e,n,a):S.style(e,n,s,a)}),e,o?s:void 0,o)}}))})),S.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],(function(t,e){S.fn[e]=function(t){return this.on(e,t)}})),S.fn.extend({bind:function(t,e,n){return this.on(t,null,e,n)},unbind:function(t,e){return this.off(t,null,e)},delegate:function(t,e,n,r){return this.on(e,t,n,r)},undelegate:function(t,e,n){return 1===arguments.length?this.off(t,"**"):this.off(e,t||"**",n)},hover:function(t,e){return this.mouseenter(t).mouseleave(e||t)}}),S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),(function(t,e){S.fn[e]=function(t,n){return arguments.length>0?this.on(e,null,t,n):this.trigger(e)}}));var Ye=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;S.proxy=function(t,e){var n,r,s;if("string"==typeof e&&(n=t[e],e=t,t=n),y(t))return r=a.call(arguments,2),(s=function(){return t.apply(e||this,r.concat(a.call(arguments)))}).guid=t.guid=t.guid||S.guid++,s},S.holdReady=function(t){t?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=N,S.isFunction=y,S.isWindow=b,S.camelCase=K,S.type=C,S.now=Date.now,S.isNumeric=function(t){var e=S.type(t);return("number"===e||"string"===e)&&!isNaN(t-parseFloat(t))},S.trim=function(t){return null==t?"":(t+"").replace(Ye,"")},void 0===(r=(function(){return S}).apply(e,[]))||(t.exports=r);var Ze=n.jQuery,Je=n.$;return S.noConflict=function(t){return n.$===S&&(n.$=Je),t&&n.jQuery===S&&(n.jQuery=Ze),S},void 0===s&&(n.jQuery=n.$=S),S}))},EhIR:function(t,e,n){(function(t){var r;!function(t,s,i){function o(t){var e,n=this,r=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(t),n.s0<0&&(n.s0+=1),n.s1-=r(t),n.s1<0&&(n.s1+=1),n.s2-=r(t),n.s2<0&&(n.s2+=1),r=null}function a(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function l(t,e){var n=new o(t),r=e&&e.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,s))||(s.exports=r):this.alea=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},PDX0:function(t,e){(function(e){t.exports=e}).call(this,{})},YSVl:function(t,e,n){var r=n("EhIR"),s=n("uDiL"),i=n("pJ6O"),o=n("yuCN"),a=n("euyF"),l=n("ie1u"),u=n("pJ3+");u.alea=r,u.xor128=s,u.xorwow=i,u.xorshift7=o,u.xor4096=a,u.tychei=l,t.exports=u},YuTi:function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,"loaded",{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,"id",{enumerable:!0,get:function(){return t.i}}),t.webpackPolyfill=1),t}},euyF:function(t,e,n){(function(t){var r;!function(t,s,i){function o(t){var e=this;e.next=function(){var t,n,r=e.w,s=e.X,i=e.i;return e.w=r=r+1640531527|0,n=s[i+34&127],t=s[i=i+1&127],n^=n<<13,t^=t<<17,n=s[i]=(n^=n>>>15)^(t^=t>>>12),e.i=i,n+(r^r>>>16)|0},function(t,e){var n,r,s,i,o,a=[],l=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,l=Math.max(l,e.length)),s=0,i=-32;i<l;++i)e&&(r^=e.charCodeAt((i+32)%e.length)),0===i&&(o=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,i>=0&&(s=0==(n=a[127&i]^=r+(o=o+1640531527|0))?s+1:0);for(s>=128&&(a[127&(e&&e.length||0)]=-1),s=127,i=512;i>0;--i)r=a[s+34&127],n=a[s=s+1&127],r^=r<<13,n^=n<<17,a[s]=(r^=r>>>15)^(n^=n>>>12);t.w=o,t.X=a,t.i=s}(e,t)}function a(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&(r.X&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,s))||(s.exports=r):this.xor4096=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},ie1u:function(t,e,n){(function(t){var r;!function(t,s,i){function o(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,s=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^s,e.a=s-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function a(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function l(t,e){var n=new o(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,s))||(s.exports=r):this.tychei=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},"pJ3+":function(t,e,n){var r;!function(s,i){var o,a=this,l=i.pow(256,6),u=i.pow(2,52),c=2*u;function h(t,e,n){var r=[],h=f(function t(e,n){var r,s=[],i=typeof e;if(n&&"object"==i)for(r in e)try{s.push(t(e[r],n-1))}catch(o){}return s.length?s:"string"==i?e:e+"\0"}((e=1==e?{entropy:!0}:e||{}).entropy?[t,m(s)]:null==t?function(){try{var t;return o&&(t=o.randomBytes)?t=t(256):(t=new Uint8Array(256),(a.crypto||a.msCrypto).getRandomValues(t)),m(t)}catch(r){var e=a.navigator,n=e&&e.plugins;return[+new Date,a,n,a.screen,m(s)]}}():t,3),r),g=new d(r),y=function(){for(var t=g.g(6),e=l,n=0;t<u;)t=256*(t+n),e*=256,n=g.g(1);for(;t>=c;)t/=2,e/=2,n>>>=1;return(t+n)/e};return y.int32=function(){return 0|g.g(4)},y.quick=function(){return g.g(4)/4294967296},y.double=y,f(m(g.S),s),(e.pass||n||function(t,e,n,r){return r&&(r.S&&p(r,g),t.state=function(){return p(g,{})}),n?(i.random=t,e):t})(y,h,"global"in e?e.global:this==i,e.state)}function d(t){var e,n=t.length,r=this,s=0,i=r.i=r.j=0,o=r.S=[];for(n||(t=[n++]);s<256;)o[s]=s++;for(s=0;s<256;s++)o[s]=o[i=255&i+t[s%n]+(e=o[s])],o[i]=e;(r.g=function(t){for(var e,n=0,s=r.i,i=r.j,o=r.S;t--;)e=o[s=255&s+1],n=256*n+o[255&(o[s]=o[i=255&i+e])+(o[i]=e)];return r.i=s,r.j=i,n})(256)}function p(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function f(t,e){for(var n,r=t+"",s=0;s<r.length;)e[255&s]=255&(n^=19*e[255&s])+r.charCodeAt(s++);return m(e)}function m(t){return String.fromCharCode.apply(0,t)}if(i.seedrandom=h,f(i.random(),s),t.exports){t.exports=h;try{o=n(3)}catch(g){}}else void 0===(r=(function(){return h}).call(e,n,e,t))||(t.exports=r)}([],Math)},pJ6O:function(t,e,n){(function(t){var r;!function(t,s,i){function o(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function a(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function l(t,e){var n=new o(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,s))||(s.exports=r):this.xorwow=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},uDiL:function(t,e,n){(function(t){var r;!function(t,s,i){function o(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function a(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function l(t,e){var n=new o(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,s))||(s.exports=r):this.xor128=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},yuCN:function(t,e,n){(function(t){var r;!function(t,s,i){function o(t){var e=this;e.next=function(){var t,n,r=e.x,s=e.i;return t=r[s],n=(t^=t>>>7)^t<<24,n^=(t=r[s+1&7])^t>>>10,n^=(t=r[s+3&7])^t>>>3,n^=(t=r[s+4&7])^t<<7,t=r[s+7&7],r[s]=n^=(t^=t<<13)^t<<9,e.i=s+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n&&(r[7]=-1),t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function a(t,e){return e.x=t.x.slice(),e.i=t.i,e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&(r.x&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,s))||(s.exports=r):this.xorshift7=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},zUnb:function(t,e,n){"use strict";n.r(e);var r={};n.r(r),n.d(r,"shuffle",(function(){return Up})),n.d(r,"clamp",(function(){return Wp})),n.d(r,"nearestLargerEven",(function(){return jp})),n.d(r,"sum",(function(){return Hp})),n.d(r,"randUniform",(function(){return qp})),n.d(r,"distSquared",(function(){return Gp})),n.d(r,"assert",(function(){return Kp})),n.d(r,"assertShapesMatch",(function(){return Xp})),n.d(r,"assertNonNull",(function(){return Yp})),n.d(r,"flatten",(function(){return Zp})),n.d(r,"sizeFromShape",(function(){return Jp})),n.d(r,"isScalarShape",(function(){return Qp})),n.d(r,"arraysEqual",(function(){return tf})),n.d(r,"isInt",(function(){return ef})),n.d(r,"tanh",(function(){return nf})),n.d(r,"sizeToSquarishShape",(function(){return rf})),n.d(r,"createShuffledIndices",(function(){return sf})),n.d(r,"rightPad",(function(){return of})),n.d(r,"repeatedTry",(function(){return af})),n.d(r,"inferFromImplicitShape",(function(){return lf})),n.d(r,"parseAxisParam",(function(){return uf})),n.d(r,"squeezeShape",(function(){return cf})),n.d(r,"getTypedArrayFromDType",(function(){return hf})),n.d(r,"getArrayFromDType",(function(){return df})),n.d(r,"checkConversionForErrors",(function(){return pf})),n.d(r,"isValidDtype",(function(){return ff})),n.d(r,"hasEncodingLoss",(function(){return mf})),n.d(r,"isTypedArray",(function(){return gf})),n.d(r,"bytesPerElement",(function(){return yf})),n.d(r,"bytesFromStringArray",(function(){return bf})),n.d(r,"isString",(function(){return vf})),n.d(r,"isBoolean",(function(){return xf})),n.d(r,"isNumber",(function(){return wf})),n.d(r,"inferDtype",(function(){return Cf})),n.d(r,"isFunction",(function(){return Sf})),n.d(r,"nearestDivisor",(function(){return _f})),n.d(r,"computeStrides",(function(){return Ef})),n.d(r,"toTypedArray",(function(){return kf})),n.d(r,"toNestedArray",(function(){return Af})),n.d(r,"makeOnesTypedArray",(function(){return If})),n.d(r,"makeZerosTypedArray",(function(){return Nf})),n.d(r,"now",(function(){return Tf})),n.d(r,"assertNonNegativeIntegerDimensions",(function(){return Rf})),n.d(r,"fetch",(function(){return $f})),n.d(r,"encodeString",(function(){return Df})),n.d(r,"decodeString",(function(){return Of})),n.d(r,"locToIndex",(function(){return Ff})),n.d(r,"indexToLoc",(function(){return Mf}));var s={};n.r(s),n.d(s,"makeTypesMatch",(function(){return nm})),n.d(s,"assertTypesMatch",(function(){return rm})),n.d(s,"isTensorInList",(function(){return sm})),n.d(s,"getTensorsInContainer",(function(){return im}));var i={};n.r(i),n.d(i,"isMobile",(function(){return um})),n.d(i,"isBrowser",(function(){return cm}));var o={};n.r(o),n.d(o,"assertParamsValid",(function(){return Db})),n.d(o,"maskToAxes",(function(){return Ob})),n.d(o,"computeOutShape",(function(){return Fb})),n.d(o,"stridesWithElidedDims",(function(){return Mb})),n.d(o,"startIndicesWithElidedDims",(function(){return Lb})),n.d(o,"stopIndicesWithElidedDims",(function(){return Pb})),n.d(o,"stridesForAxis",(function(){return zb})),n.d(o,"startForAxis",(function(){return Bb})),n.d(o,"stopForAxis",(function(){return Vb})),n.d(o,"isSliceContinous",(function(){return Ub})),n.d(o,"computeFlatOffset",(function(){return Wb}));var a={};n.r(a),n.d(a,"copyModel",(function(){return yv})),n.d(a,"listModels",(function(){return mv})),n.d(a,"moveModel",(function(){return bv})),n.d(a,"removeModel",(function(){return gv})),n.d(a,"browserFiles",(function(){return Pv})),n.d(a,"browserHTTPRequest",(function(){return Gv})),n.d(a,"concatenateArrayBuffers",(function(){return rv})),n.d(a,"decodeWeights",(function(){return Qb})),n.d(a,"encodeWeights",(function(){return Jb})),n.d(a,"fromMemory",(function(){return Yv})),n.d(a,"getLoadHandlers",(function(){return hv})),n.d(a,"getModelArtifactsInfoForJSON",(function(){return iv})),n.d(a,"getSaveHandlers",(function(){return cv})),n.d(a,"http",(function(){return qv})),n.d(a,"isHTTPScheme",(function(){return jv})),n.d(a,"loadWeights",(function(){return Vv})),n.d(a,"registerLoadRouter",(function(){return uv})),n.d(a,"registerSaveRouter",(function(){return lv})),n.d(a,"weightsLoaderFactory",(function(){return Uv})),n.d(a,"withSaveHandler",(function(){return Zv}));var l={};n.r(l),n.d(l,"toPixels",(function(){return tx})),n.d(l,"fromPixels",(function(){return ex}));var u={};n.r(u),n.d(u,"Serializable",(function(){return ox})),n.d(u,"SerializationMap",(function(){return ax})),n.d(u,"registerClass",(function(){return lx}));var c={};n.r(c),n.d(c,"segOpComputeOptimalWindowSize",(function(){return _w})),n.d(c,"computeOutShape",(function(){return Ew})),n.d(c,"collectGatherOpShapeInfo",(function(){return kw}));var h={};n.r(h),n.d(h,"fft",(function(){return aC})),n.d(h,"ifft",(function(){return lC})),n.d(h,"rfft",(function(){return uC})),n.d(h,"irfft",(function(){return cC}));var d={};n.r(d),n.d(d,"hannWindow",(function(){return mC})),n.d(d,"hammingWindow",(function(){return gC})),n.d(d,"frame",(function(){return yC})),n.d(d,"stft",(function(){return bC}));var p={};n.r(p),n.d(p,"Reduction",(function(){return xC})),n.d(p,"absoluteDifference",(function(){return wC})),n.d(p,"computeWeightedLoss",(function(){return CC})),n.d(p,"cosineDistance",(function(){return SC})),n.d(p,"hingeLoss",(function(){return _C})),n.d(p,"huberLoss",(function(){return EC})),n.d(p,"logLoss",(function(){return kC})),n.d(p,"meanSquaredError",(function(){return AC})),n.d(p,"sigmoidCrossEntropy",(function(){return IC})),n.d(p,"softmaxCrossEntropy",(function(){return NC}));var f={};n.r(f),n.d(f,"bandPart",(function(){return RC})),n.d(f,"gramSchmidt",(function(){return $C})),n.d(f,"qr",(function(){return DC}));var m={};n.r(m),n.d(m,"nonMaxSuppression",(function(){return WC})),n.d(m,"resizeBilinear",(function(){return jC})),n.d(m,"resizeNearestNeighbor",(function(){return HC})),n.d(m,"nonMaxSuppressionAsync",(function(){return qC})),n.d(m,"nonMaxSuppressionWithScore",(function(){return GC})),n.d(m,"nonMaxSuppressionWithScoreAsync",(function(){return KC})),n.d(m,"cropAndResize",(function(){return XC}));var g={};n.r(g),n.d(g,"matMul",(function(){return tS})),n.d(g,"conv2d",(function(){return eS})),n.d(g,"depthwiseConv2d",(function(){return nS}));var y={};n.r(y),n.d(y,"add",(function(){return wm})),n.d(y,"addN",(function(){return gx})),n.d(y,"atan2",(function(){return yx})),n.d(y,"avgPool",(function(){return bx})),n.d(y,"avgPool3d",(function(){return vx})),n.d(y,"batchToSpaceND",(function(){return kb})),n.d(y,"batchNorm",(function(){return wx})),n.d(y,"batchNorm2d",(function(){return Cx})),n.d(y,"batchNorm3d",(function(){return Sx})),n.d(y,"batchNorm4d",(function(){return _x})),n.d(y,"broadcastTo",(function(){return kx})),n.d(y,"clone",(function(){return Ex})),n.d(y,"complex",(function(){return _m})),n.d(y,"concat",(function(){return Wm})),n.d(y,"concat1d",(function(){return Ax})),n.d(y,"concat2d",(function(){return Ix})),n.d(y,"concat3d",(function(){return Nx})),n.d(y,"concat4d",(function(){return Tx})),n.d(y,"conv1d",(function(){return Rx})),n.d(y,"conv2d",(function(){return Ty})),n.d(y,"conv2dTranspose",(function(){return $x})),n.d(y,"conv3d",(function(){return Dx})),n.d(y,"conv3dTranspose",(function(){return Ox})),n.d(y,"cumsum",(function(){return My})),n.d(y,"depthToSpace",(function(){return Fx})),n.d(y,"depthwiseConv2d",(function(){return Mx})),n.d(y,"diag",(function(){return Lx})),n.d(y,"div",(function(){return tg})),n.d(y,"divNoNan",(function(){return Px})),n.d(y,"dot",(function(){return zx})),n.d(y,"elu",(function(){return Bx})),n.d(y,"equal",(function(){return Vx})),n.d(y,"eye",(function(){return Ux})),n.d(y,"fill",(function(){return Wx})),n.d(y,"floorDiv",(function(){return Qm})),n.d(y,"greater",(function(){return sb})),n.d(y,"greaterEqual",(function(){return Zy})),n.d(y,"imag",(function(){return Em})),n.d(y,"leakyRelu",(function(){return Hx})),n.d(y,"less",(function(){return Jy})),n.d(y,"lessEqual",(function(){return ib})),n.d(y,"localResponseNormalization",(function(){return qx})),n.d(y,"matMul",(function(){return xy})),n.d(y,"max",(function(){return Gx})),n.d(y,"maxPool",(function(){return Kx})),n.d(y,"maxPool3d",(function(){return Xx})),n.d(y,"maxPoolWithArgmax",(function(){return Yx})),n.d(y,"maximum",(function(){return jx})),n.d(y,"minimum",(function(){return Zx})),n.d(y,"mod",(function(){return Jx})),n.d(y,"mul",(function(){return eg})),n.d(y,"multinomial",(function(){return Qx})),n.d(y,"notEqual",(function(){return tw})),n.d(y,"oneHot",(function(){return Jv})),n.d(y,"outerProduct",(function(){return ew})),n.d(y,"pad",(function(){return $b})),n.d(y,"pad1d",(function(){return nw})),n.d(y,"pad2d",(function(){return rw})),n.d(y,"pad3d",(function(){return sw})),n.d(y,"pad4d",(function(){return iw})),n.d(y,"pool",(function(){return ow})),n.d(y,"pow",(function(){return bb})),n.d(y,"prelu",(function(){return aw})),n.d(y,"rand",(function(){return lw})),n.d(y,"randomGamma",(function(){return pw})),n.d(y,"randomNormal",(function(){return fw})),n.d(y,"randomUniform",(function(){return mw})),n.d(y,"real",(function(){return km})),n.d(y,"relu",(function(){return gw})),n.d(y,"relu6",(function(){return yw})),n.d(y,"selu",(function(){return bw})),n.d(y,"separableConv2d",(function(){return vw})),n.d(y,"spaceToBatchND",(function(){return Cy})),n.d(y,"split",(function(){return Ey})),n.d(y,"square",(function(){return Cg})),n.d(y,"squaredDifference",(function(){return xw})),n.d(y,"sub",(function(){return jy})),n.d(y,"tile",(function(){return Hy})),n.d(y,"truncatedNormal",(function(){return ww})),n.d(y,"booleanMaskAsync",(function(){return Rw})),n.d(y,"reverse",(function(){return $w})),n.d(y,"reverse1d",(function(){return Dw})),n.d(y,"reverse2d",(function(){return Ow})),n.d(y,"reverse3d",(function(){return Fw})),n.d(y,"reverse4d",(function(){return Mw})),n.d(y,"slice",(function(){return jb})),n.d(y,"slice1d",(function(){return Hb})),n.d(y,"slice2d",(function(){return qb})),n.d(y,"slice3d",(function(){return Gb})),n.d(y,"slice4d",(function(){return Kb})),n.d(y,"abs",(function(){return Sg})),n.d(y,"acos",(function(){return _g})),n.d(y,"acosh",(function(){return Eg})),n.d(y,"asin",(function(){return kg})),n.d(y,"asinh",(function(){return Ag})),n.d(y,"atan",(function(){return Ig})),n.d(y,"atanh",(function(){return Ng})),n.d(y,"ceil",(function(){return Tg})),n.d(y,"clipByValue",(function(){return Rg})),n.d(y,"cos",(function(){return $g})),n.d(y,"cosh",(function(){return Dg})),n.d(y,"erf",(function(){return Og})),n.d(y,"exp",(function(){return Fg})),n.d(y,"expm1",(function(){return Mg})),n.d(y,"floor",(function(){return Lg})),n.d(y,"log",(function(){return Pg})),n.d(y,"log1p",(function(){return zg})),n.d(y,"logSigmoid",(function(){return Bg})),n.d(y,"neg",(function(){return Vg})),n.d(y,"reciprocal",(function(){return Ug})),n.d(y,"round",(function(){return Wg})),n.d(y,"rsqrt",(function(){return jg})),n.d(y,"sigmoid",(function(){return Hg})),n.d(y,"sign",(function(){return qg})),n.d(y,"isNaN",(function(){return Gg})),n.d(y,"isInf",(function(){return Kg})),n.d(y,"isFinite",(function(){return Xg})),n.d(y,"sin",(function(){return Yg})),n.d(y,"sinh",(function(){return Zg})),n.d(y,"softplus",(function(){return Jg})),n.d(y,"sqrt",(function(){return Qg})),n.d(y,"step",(function(){return ty})),n.d(y,"tan",(function(){return ey})),n.d(y,"tanh",(function(){return ny})),n.d(y,"all",(function(){return dg})),n.d(y,"any",(function(){return pg})),n.d(y,"argMax",(function(){return fg})),n.d(y,"argMin",(function(){return mg})),n.d(y,"logSumExp",(function(){return gg})),n.d(y,"mean",(function(){return yg})),n.d(y,"min",(function(){return bg})),n.d(y,"moments",(function(){return vg})),n.d(y,"sum",(function(){return xg})),n.d(y,"prod",(function(){return wg})),n.d(y,"equalStrict",(function(){return Lw})),n.d(y,"greaterEqualStrict",(function(){return Pw})),n.d(y,"greaterStrict",(function(){return zw})),n.d(y,"lessEqualStrict",(function(){return Bw})),n.d(y,"lessStrict",(function(){return Vw})),n.d(y,"notEqualStrict",(function(){return Uw})),n.d(y,"addStrict",(function(){return Ww})),n.d(y,"divStrict",(function(){return jw})),n.d(y,"maximumStrict",(function(){return Hw})),n.d(y,"minimumStrict",(function(){return qw})),n.d(y,"modStrict",(function(){return Gw})),n.d(y,"mulStrict",(function(){return Kw})),n.d(y,"powStrict",(function(){return Xw})),n.d(y,"squaredDifferenceStrict",(function(){return Yw})),n.d(y,"subStrict",(function(){return Zw})),n.d(y,"logicalAnd",(function(){return db})),n.d(y,"logicalNot",(function(){return pb})),n.d(y,"logicalOr",(function(){return fb})),n.d(y,"logicalXor",(function(){return mb})),n.d(y,"where",(function(){return gb})),n.d(y,"whereAsync",(function(){return yb})),n.d(y,"buffer",(function(){return jm})),n.d(y,"print",(function(){return Hm})),n.d(y,"cast",(function(){return qm})),n.d(y,"expandDims",(function(){return Gm})),n.d(y,"reshape",(function(){return Km})),n.d(y,"squeeze",(function(){return Xm})),n.d(y,"stack",(function(){return Ym})),n.d(y,"unstack",(function(){return Zm})),n.d(y,"setdiff1dAsync",(function(){return Jm})),n.d(y,"linspace",(function(){return zm})),n.d(y,"ones",(function(){return Lm})),n.d(y,"range",(function(){return Bm})),n.d(y,"scalar",(function(){return Nm})),n.d(y,"tensor",(function(){return Am})),n.d(y,"tensor1d",(function(){return Tm})),n.d(y,"tensor2d",(function(){return Rm})),n.d(y,"tensor3d",(function(){return $m})),n.d(y,"tensor4d",(function(){return Dm})),n.d(y,"tensor5d",(function(){return Om})),n.d(y,"tensor6d",(function(){return Fm})),n.d(y,"variable",(function(){return Mm})),n.d(y,"zeros",(function(){return Pm})),n.d(y,"onesLike",(function(){return Vm})),n.d(y,"zerosLike",(function(){return Um})),n.d(y,"transpose",(function(){return Fy})),n.d(y,"softmax",(function(){return Jw})),n.d(y,"logSoftmax",(function(){return Qw})),n.d(y,"norm",(function(){return tC})),n.d(y,"gather",(function(){return Nw})),n.d(y,"unsortedSegmentSum",(function(){return Tw})),n.d(y,"basicLSTMCell",(function(){return eC})),n.d(y,"multiRNNCell",(function(){return nC})),n.d(y,"movingAverage",(function(){return rC})),n.d(y,"stridedSlice",(function(){return sC})),n.d(y,"topk",(function(){return iC})),n.d(y,"scatterND",(function(){return oC})),n.d(y,"fft",(function(){return aC})),n.d(y,"ifft",(function(){return lC})),n.d(y,"rfft",(function(){return uC})),n.d(y,"irfft",(function(){return cC})),n.d(y,"sparseToDense",(function(){return hC})),n.d(y,"gatherND",(function(){return dC})),n.d(y,"dropout",(function(){return pC})),n.d(y,"hannWindow",(function(){return mC})),n.d(y,"hammingWindow",(function(){return gC})),n.d(y,"frame",(function(){return yC})),n.d(y,"stft",(function(){return bC})),n.d(y,"inTopKAsync",(function(){return vC})),n.d(y,"op",(function(){return xm})),n.d(y,"image",(function(){return m})),n.d(y,"linalg",(function(){return f})),n.d(y,"losses",(function(){return p})),n.d(y,"spectral",(function(){return h})),n.d(y,"fused",(function(){return g})),n.d(y,"signal",(function(){return d}));var b={};n.r(b),n.d(b,"axesAreInnerMostDims",(function(){return rg})),n.d(b,"combineLocations",(function(){return sg})),n.d(b,"computeOutAndReduceShapes",(function(){return ig})),n.d(b,"expandShapeToKeepDim",(function(){return og})),n.d(b,"assertAxesAreInnerMostDims",(function(){return ag})),n.d(b,"getAxesPermutation",(function(){return lg})),n.d(b,"getUndoAxesPermutation",(function(){return ug})),n.d(b,"getInnerMostAxes",(function(){return cg})),n.d(b,"getBroadcastDims",(function(){return dm})),n.d(b,"getReductionAxes",(function(){return pm})),n.d(b,"assertAndGetBroadcastShape",(function(){return fm})),n.d(b,"assertParamsConsistent",(function(){return Cm})),n.d(b,"computeOutShape",(function(){return Sm})),n.d(b,"computePool2DInfo",(function(){return sy})),n.d(b,"computePool3DInfo",(function(){return iy})),n.d(b,"computeConv2DInfo",(function(){return oy})),n.d(b,"computeConv3DInfo",(function(){return ay})),n.d(b,"computeDefaultPad",(function(){return ly})),n.d(b,"tupleValuesAreOne",(function(){return py})),n.d(b,"eitherStridesOrDilationsAreOne",(function(){return fy})),n.d(b,"convertConv2DDataFormat",(function(){return my})),n.d(b,"PARALLELIZE_THRESHOLD",(function(){return Cw})),n.d(b,"computeOptimalWindowSize",(function(){return Sw})),n.d(b,"nonMaxSuppressionV3",(function(){return MC})),n.d(b,"nonMaxSuppressionV5",(function(){return LC})),n.d(b,"upcastType",(function(){return tm})),n.d(b,"getReshaped",(function(){return mS})),n.d(b,"getPermuted",(function(){return gS})),n.d(b,"getReshapedPermuted",(function(){return yS})),n.d(b,"getSliceBeginCoords",(function(){return bS})),n.d(b,"getSliceSize",(function(){return vS})),n.d(b,"prepareAndValidate",(function(){return nx})),n.d(b,"validateUpdateShape",(function(){return rx})),n.d(b,"validateInput",(function(){return sx})),n.d(b,"calculateShapes",(function(){return ix})),n.d(b,"SELU_SCALEALPHA",(function(){return Sb})),n.d(b,"SELU_SCALE",(function(){return _b})),n.d(b,"shouldFuse",(function(){return YC})),n.d(b,"ERF_P",(function(){return xS})),n.d(b,"ERF_A1",(function(){return wS})),n.d(b,"ERF_A2",(function(){return CS})),n.d(b,"ERF_A3",(function(){return SS})),n.d(b,"ERF_A4",(function(){return _S})),n.d(b,"ERF_A5",(function(){return ES})),n.d(b,"warn",(function(){return kS})),n.d(b,"log",(function(){return AS})),n.d(b,"mergeRealAndImagArrays",(function(){return IS})),n.d(b,"splitRealAndImagArrays",(function(){return NS})),n.d(b,"complexWithEvenIndex",(function(){return TS})),n.d(b,"complexWithOddIndex",(function(){return RS})),n.d(b,"getComplexWithIndex",(function(){return $S})),n.d(b,"assignToTypedArray",(function(){return DS})),n.d(b,"exponents",(function(){return OS})),n.d(b,"exponent",(function(){return FS})),n.d(b,"segment_util",(function(){return c})),n.d(b,"castTensor",(function(){return MS})),n.d(b,"reshapeTensor",(function(){return LS})),n.d(b,"linspaceImpl",(function(){return PS}));var v={};n.r(v),n.d(v,"nonMaxSuppressionV3",(function(){return MC})),n.d(v,"nonMaxSuppressionV5",(function(){return LC})),n.d(v,"split",(function(){return zS})),n.d(v,"tile",(function(){return BS})),n.d(v,"topkImpl",(function(){return VS})),n.d(v,"whereImpl",(function(){return hb}));var x={};n.r(x),n.d(x,"json",(function(){return QI}));var w={};n.r(w),n.d(w,"json",(function(){return tN}));var C={};n.r(C),n.d(C,"json",(function(){return eN}));var S={};n.r(S),n.d(S,"json",(function(){return nN}));var _={};n.r(_),n.d(_,"json",(function(){return rN}));var E={};n.r(E),n.d(E,"json",(function(){return sN}));var k={};n.r(k),n.d(k,"json",(function(){return iN}));var A={};n.r(A),n.d(A,"json",(function(){return oN}));var I={};n.r(I),n.d(I,"json",(function(){return aN}));var N={};n.r(N),n.d(N,"json",(function(){return lN}));var T={};n.r(T),n.d(T,"json",(function(){return uN}));var R={};n.r(R),n.d(R,"json",(function(){return cN}));var $={};n.r($),n.d($,"json",(function(){return hN}));var D={};n.r(D),n.d(D,"json",(function(){return dN}));var O={};n.r(O),n.d(O,"json",(function(){return pN}));var F={};n.r(F),n.d(F,"json",(function(){return fN}));var M={};function L(t){return"function"==typeof t}n.r(M),n.d(M,"maxImpl",(function(){return UN})),n.d(M,"transposeImpl",(function(){return WN}));let P=!1;const z={Promise:void 0,set useDeprecatedSynchronousErrorHandling(t){if(t){const t=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+t.stack)}else P&&console.log("RxJS: Back to a better error behavior. Thank you. <3");P=t},get useDeprecatedSynchronousErrorHandling(){return P}};function B(t){setTimeout(()=>{throw t},0)}const V={closed:!0,next(t){},error(t){if(z.useDeprecatedSynchronousErrorHandling)throw t;B(t)},complete(){}},U=(()=>Array.isArray||(t=>t&&"number"==typeof t.length))();function W(t){return null!==t&&"object"==typeof t}const j=(()=>{function t(t){return Error.call(this),this.message=t?`${t.length} errors occurred during unsubscription:\n${t.map((t,e)=>`${e+1}) ${t.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=t,this}return t.prototype=Object.create(Error.prototype),t})();let H=(()=>{class t{constructor(t){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,t&&(this._unsubscribe=t)}unsubscribe(){let e;if(this.closed)return;let{_parentOrParents:n,_unsubscribe:r,_subscriptions:s}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,n instanceof t)n.remove(this);else if(null!==n)for(let t=0;t<n.length;++t)n[t].remove(this);if(L(r))try{r.call(this)}catch(i){e=i instanceof j?q(i.errors):[i]}if(U(s)){let t=-1,n=s.length;for(;++t<n;){const n=s[t];if(W(n))try{n.unsubscribe()}catch(i){e=e||[],i instanceof j?e=e.concat(q(i.errors)):e.push(i)}}}if(e)throw new j(e)}add(e){let n=e;if(!e)return t.EMPTY;switch(typeof e){case"function":n=new t(e);case"object":if(n===this||n.closed||"function"!=typeof n.unsubscribe)return n;if(this.closed)return n.unsubscribe(),n;if(!(n instanceof t)){const e=n;n=new t,n._subscriptions=[e]}break;default:throw new Error("unrecognized teardown "+e+" added to Subscription.")}let{_parentOrParents:r}=n;if(null===r)n._parentOrParents=this;else if(r instanceof t){if(r===this)return n;n._parentOrParents=[r,this]}else{if(-1!==r.indexOf(this))return n;r.push(this)}const s=this._subscriptions;return null===s?this._subscriptions=[n]:s.push(n),n}remove(t){const e=this._subscriptions;if(e){const n=e.indexOf(t);-1!==n&&e.splice(n,1)}}}return t.EMPTY=function(t){return t.closed=!0,t}(new t),t})();function q(t){return t.reduce((t,e)=>t.concat(e instanceof j?e.errors:e),[])}const G=(()=>"function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random())();class K extends H{constructor(t,e,n){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=V;break;case 1:if(!t){this.destination=V;break}if("object"==typeof t){t instanceof K?(this.syncErrorThrowable=t.syncErrorThrowable,this.destination=t,t.add(this)):(this.syncErrorThrowable=!0,this.destination=new X(this,t));break}default:this.syncErrorThrowable=!0,this.destination=new X(this,t,e,n)}}[G](){return this}static create(t,e,n){const r=new K(t,e,n);return r.syncErrorThrowable=!1,r}next(t){this.isStopped||this._next(t)}error(t){this.isStopped||(this.isStopped=!0,this._error(t))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(t){this.destination.next(t)}_error(t){this.destination.error(t),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:t}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=t,this}}class X extends K{constructor(t,e,n,r){let s;super(),this._parentSubscriber=t;let i=this;L(e)?s=e:e&&(s=e.next,n=e.error,r=e.complete,e!==V&&(i=Object.create(e),L(i.unsubscribe)&&this.add(i.unsubscribe.bind(i)),i.unsubscribe=this.unsubscribe.bind(this))),this._context=i,this._next=s,this._error=n,this._complete=r}next(t){if(!this.isStopped&&this._next){const{_parentSubscriber:e}=this;z.useDeprecatedSynchronousErrorHandling&&e.syncErrorThrowable?this.__tryOrSetError(e,this._next,t)&&this.unsubscribe():this.__tryOrUnsub(this._next,t)}}error(t){if(!this.isStopped){const{_parentSubscriber:e}=this,{useDeprecatedSynchronousErrorHandling:n}=z;if(this._error)n&&e.syncErrorThrowable?(this.__tryOrSetError(e,this._error,t),this.unsubscribe()):(this.__tryOrUnsub(this._error,t),this.unsubscribe());else if(e.syncErrorThrowable)n?(e.syncErrorValue=t,e.syncErrorThrown=!0):B(t),this.unsubscribe();else{if(this.unsubscribe(),n)throw t;B(t)}}}complete(){if(!this.isStopped){const{_parentSubscriber:t}=this;if(this._complete){const e=()=>this._complete.call(this._context);z.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?(this.__tryOrSetError(t,e),this.unsubscribe()):(this.__tryOrUnsub(e),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(t,e){try{t.call(this._context,e)}catch(n){if(this.unsubscribe(),z.useDeprecatedSynchronousErrorHandling)throw n;B(n)}}__tryOrSetError(t,e,n){if(!z.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{e.call(this._context,n)}catch(r){return z.useDeprecatedSynchronousErrorHandling?(t.syncErrorValue=r,t.syncErrorThrown=!0,!0):(B(r),!0)}return!1}_unsubscribe(){const{_parentSubscriber:t}=this;this._context=null,this._parentSubscriber=null,t.unsubscribe()}}const Y=(()=>"function"==typeof Symbol&&Symbol.observable||"@@observable")();function Z(t){return t}let J=(()=>{class t{constructor(t){this._isScalar=!1,t&&(this._subscribe=t)}lift(e){const n=new t;return n.source=this,n.operator=e,n}subscribe(t,e,n){const{operator:r}=this,s=function(t,e,n){if(t){if(t instanceof K)return t;if(t[G])return t[G]()}return t||e||n?new K(t,e,n):new K(V)}(t,e,n);if(s.add(r?r.call(s,this.source):this.source||z.useDeprecatedSynchronousErrorHandling&&!s.syncErrorThrowable?this._subscribe(s):this._trySubscribe(s)),z.useDeprecatedSynchronousErrorHandling&&s.syncErrorThrowable&&(s.syncErrorThrowable=!1,s.syncErrorThrown))throw s.syncErrorValue;return s}_trySubscribe(t){try{return this._subscribe(t)}catch(e){z.useDeprecatedSynchronousErrorHandling&&(t.syncErrorThrown=!0,t.syncErrorValue=e),function(t){for(;t;){const{closed:e,destination:n,isStopped:r}=t;if(e||r)return!1;t=n&&n instanceof K?n:null}return!0}(t)?t.error(e):console.warn(e)}}forEach(t,e){return new(e=Q(e))((e,n)=>{let r;r=this.subscribe(e=>{try{t(e)}catch(s){n(s),r&&r.unsubscribe()}},n,e)})}_subscribe(t){const{source:e}=this;return e&&e.subscribe(t)}[Y](){return this}pipe(...t){return 0===t.length?this:(0===(e=t).length?Z:1===e.length?e[0]:function(t){return e.reduce((t,e)=>e(t),t)})(this);var e}toPromise(t){return new(t=Q(t))((t,e)=>{let n;this.subscribe(t=>n=t,t=>e(t),()=>t(n))})}}return t.create=e=>new t(e),t})();function Q(t){if(t||(t=z.Promise||Promise),!t)throw new Error("no Promise impl found");return t}const tt=(()=>{function t(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return t.prototype=Object.create(Error.prototype),t})();class et extends H{constructor(t,e){super(),this.subject=t,this.subscriber=e,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const t=this.subject,e=t.observers;if(this.subject=null,!e||0===e.length||t.isStopped||t.closed)return;const n=e.indexOf(this.subscriber);-1!==n&&e.splice(n,1)}}class nt extends K{constructor(t){super(t),this.destination=t}}let rt=(()=>{class t extends J{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[G](){return new nt(this)}lift(t){const e=new st(this,this);return e.operator=t,e}next(t){if(this.closed)throw new tt;if(!this.isStopped){const{observers:e}=this,n=e.length,r=e.slice();for(let s=0;s<n;s++)r[s].next(t)}}error(t){if(this.closed)throw new tt;this.hasError=!0,this.thrownError=t,this.isStopped=!0;const{observers:e}=this,n=e.length,r=e.slice();for(let s=0;s<n;s++)r[s].error(t);this.observers.length=0}complete(){if(this.closed)throw new tt;this.isStopped=!0;const{observers:t}=this,e=t.length,n=t.slice();for(let r=0;r<e;r++)n[r].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(t){if(this.closed)throw new tt;return super._trySubscribe(t)}_subscribe(t){if(this.closed)throw new tt;return this.hasError?(t.error(this.thrownError),H.EMPTY):this.isStopped?(t.complete(),H.EMPTY):(this.observers.push(t),new et(this,t))}asObservable(){const t=new J;return t.source=this,t}}return t.create=(t,e)=>new st(t,e),t})();class st extends rt{constructor(t,e){super(),this.destination=t,this.source=e}next(t){const{destination:e}=this;e&&e.next&&e.next(t)}error(t){const{destination:e}=this;e&&e.error&&this.destination.error(t)}complete(){const{destination:t}=this;t&&t.complete&&this.destination.complete()}_subscribe(t){const{source:e}=this;return e?this.source.subscribe(t):H.EMPTY}}function it(t){return t&&"function"==typeof t.schedule}class ot extends K{constructor(t,e,n){super(),this.parent=t,this.outerValue=e,this.outerIndex=n,this.index=0}_next(t){this.parent.notifyNext(this.outerValue,t,this.outerIndex,this.index++,this)}_error(t){this.parent.notifyError(t,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}const at=t=>e=>{for(let n=0,r=t.length;n<r&&!e.closed;n++)e.next(t[n]);e.complete()};function lt(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}const ut=lt(),ct=t=>t&&"number"==typeof t.length&&"function"!=typeof t;function ht(t){return!!t&&"function"!=typeof t.subscribe&&"function"==typeof t.then}const dt=t=>{if(t&&"function"==typeof t[Y])return r=t,t=>{const e=r[Y]();if("function"!=typeof e.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return e.subscribe(t)};if(ct(t))return at(t);if(ht(t))return n=t,t=>(n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,B),t);if(t&&"function"==typeof t[ut])return e=t,t=>{const n=e[ut]();for(;;){const e=n.next();if(e.done){t.complete();break}if(t.next(e.value),t.closed)break}return"function"==typeof n.return&&t.add(()=>{n.return&&n.return()}),t};{const e=W(t)?"an invalid object":`'${t}'`;throw new TypeError(`You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`)}var e,n,r};function pt(t,e,n,r,s=new ot(t,n,r)){if(!s.closed)return e instanceof J?e.subscribe(s):dt(e)(s)}class ft extends K{notifyNext(t,e,n,r,s){this.destination.next(e)}notifyError(t,e){this.destination.error(t)}notifyComplete(t){this.destination.complete()}}function mt(t,e){return function(n){if("function"!=typeof t)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return n.lift(new gt(t,e))}}class gt{constructor(t,e){this.project=t,this.thisArg=e}call(t,e){return e.subscribe(new yt(t,this.project,this.thisArg))}}class yt extends K{constructor(t,e,n){super(t),this.project=e,this.count=0,this.thisArg=n||this}_next(t){let e;try{e=this.project.call(this.thisArg,t,this.count++)}catch(n){return void this.destination.error(n)}this.destination.next(e)}}function bt(t,e){return new J(n=>{const r=new H;let s=0;return r.add(e.schedule((function(){s!==t.length?(n.next(t[s++]),n.closed||r.add(this.schedule())):n.complete()}))),r})}function vt(t,e){return e?function(t,e){if(null!=t){if(function(t){return t&&"function"==typeof t[Y]}(t))return function(t,e){return new J(n=>{const r=new H;return r.add(e.schedule(()=>{const s=t[Y]();r.add(s.subscribe({next(t){r.add(e.schedule(()=>n.next(t)))},error(t){r.add(e.schedule(()=>n.error(t)))},complete(){r.add(e.schedule(()=>n.complete()))}}))})),r})}(t,e);if(ht(t))return function(t,e){return new J(n=>{const r=new H;return r.add(e.schedule(()=>t.then(t=>{r.add(e.schedule(()=>{n.next(t),r.add(e.schedule(()=>n.complete()))}))},t=>{r.add(e.schedule(()=>n.error(t)))}))),r})}(t,e);if(ct(t))return bt(t,e);if(function(t){return t&&"function"==typeof t[ut]}(t)||"string"==typeof t)return function(t,e){if(!t)throw new Error("Iterable cannot be null");return new J(n=>{const r=new H;let s;return r.add(()=>{s&&"function"==typeof s.return&&s.return()}),r.add(e.schedule(()=>{s=t[ut](),r.add(e.schedule((function(){if(n.closed)return;let t,e;try{const n=s.next();t=n.value,e=n.done}catch(r){return void n.error(r)}e?n.complete():(n.next(t),this.schedule())})))})),r})}(t,e)}throw new TypeError((null!==t&&typeof t||t)+" is not observable")}(t,e):t instanceof J?t:new J(dt(t))}function xt(t,e,n=Number.POSITIVE_INFINITY){return"function"==typeof e?r=>r.pipe(xt((n,r)=>vt(t(n,r)).pipe(mt((t,s)=>e(n,t,r,s))),n)):("number"==typeof e&&(n=e),e=>e.lift(new wt(t,n)))}class wt{constructor(t,e=Number.POSITIVE_INFINITY){this.project=t,this.concurrent=e}call(t,e){return e.subscribe(new Ct(t,this.project,this.concurrent))}}class Ct extends ft{constructor(t,e,n=Number.POSITIVE_INFINITY){super(t),this.project=e,this.concurrent=n,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(t){this.active<this.concurrent?this._tryNext(t):this.buffer.push(t)}_tryNext(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(r){return void this.destination.error(r)}this.active++,this._innerSub(e,t,n)}_innerSub(t,e,n){const r=new ot(this,e,n),s=this.destination;s.add(r);const i=pt(this,t,void 0,void 0,r);i!==r&&s.add(i)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(t,e,n,r,s){this.destination.next(e)}notifyComplete(t){const e=this.buffer;this.remove(t),this.active--,e.length>0?this._next(e.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}function St(t=Number.POSITIVE_INFINITY){return xt(Z,t)}function _t(t,e){return e?bt(t,e):new J(at(t))}function Et(){return function(t){return t.lift(new kt(t))}}class kt{constructor(t){this.connectable=t}call(t,e){const{connectable:n}=this;n._refCount++;const r=new At(t,n),s=e.subscribe(r);return r.closed||(r.connection=n.connect()),s}}class At extends K{constructor(t,e){super(t),this.connectable=e}_unsubscribe(){const{connectable:t}=this;if(!t)return void(this.connection=null);this.connectable=null;const e=t._refCount;if(e<=0)return void(this.connection=null);if(t._refCount=e-1,e>1)return void(this.connection=null);const{connection:n}=this,r=t._connection;this.connection=null,!r||n&&r!==n||r.unsubscribe()}}class It extends J{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._refCount=0,this._isComplete=!1}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return t&&!t.isStopped||(this._subject=this.subjectFactory()),this._subject}connect(){let t=this._connection;return t||(this._isComplete=!1,t=this._connection=new H,t.add(this.source.subscribe(new Tt(this.getSubject(),this))),t.closed&&(this._connection=null,t=H.EMPTY)),t}refCount(){return Et()(this)}}const Nt=(()=>{const t=It.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:t._subscribe},_isComplete:{value:t._isComplete,writable:!0},getSubject:{value:t.getSubject},connect:{value:t.connect},refCount:{value:t.refCount}}})();class Tt extends nt{constructor(t,e){super(t),this.connectable=e}_error(t){this._unsubscribe(),super._error(t)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const t=this.connectable;if(t){this.connectable=null;const e=t._connection;t._refCount=0,t._subject=null,t._connection=null,e&&e.unsubscribe()}}}function Rt(){return new rt}function $t(t){return{toString:t}.toString()}function Dt(t,e,n){return $t(()=>{const r=function(t){return function(...e){if(t){const n=t(...e);for(const t in n)this[t]=n[t]}}}(e);function s(...t){if(this instanceof s)return r.apply(this,t),this;const e=new s(...t);return n.annotation=e,n;function n(t,n,r){const s=t.hasOwnProperty("__parameters__")?t.__parameters__:Object.defineProperty(t,"__parameters__",{value:[]}).__parameters__;for(;s.length<=r;)s.push(null);return(s[r]=s[r]||[]).push(e),t}}return n&&(s.prototype=Object.create(n.prototype)),s.prototype.ngMetadataName=t,s.annotationCls=s,s})}const Ot=Dt("Inject",t=>({token:t})),Ft=Dt("Optional"),Mt=Dt("Self"),Lt=Dt("SkipSelf");var Pt=function(t){return t[t.Default=0]="Default",t[t.Host=1]="Host",t[t.Self=2]="Self",t[t.SkipSelf=4]="SkipSelf",t[t.Optional=8]="Optional",t}({});function zt(t){for(let e in t)if(t[e]===zt)return e;throw Error("Could not find renamed property on target object.")}function Bt(t,e){for(const n in e)e.hasOwnProperty(n)&&!t.hasOwnProperty(n)&&(t[n]=e[n])}function Vt(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}function Ut(t){return{factory:t.factory,providers:t.providers||[],imports:t.imports||[]}}function Wt(t){return jt(t,t[qt])||jt(t,t[Xt])}function jt(t,e){return e&&e.token===t?e:null}function Ht(t){return t&&(t.hasOwnProperty(Gt)||t.hasOwnProperty(Yt))?t[Gt]:null}const qt=zt({"\u0275prov":zt}),Gt=zt({"\u0275inj":zt}),Kt=zt({"\u0275provFallback":zt}),Xt=zt({ngInjectableDef:zt}),Yt=zt({ngInjectorDef:zt});function Zt(t){if("string"==typeof t)return t;if(Array.isArray(t))return"["+t.map(Zt).join(", ")+"]";if(null==t)return""+t;if(t.overriddenName)return""+t.overriddenName;if(t.name)return""+t.name;const e=t.toString();if(null==e)return""+e;const n=e.indexOf("\n");return-1===n?e:e.substring(0,n)}function Jt(t,e){return null==t||""===t?null===e?"":e:null==e||""===e?t:t+" "+e}const Qt=zt({__forward_ref__:zt});function te(t){return t.__forward_ref__=te,t.toString=function(){return Zt(this())},t}function ee(t){return ne(t)?t():t}function ne(t){return"function"==typeof t&&t.hasOwnProperty(Qt)&&t.__forward_ref__===te}const re="undefined"!=typeof globalThis&&globalThis,se="undefined"!=typeof window&&window,ie="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,oe="undefined"!=typeof global&&global,ae=re||oe||se||ie,le=zt({"\u0275cmp":zt}),ue=zt({"\u0275dir":zt}),ce=zt({"\u0275pipe":zt}),he=zt({"\u0275mod":zt}),de=zt({"\u0275loc":zt}),pe=zt({"\u0275fac":zt}),fe=zt({__NG_ELEMENT_ID__:zt});class me{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=Vt({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}toString(){return"InjectionToken "+this._desc}}const ge=new me("INJECTOR",-1),ye={},be=/\n/gm,ve=zt({provide:String,useValue:zt});let xe,we=void 0;function Ce(t){const e=we;return we=t,e}function Se(t){const e=xe;return xe=t,e}function _e(t,e=Pt.Default){if(void 0===we)throw new Error("inject() must be called from an injection context");return null===we?ke(t,void 0,e):we.get(t,e&Pt.Optional?null:void 0,e)}function Ee(t,e=Pt.Default){return(xe||_e)(ee(t),e)}function ke(t,e,n){const r=Wt(t);if(r&&"root"==r.providedIn)return void 0===r.value?r.value=r.factory():r.value;if(n&Pt.Optional)return null;if(void 0!==e)return e;throw new Error(`Injector: NOT_FOUND [${Zt(t)}]`)}function Ae(t){const e=[];for(let n=0;n<t.length;n++){const r=ee(t[n]);if(Array.isArray(r)){if(0===r.length)throw new Error("Arguments array must have arguments.");let t=void 0,n=Pt.Default;for(let e=0;e<r.length;e++){const s=r[e];s instanceof Ft||"Optional"===s.ngMetadataName||s===Ft?n|=Pt.Optional:s instanceof Lt||"SkipSelf"===s.ngMetadataName||s===Lt?n|=Pt.SkipSelf:s instanceof Mt||"Self"===s.ngMetadataName||s===Mt?n|=Pt.Self:t=s instanceof Ot||s===Ot?s.token:s}e.push(Ee(t,n))}else e.push(Ee(r))}return e}class Ie{get(t,e=ye){if(e===ye){const e=new Error(`NullInjectorError: No provider for ${Zt(t)}!`);throw e.name="NullInjectorError",e}return e}}class Ne{}class Te{}function Re(t,e){t.forEach(t=>Array.isArray(t)?Re(t,e):e(t))}function $e(t,e,n){e>=t.length?t.push(n):t.splice(e,0,n)}function De(t,e){return e>=t.length-1?t.pop():t.splice(e,1)[0]}function Oe(t,e){const n=[];for(let r=0;r<t;r++)n.push(e);return n}function Fe(t,e,n){let r=Le(t,e);return r>=0?t[1|r]=n:(r=~r,function(t,e,n,r){let s=t.length;if(s==e)t.push(n,r);else if(1===s)t.push(r,t[0]),t[0]=n;else{for(s--,t.push(t[s-1],t[s]);s>e;)t[s]=t[s-2],s--;t[e]=n,t[e+1]=r}}(t,r,e,n)),r}function Me(t,e){const n=Le(t,e);if(n>=0)return t[1|n]}function Le(t,e){return function(t,e,n){let r=0,s=t.length>>1;for(;s!==r;){const n=r+(s-r>>1),i=t[n<<1];if(e===i)return n<<1;i>e?s=n:r=n+1}return~(s<<1)}(t,e)}var Pe=function(t){return t[t.OnPush=0]="OnPush",t[t.Default=1]="Default",t}({}),ze=function(t){return t[t.Emulated=0]="Emulated",t[t.Native=1]="Native",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom",t}({});const Be={},Ve=[];let Ue=0;function We(t){return $t(()=>{const e={},n={type:t.type,providersResolver:null,decls:t.decls,vars:t.vars,factory:null,template:t.template||null,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:e,inputs:null,outputs:null,exportAs:t.exportAs||null,onPush:t.changeDetection===Pe.OnPush,directiveDefs:null,pipeDefs:null,selectors:t.selectors||Ve,viewQuery:t.viewQuery||null,features:t.features||null,data:t.data||{},encapsulation:t.encapsulation||ze.Emulated,id:"c",styles:t.styles||Ve,_:null,setInput:null,schemas:t.schemas||null,tView:null},r=t.directives,s=t.features,i=t.pipes;return n.id+=Ue++,n.inputs=Ke(t.inputs,e),n.outputs=Ke(t.outputs),s&&s.forEach(t=>t(n)),n.directiveDefs=r?()=>("function"==typeof r?r():r).map(je):null,n.pipeDefs=i?()=>("function"==typeof i?i():i).map(He):null,n})}function je(t){return Ye(t)||function(t){return t[ue]||null}(t)}function He(t){return function(t){return t[ce]||null}(t)}const qe={};function Ge(t){const e={type:t.type,bootstrap:t.bootstrap||Ve,declarations:t.declarations||Ve,imports:t.imports||Ve,exports:t.exports||Ve,transitiveCompileScopes:null,schemas:t.schemas||null,id:t.id||null};return null!=t.id&&$t(()=>{qe[t.id]=t.type}),e}function Ke(t,e){if(null==t)return Be;const n={};for(const r in t)if(t.hasOwnProperty(r)){let s=t[r],i=s;Array.isArray(s)&&(i=s[1],s=s[0]),n[s]=r,e&&(e[s]=i)}return n}const Xe=We;function Ye(t){return t[le]||null}function Ze(t,e){return t.hasOwnProperty(pe)?t[pe]:null}function Je(t,e){const n=t[he]||null;if(!n&&!0===e)throw new Error(`Type ${Zt(t)} does not have '\u0275mod' property.`);return n}function Qe(t){return Array.isArray(t)&&"object"==typeof t[1]}function tn(t){return Array.isArray(t)&&!0===t[1]}function en(t){return 0!=(8&t.flags)}function nn(t){return 2==(2&t.flags)}function rn(t){return 1==(1&t.flags)}function sn(t){return null!==t.template}function on(t){return 0!=(512&t[2])}class an{constructor(t,e,n){this.previousValue=t,this.currentValue=e,this.firstChange=n}isFirstChange(){return this.firstChange}}function ln(){return un}function un(t){return t.type.prototype.ngOnChanges&&(t.setInput=hn),cn}function cn(){const t=dn(this),e=null==t?void 0:t.current;if(e){const n=t.previous;if(n===Be)t.previous=e;else for(let t in e)n[t]=e[t];t.current=null,this.ngOnChanges(e)}}function hn(t,e,n,r){const s=dn(t)||function(t,e){return t.__ngSimpleChanges__=e}(t,{previous:Be,current:null}),i=s.current||(s.current={}),o=s.previous,a=this.declaredInputs[n],l=o[a];i[a]=new an(l&&l.currentValue,e,o===Be),t[r]=e}function dn(t){return t.__ngSimpleChanges__||null}ln.ngInherit=!0;let pn=void 0;function fn(t){return!!t.listen}const mn={createRenderer:(t,e)=>void 0!==pn?pn:"undefined"!=typeof document?document:void 0};function gn(t){for(;Array.isArray(t);)t=t[0];return t}function yn(t,e){return gn(e[t+20])}function bn(t,e){return gn(e[t.index])}function vn(t,e){return t.data[e+20]}function xn(t,e){const n=e[t];return Qe(n)?n:n[0]}function wn(t){const e=function(t){return t.__ngContext__||null}(t);return e?Array.isArray(e)?e:e.lView:null}function Cn(t){return 4==(4&t[2])}function Sn(t){return 128==(128&t[2])}function _n(t,e){return null===t||null==e?null:t[e]}function En(t){t[18]=0}function kn(t,e){t[5]+=e;let n=t,r=t[3];for(;null!==r&&(1===e&&1===n[5]||-1===e&&0===n[5]);)r[5]+=e,n=r,r=r[3]}const An={lFrame:qn(null),bindingsEnabled:!0,checkNoChangesMode:!1};function In(){return An.bindingsEnabled}function Nn(){return An.lFrame.lView}function Tn(){return An.lFrame.tView}function Rn(){return An.lFrame.previousOrParentTNode}function $n(t,e){An.lFrame.previousOrParentTNode=t,An.lFrame.isParent=e}function Dn(){return An.lFrame.isParent}function On(){An.lFrame.isParent=!1}function Fn(){return An.checkNoChangesMode}function Mn(t){An.checkNoChangesMode=t}function Ln(){return An.lFrame.bindingIndex++}function Pn(t){const e=An.lFrame,n=e.bindingIndex;return e.bindingIndex=e.bindingIndex+t,n}function zn(t,e){const n=An.lFrame;n.bindingIndex=n.bindingRootIndex=t,Bn(e)}function Bn(t){An.lFrame.currentDirectiveIndex=t}function Vn(){return An.lFrame.currentQueryIndex}function Un(t){An.lFrame.currentQueryIndex=t}function Wn(t,e){const n=Hn();An.lFrame=n,n.previousOrParentTNode=e,n.lView=t}function jn(t,e){const n=Hn(),r=t[1];An.lFrame=n,n.previousOrParentTNode=e,n.lView=t,n.tView=r,n.contextLView=t,n.bindingIndex=r.bindingStartIndex}function Hn(){const t=An.lFrame,e=null===t?null:t.child;return null===e?qn(t):e}function qn(t){const e={previousOrParentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:0,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null};return null!==t&&(t.child=e),e}function Gn(){const t=An.lFrame;return An.lFrame=t.parent,t.previousOrParentTNode=null,t.lView=null,t}const Kn=Gn;function Xn(){const t=Gn();t.isParent=!0,t.tView=null,t.selectedIndex=0,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function Yn(){return An.lFrame.selectedIndex}function Zn(t){An.lFrame.selectedIndex=t}function Jn(){const t=An.lFrame;return vn(t.tView,t.selectedIndex)}function Qn(){An.lFrame.currentNamespace="http://www.w3.org/2000/svg"}function tr(){An.lFrame.currentNamespace=null}function er(t,e){for(let n=e.directiveStart,r=e.directiveEnd;n<r;n++){const e=t.data[n].type.prototype,{ngAfterContentInit:r,ngAfterContentChecked:s,ngAfterViewInit:i,ngAfterViewChecked:o,ngOnDestroy:a}=e;r&&(t.contentHooks||(t.contentHooks=[])).push(-n,r),s&&((t.contentHooks||(t.contentHooks=[])).push(n,s),(t.contentCheckHooks||(t.contentCheckHooks=[])).push(n,s)),i&&(t.viewHooks||(t.viewHooks=[])).push(-n,i),o&&((t.viewHooks||(t.viewHooks=[])).push(n,o),(t.viewCheckHooks||(t.viewCheckHooks=[])).push(n,o)),null!=a&&(t.destroyHooks||(t.destroyHooks=[])).push(n,a)}}function nr(t,e,n){ir(t,e,3,n)}function rr(t,e,n,r){(3&t[2])===n&&ir(t,e,n,r)}function sr(t,e){let n=t[2];(3&n)===e&&(n&=2047,n+=1,t[2]=n)}function ir(t,e,n,r){const s=null!=r?r:-1;let i=0;for(let o=void 0!==r?65535&t[18]:0;o<e.length;o++)if("number"==typeof e[o+1]){if(i=e[o],null!=r&&i>=r)break}else e[o]<0&&(t[18]+=65536),(i<s||-1==s)&&(or(t,n,e,o),t[18]=(4294901760&t[18])+o+2),o++}function or(t,e,n,r){const s=n[r]<0,i=n[r+1],o=t[s?-n[r]:n[r]];s?t[2]>>11<t[18]>>16&&(3&t[2])===e&&(t[2]+=2048,i.call(o)):i.call(o)}class ar{constructor(t,e,n){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=n}}function lr(t,e,n){const r=fn(t);let s=0;for(;s<n.length;){const i=n[s];if("number"==typeof i){if(0!==i)break;s++;const o=n[s++],a=n[s++],l=n[s++];r?t.setAttribute(e,a,l,o):e.setAttributeNS(o,a,l)}else{const o=i,a=n[++s];cr(o)?r&&t.setProperty(e,o,a):r?t.setAttribute(e,o,a):e.setAttribute(o,a),s++}}return s}function ur(t){return 3===t||4===t||6===t}function cr(t){return 64===t.charCodeAt(0)}function hr(t,e){if(null===e||0===e.length);else if(null===t||0===t.length)t=e.slice();else{let n=-1;for(let r=0;r<e.length;r++){const s=e[r];"number"==typeof s?n=s:0===n||dr(t,n,s,null,-1===n||2===n?e[++r]:null)}}return t}function dr(t,e,n,r,s){let i=0,o=t.length;if(-1===e)o=-1;else for(;i<t.length;){const n=t[i++];if("number"==typeof n){if(n===e){o=-1;break}if(n>e){o=i-1;break}}}for(;i<t.length;){const e=t[i];if("number"==typeof e)break;if(e===n){if(null===r)return void(null!==s&&(t[i+1]=s));if(r===t[i+1])return void(t[i+2]=s)}i++,null!==r&&i++,null!==s&&i++}-1!==o&&(t.splice(o,0,e),i=o+1),t.splice(i++,0,n),null!==r&&t.splice(i++,0,r),null!==s&&t.splice(i++,0,s)}function pr(t){return-1!==t}function fr(t){return 32767&t}function mr(t){return t>>16}function gr(t,e){let n=mr(t),r=e;for(;n>0;)r=r[15],n--;return r}function yr(t){return"string"==typeof t?t:null==t?"":""+t}function br(t){return"function"==typeof t?t.name||t.toString():"object"==typeof t&&null!=t&&"function"==typeof t.type?t.type.name||t.type.toString():yr(t)}const vr=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(ae))();function xr(t){return t instanceof Function?t():t}let wr=!0;function Cr(t){const e=wr;return wr=t,e}let Sr=0;function _r(t,e){const n=kr(t,e);if(-1!==n)return n;const r=e[1];r.firstCreatePass&&(t.injectorIndex=e.length,Er(r.data,t),Er(e,null),Er(r.blueprint,null));const s=Ar(t,e),i=t.injectorIndex;if(pr(s)){const t=fr(s),n=gr(s,e),r=n[1].data;for(let s=0;s<8;s++)e[i+s]=n[t+s]|r[t+s]}return e[i+8]=s,i}function Er(t,e){t.push(0,0,0,0,0,0,0,0,e)}function kr(t,e){return-1===t.injectorIndex||t.parent&&t.parent.injectorIndex===t.injectorIndex||null==e[t.injectorIndex+8]?-1:t.injectorIndex}function Ar(t,e){if(t.parent&&-1!==t.parent.injectorIndex)return t.parent.injectorIndex;let n=e[6],r=1;for(;n&&-1===n.injectorIndex;)n=(e=e[15])?e[6]:null,r++;return n?n.injectorIndex|r<<16:-1}function Ir(t,e,n){!function(t,e,n){let r;"string"==typeof n?r=n.charCodeAt(0)||0:n.hasOwnProperty(fe)&&(r=n[fe]),null==r&&(r=n[fe]=Sr++);const s=255&r,i=1<<s,o=64&s,a=32&s,l=e.data;128&s?o?a?l[t+7]|=i:l[t+6]|=i:a?l[t+5]|=i:l[t+4]|=i:o?a?l[t+3]|=i:l[t+2]|=i:a?l[t+1]|=i:l[t]|=i}(t,e,n)}function Nr(t,e,n,r=Pt.Default,s){if(null!==t){const s=function(t){if("string"==typeof t)return t.charCodeAt(0)||0;const e=t.hasOwnProperty(fe)?t[fe]:void 0;return"number"==typeof e&&e>0?255&e:e}(n);if("function"==typeof s){Wn(e,t);try{const t=s();if(null!=t||r&Pt.Optional)return t;throw new Error(`No provider for ${br(n)}!`)}finally{Kn()}}else if("number"==typeof s){if(-1===s)return new Mr(t,e);let i=null,o=kr(t,e),a=-1,l=r&Pt.Host?e[16][6]:null;for((-1===o||r&Pt.SkipSelf)&&(a=-1===o?Ar(t,e):e[o+8],Fr(r,!1)?(i=e[1],o=fr(a),e=gr(a,e)):o=-1);-1!==o;){a=e[o+8];const t=e[1];if(Or(s,o,t.data)){const t=Rr(o,e,n,i,r,l);if(t!==Tr)return t}Fr(r,e[1].data[o+8]===l)&&Or(s,o,e)?(i=t,o=fr(a),e=gr(a,e)):o=-1}}}if(r&Pt.Optional&&void 0===s&&(s=null),0==(r&(Pt.Self|Pt.Host))){const t=e[9],i=Se(void 0);try{return t?t.get(n,s,r&Pt.Optional):ke(n,s,r&Pt.Optional)}finally{Se(i)}}if(r&Pt.Optional)return s;throw new Error(`NodeInjector: NOT_FOUND [${br(n)}]`)}const Tr={};function Rr(t,e,n,r,s,i){const o=e[1],a=o.data[t+8],l=$r(a,o,n,null==r?nn(a)&&wr:r!=o&&3===a.type,s&Pt.Host&&i===a);return null!==l?Dr(e,o,l,a):Tr}function $r(t,e,n,r,s){const i=t.providerIndexes,o=e.data,a=1048575&i,l=t.directiveStart,u=i>>20,c=s?a+u:t.directiveEnd;for(let h=r?a:a+u;h<c;h++){const t=o[h];if(h<l&&n===t||h>=l&&t.type===n)return h}if(s){const t=o[l];if(t&&sn(t)&&t.type===n)return l}return null}function Dr(t,e,n,r){let s=t[n];const i=e.data;if(s instanceof ar){const o=s;if(o.resolving)throw new Error("Circular dep for "+br(i[n]));const a=Cr(o.canSeeViewProviders);let l;o.resolving=!0,o.injectImpl&&(l=Se(o.injectImpl)),Wn(t,r);try{s=t[n]=o.factory(void 0,i,t,r),e.firstCreatePass&&n>=r.directiveStart&&function(t,e,n){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:i}=e.type.prototype;if(r){const r=un(e);(n.preOrderHooks||(n.preOrderHooks=[])).push(t,r),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(t,r)}s&&(n.preOrderHooks||(n.preOrderHooks=[])).push(0-t,s),i&&((n.preOrderHooks||(n.preOrderHooks=[])).push(t,i),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(t,i))}(n,i[n],e)}finally{o.injectImpl&&Se(l),Cr(a),o.resolving=!1,Kn()}}return s}function Or(t,e,n){const r=64&t,s=32&t;let i;return i=128&t?r?s?n[e+7]:n[e+6]:s?n[e+5]:n[e+4]:r?s?n[e+3]:n[e+2]:s?n[e+1]:n[e],!!(i&1<<t)}function Fr(t,e){return!(t&Pt.Self||t&Pt.Host&&e)}class Mr{constructor(t,e){this._tNode=t,this._lView=e}get(t,e){return Nr(this._tNode,this._lView,t,void 0,e)}}function Lr(t){const e=t;if(ne(t))return()=>{const t=Lr(ee(e));return t?t():null};let n=Ze(e);if(null===n){const t=Ht(e);n=t&&t.factory}return n||null}function Pr(t){return $t(()=>{const e=t.prototype.constructor,n=e[pe]||Lr(e),r=Object.prototype;let s=Object.getPrototypeOf(t.prototype).constructor;for(;s&&s!==r;){const t=s[pe]||Lr(s);if(t&&t!==n)return t;s=Object.getPrototypeOf(s)}return t=>new t})}function zr(t){return t.ngDebugContext}function Br(t){return t.ngOriginalError}function Vr(t,...e){t.error(...e)}class Ur{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t),n=this._findContext(t),r=function(t){return t.ngErrorLogger||Vr}(t);r(this._console,"ERROR",t),e&&r(this._console,"ORIGINAL ERROR",e),n&&r(this._console,"ERROR CONTEXT",n)}_findContext(t){return t?zr(t)?zr(t):this._findContext(Br(t)):null}_findOriginalError(t){let e=Br(t);for(;e&&Br(e);)e=Br(e);return e}}function Wr(t){return t instanceof class{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return"SafeValue must use [property]=binding: "+this.changingThisBreaksApplicationSecurity+" (see http://g.co/ng/security#xss)"}}?t.changingThisBreaksApplicationSecurity:t}let jr=!0,Hr=!1;function qr(){return Hr=!0,jr}function Gr(t,e){t.__ngContext__=e}function Kr(t){throw new Error("Multiple components match node with tagname "+t.tagName)}function Xr(){throw new Error("Cannot mix multi providers and regular providers")}function Yr(t,e,n){let r=t.length;for(;;){const s=t.indexOf(e,n);if(-1===s)return s;if(0===s||t.charCodeAt(s-1)<=32){const n=e.length;if(s+n===r||t.charCodeAt(s+n)<=32)return s}n=s+1}}function Zr(t,e,n){let r=0;for(;r<t.length;){let s=t[r++];if(n&&"class"===s){if(s=t[r],-1!==Yr(s.toLowerCase(),e,0))return!0}else if(1===s){for(;r<t.length&&"string"==typeof(s=t[r++]);)if(s.toLowerCase()===e)return!0;return!1}}return!1}function Jr(t){return 0===t.type&&"ng-template"!==t.tagName}function Qr(t,e,n){return e===(0!==t.type||n?t.tagName:"ng-template")}function ts(t,e,n){let r=4;const s=t.attrs||[],i=function(t){for(let e=0;e<t.length;e++)if(ur(t[e]))return e;return t.length}(s);let o=!1;for(let a=0;a<e.length;a++){const l=e[a];if("number"!=typeof l){if(!o)if(4&r){if(r=2|1&r,""!==l&&!Qr(t,l,n)||""===l&&1===e.length){if(es(r))return!1;o=!0}}else{const u=8&r?l:e[++a];if(8&r&&null!==t.attrs){if(!Zr(t.attrs,u,n)){if(es(r))return!1;o=!0}continue}const c=ns(8&r?"class":l,s,Jr(t),n);if(-1===c){if(es(r))return!1;o=!0;continue}if(""!==u){let t;t=c>i?"":s[c+1].toLowerCase();const e=8&r?t:null;if(e&&-1!==Yr(e,u,0)||2&r&&u!==t){if(es(r))return!1;o=!0}}}}else{if(!o&&!es(r)&&!es(l))return!1;if(o&&es(l))continue;o=!1,r=l|1&r}}return es(r)||o}function es(t){return 0==(1&t)}function ns(t,e,n,r){if(null===e)return-1;let s=0;if(r||!n){let n=!1;for(;s<e.length;){const r=e[s];if(r===t)return s;if(3===r||6===r)n=!0;else{if(1===r||2===r){let t=e[++s];for(;"string"==typeof t;)t=e[++s];continue}if(4===r)break;if(0===r){s+=4;continue}}s+=n?1:2}return-1}return function(t,e){let n=t.indexOf(4);if(n>-1)for(n++;n<t.length;){const r=t[n];if("number"==typeof r)return-1;if(r===e)return n;n++}return-1}(e,t)}function rs(t,e,n=!1){for(let r=0;r<e.length;r++)if(ts(t,e[r],n))return!0;return!1}function ss(t,e){return t?":not("+e.trim()+")":e}function is(t){let e=t[0],n=1,r=2,s="",i=!1;for(;n<t.length;){let o=t[n];if("string"==typeof o)if(2&r){const e=t[++n];s+="["+o+(e.length>0?'="'+e+'"':"")+"]"}else 8&r?s+="."+o:4&r&&(s+=" "+o);else""===s||es(o)||(e+=ss(i,s),s=""),r=o,i=i||!es(r);n++}return""!==s&&(e+=ss(i,s)),e}const os={};function as(t){const e=t[3];return tn(e)?e[3]:e}function ls(t){return cs(t[13])}function us(t){return cs(t[4])}function cs(t){for(;null!==t&&!tn(t);)t=t[4];return t}function hs(t){ds(Tn(),Nn(),Yn()+t,Fn())}function ds(t,e,n,r){if(!r)if(3==(3&e[2])){const r=t.preOrderCheckHooks;null!==r&&nr(e,r,n)}else{const r=t.preOrderHooks;null!==r&&rr(e,r,0,n)}Zn(n)}function ps(t,e){return t<<17|e<<2}function fs(t){return t>>17&32767}function ms(t){return 2|t}function gs(t){return(131068&t)>>2}function ys(t,e){return-131069&t|e<<2}function bs(t){return 1|t}function vs(t,e){const n=t.contentQueries;if(null!==n)for(let r=0;r<n.length;r+=2){const s=n[r],i=n[r+1];if(-1!==i){const n=t.data[i];Un(s),n.contentQueries(2,e[i],i)}}}function xs(t,e,n){return fn(e)?e.createElement(t,n):null===n?e.createElement(t):e.createElementNS(n,t)}function ws(t,e,n,r,s,i,o,a,l,u){const c=e.blueprint.slice();return c[0]=s,c[2]=140|r,En(c),c[3]=c[15]=t,c[8]=n,c[10]=o||t&&t[10],c[11]=a||t&&t[11],c[12]=l||t&&t[12]||null,c[9]=u||t&&t[9]||null,c[6]=i,c[16]=2==e.type?t[16]:c,c}function Cs(t,e,n,r,s,i){const o=n+20,a=t.data[o]||function(t,e,n,r,s,i){const o=Rn(),a=Dn(),l=a?o:o&&o.parent,u=t.data[n]=Ts(0,l&&l!==e?l:null,r,n,s,i);return null===t.firstChild&&(t.firstChild=u),o&&(!a||null!=o.child||null===u.parent&&2!==o.type?a||(o.next=u):o.child=u),u}(t,e,o,r,s,i);return $n(a,!0),a}function Ss(t,e,n){jn(e,e[6]);try{const r=t.viewQuery;null!==r&&Ys(1,r,n);const s=t.template;null!==s&&ks(t,e,s,1,n),t.firstCreatePass&&(t.firstCreatePass=!1),t.staticContentQueries&&vs(t,e),t.staticViewQueries&&Ys(2,t.viewQuery,n);const i=t.components;null!==i&&function(t,e){for(let n=0;n<e.length;n++)Hs(t,e[n])}(e,i)}catch(r){throw t.firstCreatePass&&(t.incompleteFirstPass=!0),r}finally{e[2]&=-5,Xn()}}function _s(t,e,n,r){const s=e[2];if(256==(256&s))return;jn(e,e[6]);const i=Fn();try{En(e),An.lFrame.bindingIndex=t.bindingStartIndex,null!==n&&ks(t,e,n,2,r);const o=3==(3&s);if(!i)if(o){const n=t.preOrderCheckHooks;null!==n&&nr(e,n,null)}else{const n=t.preOrderHooks;null!==n&&rr(e,n,0,null),sr(e,0)}if(function(t){for(let e=ls(t);null!==e;e=us(e)){if(!e[2])continue;const t=e[9];for(let e=0;e<t.length;e++){const n=t[e],r=n[3];0==(1024&n[2])&&kn(r,1),n[2]|=1024}}}(e),function(t){for(let e=ls(t);null!==e;e=us(e))for(let t=10;t<e.length;t++){const n=e[t],r=n[1];Sn(n)&&_s(r,n,r.template,n[8])}}(e),null!==t.contentQueries&&vs(t,e),!i)if(o){const n=t.contentCheckHooks;null!==n&&nr(e,n)}else{const n=t.contentHooks;null!==n&&rr(e,n,1),sr(e,1)}!function(t,e){try{const n=t.expandoInstructions;if(null!==n){let r=t.expandoStartIndex,s=-1,i=-1;for(let t=0;t<n.length;t++){const o=n[t];"number"==typeof o?o<=0?(i=0-o,Zn(i),r+=9+n[++t],s=r):r+=o:(null!==o&&(zn(r,s),o(2,e[s])),s++)}}}finally{Zn(-1)}}(t,e);const a=t.components;null!==a&&function(t,e){for(let n=0;n<e.length;n++)js(t,e[n])}(e,a);const l=t.viewQuery;if(null!==l&&Ys(2,l,r),!i)if(o){const n=t.viewCheckHooks;null!==n&&nr(e,n)}else{const n=t.viewHooks;null!==n&&rr(e,n,2),sr(e,2)}!0===t.firstUpdatePass&&(t.firstUpdatePass=!1),i||(e[2]&=-73),1024&e[2]&&(e[2]&=-1025,kn(e[3],-1))}finally{Xn()}}function Es(t,e,n,r){const s=e[10],i=!Fn(),o=Cn(e);try{i&&!o&&s.begin&&s.begin(),o&&Ss(t,e,r),_s(t,e,n,r)}finally{i&&!o&&s.end&&s.end()}}function ks(t,e,n,r,s){const i=Yn();try{Zn(-1),2&r&&e.length>20&&ds(t,e,0,Fn()),n(r,s)}finally{Zn(i)}}function As(t){const e=t.tView;return null===e||e.incompleteFirstPass?t.tView=Is(1,-1,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts):e}function Is(t,e,n,r,s,i,o,a,l,u){const c=20+r,h=c+s,d=function(t,e){const n=[];for(let r=0;r<e;r++)n.push(r<t?null:os);return n}(c,h);return d[1]={type:t,id:e,blueprint:d,template:n,queries:null,viewQuery:a,node:null,data:d.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:h,expandoInstructions:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof i?i():i,pipeRegistry:"function"==typeof o?o():o,firstChild:null,schemas:l,consts:u,incompleteFirstPass:!1}}function Ns(t,e,n,r){const s=Js(e);s.push(n),t.firstCreatePass&&function(t){return t.cleanup||(t.cleanup=[])}(t).push(r,s.length-1)}function Ts(t,e,n,r,s,i){return{type:n,index:r,injectorIndex:e?e.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,tagName:s,attrs:i,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:e,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}function Rs(t,e,n){for(let r in t)if(t.hasOwnProperty(r)){const s=t[r];(n=null===n?{}:n).hasOwnProperty(r)?n[r].push(e,s):n[r]=[e,s]}return n}function $s(t,e,n,r,s,i,o,a){const l=bn(e,n);let u,c=e.inputs;var h;!a&&null!=c&&(u=c[r])?(ti(t,n,u,r,s),nn(e)&&function(t,e){const n=xn(e,t);16&n[2]||(n[2]|=64)}(n,e.index)):3===e.type&&(r="class"===(h=r)?"className":"for"===h?"htmlFor":"formaction"===h?"formAction":"innerHtml"===h?"innerHTML":"readonly"===h?"readOnly":"tabindex"===h?"tabIndex":h,s=null!=o?o(s,e.tagName||"",r):s,fn(i)?i.setProperty(l,r,s):cr(r)||(l.setProperty?l.setProperty(r,s):l[r]=s))}function Ds(t,e){const n=t.expandoInstructions;n.push(e.hostBindings),0!==e.hostVars&&n.push(e.hostVars)}function Os(t,e,n){for(let r=0;r<n;r++)e.push(os),t.blueprint.push(os),t.data.push(null)}function Fs(t,e){null!==t.hostBindings&&t.hostBindings(1,e)}function Ms(t,e,n){const r=20-e.index,s=t.data.length-(1048575&e.providerIndexes);(t.expandoInstructions||(t.expandoInstructions=[])).push(r,s,n)}function Ls(t,e){e.flags|=2,(t.components||(t.components=[])).push(e.index)}function Ps(t,e,n){if(n){if(e.exportAs)for(let r=0;r<e.exportAs.length;r++)n[e.exportAs[r]]=t;sn(e)&&(n[""]=t)}}function zs(t,e,n){t.flags|=1,t.directiveStart=e,t.directiveEnd=e+n,t.providerIndexes=e}function Bs(t,e,n){t.data.push(n);const r=n.factory||(n.factory=Ze(n.type)),s=new ar(r,sn(n),null);t.blueprint.push(s),e.push(s)}function Vs(t,e,n){const r=bn(e,t),s=As(n),i=t[10],o=qs(t,ws(t,s,null,n.onPush?64:16,r,e,i,i.createRenderer(r,n)));t[e.index]=o}function Us(t,e,n,r,s,i){const o=i[e];if(null!==o){const t=r.setInput;for(let e=0;e<o.length;){const s=o[e++],i=o[e++],a=o[e++];null!==t?r.setInput(n,a,s,i):n[i]=a}}}function Ws(t,e){let n=null,r=0;for(;r<e.length;){const s=e[r];if(0!==s)if(5!==s){if("number"==typeof s)break;t.hasOwnProperty(s)&&(null===n&&(n=[]),n.push(s,t[s],e[r+1])),r+=2}else r+=2;else r+=4}return n}function js(t,e){const n=xn(e,t);if(Sn(n)){const t=n[1];80&n[2]?_s(t,n,t.template,n[8]):n[5]>0&&function t(e){for(let r=ls(e);null!==r;r=us(r))for(let e=10;e<r.length;e++){const n=r[e];if(1024&n[2]){const t=n[1];_s(t,n,t.template,n[8])}else n[5]>0&&t(n)}const n=e[1].components;if(null!==n)for(let r=0;r<n.length;r++){const s=xn(n[r],e);Sn(s)&&s[5]>0&&t(s)}}(n)}}function Hs(t,e){const n=xn(e,t),r=n[1];!function(t,e){for(let n=e.length;n<t.blueprint.length;n++)e.push(t.blueprint[n])}(r,n),Ss(r,n,n[8])}function qs(t,e){return t[13]?t[14][4]=e:t[13]=e,t[14]=e,e}function Gs(t){for(;t;){t[2]|=64;const e=as(t);if(on(t)&&!e)return t;t=e}return null}function Ks(t,e,n){const r=e[10];r.begin&&r.begin();try{_s(t,e,t.template,n)}catch(s){throw Qs(e,s),s}finally{r.end&&r.end()}}function Xs(t){!function(t){for(let e=0;e<t.components.length;e++){const n=t.components[e],r=wn(n),s=r[1];Es(s,r,s.template,n)}}(t[8])}function Ys(t,e,n){Un(0),e(t,n)}const Zs=(()=>Promise.resolve(null))();function Js(t){return t[7]||(t[7]=[])}function Qs(t,e){const n=t[9],r=n?n.get(Ur,null):null;r&&r.handleError(e)}function ti(t,e,n,r,s){for(let i=0;i<n.length;){const o=n[i++],a=n[i++],l=e[o],u=t.data[o];null!==u.setInput?u.setInput(l,s,r,a):l[a]=s}}function ei(t,e){const n=e[3];return-1===t.index?tn(n)?n:null:n}function ni(t,e){const n=ei(t,e);return n?fi(e[11],n[7]):null}function ri(t,e,n,r,s){if(null!=r){let i,o=!1;tn(r)?i=r:Qe(r)&&(o=!0,r=r[0]);const a=gn(r);0===t&&null!==n?null==s?di(e,n,a):hi(e,n,a,s||null):1===t&&null!==n?hi(e,n,a,s||null):2===t?function(t,e,n){const r=fi(t,e);r&&function(t,e,n,r){fn(t)?t.removeChild(e,n,r):e.removeChild(n)}(t,r,e,n)}(e,a,o):3===t&&e.destroyNode(a),null!=i&&function(t,e,n,r,s){const i=n[7];i!==gn(n)&&ri(e,t,r,i,s);for(let o=10;o<n.length;o++){const s=n[o];vi(s[1],s,t,e,r,i)}}(e,t,i,n,s)}}function si(t,e,n,r){const s=ni(t.node,e);s&&vi(t,e,e[11],n?1:2,s,r)}function ii(t,e){const n=t[9],r=n.indexOf(e);1024&e[2]&&kn(e[3],-1),n.splice(r,1)}function oi(t,e){if(t.length<=10)return;const n=10+e,r=t[n];if(r){const s=r[17];null!==s&&s!==t&&ii(s,r),e>0&&(t[n-1][4]=r[4]);const i=De(t,10+e);si(r[1],r,!1,null);const o=i[19];null!==o&&o.detachView(i[1]),r[3]=null,r[4]=null,r[2]&=-129}return r}function ai(t,e){if(!(256&e[2])){const n=e[11];fn(n)&&n.destroyNode&&vi(t,e,n,3,null,null),function(t){let e=t[13];if(!e)return ui(t[1],t);for(;e;){let n=null;if(Qe(e))n=e[13];else{const t=e[10];t&&(n=t)}if(!n){for(;e&&!e[4]&&e!==t;)Qe(e)&&ui(e[1],e),e=li(e,t);null===e&&(e=t),Qe(e)&&ui(e[1],e),n=e&&e[4]}e=n}}(e)}}function li(t,e){let n;return Qe(t)&&(n=t[6])&&2===n.type?ei(n,t):t[3]===e?null:t[3]}function ui(t,e){if(!(256&e[2])){e[2]&=-129,e[2]|=256,function(t,e){let n;if(null!=t&&null!=(n=t.destroyHooks))for(let r=0;r<n.length;r+=2){const t=e[n[r]];if(!(t instanceof ar)){const e=n[r+1];if(Array.isArray(e))for(let n=0;n<e.length;n+=2)e[n+1].call(t[e[n]]);else e.call(t)}}}(t,e),function(t,e){const n=t.cleanup;if(null!==n){const t=e[7];for(let r=0;r<n.length-1;r+=2)if("string"==typeof n[r]){const s=n[r+1],i="function"==typeof s?s(e):gn(e[s]),o=t[n[r+2]],a=n[r+3];"boolean"==typeof a?i.removeEventListener(n[r],o,a):a>=0?t[a]():t[-a].unsubscribe(),r+=2}else n[r].call(t[n[r+1]]);e[7]=null}}(t,e);const n=e[6];n&&3===n.type&&fn(e[11])&&e[11].destroy();const r=e[17];if(null!==r&&tn(e[3])){r!==e[3]&&ii(r,e);const n=e[19];null!==n&&n.detachView(t)}}}function ci(t,e,n){let r=e.parent;for(;null!=r&&(4===r.type||5===r.type);)r=(e=r).parent;if(null==r){const t=n[6];return 2===t.type?ni(t,n):n[0]}if(e&&5===e.type&&4&e.flags)return bn(e,n).parentNode;if(2&r.flags){const e=t.data,n=e[e[r.index].directiveStart].encapsulation;if(n!==ze.ShadowDom&&n!==ze.Native)return null}return bn(r,n)}function hi(t,e,n,r){fn(t)?t.insertBefore(e,n,r):e.insertBefore(n,r,!0)}function di(t,e,n){fn(t)?t.appendChild(e,n):e.appendChild(n)}function pi(t,e,n,r){null!==r?hi(t,e,n,r):di(t,e,n)}function fi(t,e){return fn(t)?t.parentNode(e):e.parentNode}function mi(t,e){if(2===t.type){const n=ei(t,e);return null===n?null:yi(n.indexOf(e,10)-10,n)}return 4===t.type||5===t.type?bn(t,e):null}function gi(t,e,n,r){const s=ci(t,r,e);if(null!=s){const t=e[11],i=mi(r.parent||e[6],e);if(Array.isArray(n))for(let e=0;e<n.length;e++)pi(t,s,n[e],i);else pi(t,s,n,i)}}function yi(t,e){const n=10+t+1;if(n<e.length){const t=e[n],r=t[1].firstChild;if(null!==r)return function t(e,n){if(null!==n){const r=n.type;if(3===r)return bn(n,e);if(0===r)return yi(-1,e[n.index]);if(4===r||5===r){const r=n.child;if(null!==r)return t(e,r);{const t=e[n.index];return tn(t)?yi(-1,t):gn(t)}}{const r=e[16],s=r[6],i=as(r),o=s.projection[n.projection];return null!=o?t(i,o):t(e,n.next)}}return null}(t,r)}return e[7]}function bi(t,e,n,r,s,i,o){for(;null!=n;){const a=r[n.index],l=n.type;o&&0===e&&(a&&Gr(gn(a),r),n.flags|=4),64!=(64&n.flags)&&(4===l||5===l?(bi(t,e,n.child,r,s,i,!1),ri(e,t,s,a,i)):1===l?xi(t,e,r,n,s,i):ri(e,t,s,a,i)),n=o?n.projectionNext:n.next}}function vi(t,e,n,r,s,i){bi(n,r,t.node.child,e,s,i,!1)}function xi(t,e,n,r,s,i){const o=n[16],a=o[6].projection[r.projection];if(Array.isArray(a))for(let l=0;l<a.length;l++)ri(e,t,s,a[l],i);else bi(t,e,a,o[3],s,i,!0)}function wi(t,e,n){fn(t)?t.setAttribute(e,"style",n):e.style.cssText=n}function Ci(t,e,n){fn(t)?""===n?t.removeAttribute(e,"class"):t.setAttribute(e,"class",n):e.className=n}class Si{constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._viewContainerRef=null}get rootNodes(){const t=this._lView;return null==t[0]?function t(e,n,r,s,i=!1){for(;null!==r;){const o=n[r.index];if(null!==o&&s.push(gn(o)),tn(o))for(let e=10;e<o.length;e++){const n=o[e],r=n[1].firstChild;null!==r&&t(n[1],n,r,s)}const a=r.type;if(4===a||5===a)t(e,n,r.child,s);else if(1===a){const e=n[16],i=e[6].projection[r.projection];if(Array.isArray(i))s.push(...i);else{const n=as(e);t(n[1],n,i,s,!0)}}r=i?r.projectionNext:r.next}return s}(t[1],t,t[6].child,[]):[]}get context(){return this._lView[8]}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._viewContainerRef){const t=this._viewContainerRef.indexOf(this);t>-1&&this._viewContainerRef.detach(t),this._viewContainerRef=null}ai(this._lView[1],this._lView)}onDestroy(t){Ns(this._lView[1],this._lView,null,t)}markForCheck(){Gs(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){Ks(this._lView[1],this._lView,this.context)}checkNoChanges(){!function(t,e,n){Mn(!0);try{Ks(t,e,n)}finally{Mn(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(t){if(this._appRef)throw new Error("This view is already attached directly to the ApplicationRef!");this._viewContainerRef=t}detachFromAppRef(){var t;this._appRef=null,vi(this._lView[1],t=this._lView,t[11],2,null,null)}attachToAppRef(t){if(this._viewContainerRef)throw new Error("This view is already attached to a ViewContainer!");this._appRef=t}}class _i extends Si{constructor(t){super(t),this._view=t}detectChanges(){Xs(this._view)}checkNoChanges(){!function(t){Mn(!0);try{Xs(t)}finally{Mn(!1)}}(this._view)}get context(){return null}}let Ei,ki,Ai;function Ii(t,e,n){return Ei||(Ei=class extends t{}),new Ei(bn(e,n))}function Ni(t,e,n,r){return ki||(ki=class extends t{constructor(t,e,n){super(),this._declarationView=t,this._declarationTContainer=e,this.elementRef=n}createEmbeddedView(t){const e=this._declarationTContainer.tViews,n=ws(this._declarationView,e,t,16,null,e.node);n[17]=this._declarationView[this._declarationTContainer.index];const r=this._declarationView[19];return null!==r&&(n[19]=r.createEmbeddedView(e)),Ss(e,n,t),new Si(n)}}),0===n.type?new ki(r,n,Ii(e,n,r)):null}function Ti(t,e,n,r){let s;Ai||(Ai=class extends t{constructor(t,e,n){super(),this._lContainer=t,this._hostTNode=e,this._hostView=n}get element(){return Ii(e,this._hostTNode,this._hostView)}get injector(){return new Mr(this._hostTNode,this._hostView)}get parentInjector(){const t=Ar(this._hostTNode,this._hostView),e=gr(t,this._hostView),n=function(t,e,n){if(n.parent&&-1!==n.parent.injectorIndex){const t=n.parent.injectorIndex;let e=n.parent;for(;null!=e.parent&&t==e.parent.injectorIndex;)e=e.parent;return e}let r=mr(t),s=e,i=e[6];for(;r>1;)s=s[15],i=s[6],r--;return i}(t,this._hostView,this._hostTNode);return pr(t)&&null!=n?new Mr(n,e):new Mr(null,this._hostView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){return null!==this._lContainer[8]&&this._lContainer[8][t]||null}get length(){return this._lContainer.length-10}createEmbeddedView(t,e,n){const r=t.createEmbeddedView(e||{});return this.insert(r,n),r}createComponent(t,e,n,r,s){const i=n||this.parentInjector;if(!s&&null==t.ngModule&&i){const t=i.get(Ne,null);t&&(s=t)}const o=t.create(i,r,void 0,s);return this.insert(o.hostView,e),o}insert(t,e){const n=t._lView,r=n[1];if(t.destroyed)throw new Error("Cannot insert a destroyed View in a ViewContainer!");if(this.allocateContainerIfNeeded(),tn(n[3])){const e=this.indexOf(t);if(-1!==e)this.detach(e);else{const e=n[3],r=new Ai(e,e[6],e[3]);r.detach(r.indexOf(t))}}const s=this._adjustIndex(e);return function(t,e,n,r){const s=10+r,i=n.length;r>0&&(n[s-1][4]=e),r<i-10?(e[4]=n[s],$e(n,10+r,e)):(n.push(e),e[4]=null),e[3]=n;const o=e[17];null!==o&&n!==o&&function(t,e){const n=t[9];e[16]!==e[3][3][16]&&(t[2]=!0),null===n?t[9]=[e]:n.push(e)}(o,e);const a=e[19];null!==a&&a.insertView(t),e[2]|=128}(r,n,this._lContainer,s),si(r,n,!0,yi(s,this._lContainer)),t.attachToViewContainerRef(this),$e(this._lContainer[8],s,t),t}move(t,e){if(t.destroyed)throw new Error("Cannot move a destroyed View in a ViewContainer!");return this.insert(t,e)}indexOf(t){const e=this._lContainer[8];return null!==e?e.indexOf(t):-1}remove(t){this.allocateContainerIfNeeded();const e=this._adjustIndex(t,-1);!function(t,e){const n=oi(t,e);n&&ai(n[1],n)}(this._lContainer,e),De(this._lContainer[8],e)}detach(t){this.allocateContainerIfNeeded();const e=this._adjustIndex(t,-1),n=oi(this._lContainer,e);return n&&null!=De(this._lContainer[8],e)?new Si(n):null}_adjustIndex(t,e=0){return null==t?this.length+e:t}allocateContainerIfNeeded(){null===this._lContainer[8]&&(this._lContainer[8]=[])}});const i=r[n.index];if(tn(i))s=i;else{let t;if(4===n.type)t=gn(i);else if(t=r[11].createComment(""),on(r)){const e=r[11],s=bn(n,r);hi(e,fi(e,s),t,function(t,e){return fn(t)?t.nextSibling(e):e.nextSibling}(e,s))}else gi(r[1],r,t,n);r[n.index]=s=new Array(i,!0,!1,r,null,0,n,t,null,null),qs(r,s)}return new Ai(s,n,r)}let Ri=(()=>{class t{}return t.__NG_ELEMENT_ID__=()=>$i(),t})();const $i=function(t=!1){return function(t,e,n){if(!n&&nn(t)){const n=xn(t.index,e);return new Si(n,n)}return 3===t.type||0===t.type||4===t.type||5===t.type?new Si(e[16],e):null}(Rn(),Nn(),t)},Di=Function,Oi=new me("Set Injector scope."),Fi={},Mi={},Li=[];let Pi=void 0;function zi(){return void 0===Pi&&(Pi=new Ie),Pi}function Bi(t,e=null,n=null,r){return new Vi(t,n,e||zi(),r)}class Vi{constructor(t,e,n,r=null){this.parent=n,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const s=[];e&&Re(e,n=>this.processProvider(n,t,e)),Re([t],t=>this.processInjectorType(t,[],s)),this.records.set(ge,ji(void 0,this));const i=this.records.get(Oi);this.scope=null!=i?i.value:null,this.source=r||("object"==typeof t?null:Zt(t))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(t=>t.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(t,e=ye,n=Pt.Default){this.assertNotDestroyed();const r=Ce(this);try{if(!(n&Pt.SkipSelf)){let e=this.records.get(t);if(void 0===e){const n=("function"==typeof(s=t)||"object"==typeof s&&s instanceof me)&&Wt(t);e=n&&this.injectableDefInScope(n)?ji(Ui(t),Fi):null,this.records.set(t,e)}if(null!=e)return this.hydrate(t,e)}return(n&Pt.Self?zi():this.parent).get(t,e=n&Pt.Optional&&e===ye?null:e)}catch(i){if("NullInjectorError"===i.name){if((i.ngTempTokenPath=i.ngTempTokenPath||[]).unshift(Zt(t)),r)throw i;return function(t,e,n,r){const s=t.ngTempTokenPath;throw e.__source&&s.unshift(e.__source),t.message=function(t,e,n,r=null){t=t&&"\n"===t.charAt(0)&&"\u0275"==t.charAt(1)?t.substr(2):t;let s=Zt(e);if(Array.isArray(e))s=e.map(Zt).join(" -> ");else if("object"==typeof e){let t=[];for(let n in e)if(e.hasOwnProperty(n)){let r=e[n];t.push(n+":"+("string"==typeof r?JSON.stringify(r):Zt(r)))}s=`{${t.join(", ")}}`}return`${n}${r?"("+r+")":""}[${s}]: ${t.replace(be,"\n  ")}`}("\n"+t.message,s,n,r),t.ngTokenPath=s,t.ngTempTokenPath=null,t}(i,t,"R3InjectorError",this.source)}throw i}finally{Ce(r)}var s}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(t=>this.get(t))}toString(){const t=[];return this.records.forEach((e,n)=>t.push(Zt(n))),`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Error("Injector has already been destroyed.")}processInjectorType(t,e,n){if(!(t=ee(t)))return!1;let r=Ht(t);const s=null==r&&t.ngModule||void 0,i=void 0===s?t:s,o=-1!==n.indexOf(i);if(void 0!==s&&(r=Ht(s)),null==r)return!1;if(null!=r.imports&&!o){let t;n.push(i);try{Re(r.imports,r=>{this.processInjectorType(r,e,n)&&(void 0===t&&(t=[]),t.push(r))})}finally{}if(void 0!==t)for(let e=0;e<t.length;e++){const{ngModule:n,providers:r}=t[e];Re(r,t=>this.processProvider(t,n,r||Li))}}this.injectorDefTypes.add(i),this.records.set(i,ji(r.factory,Fi));const a=r.providers;if(null!=a&&!o){const e=t;Re(a,t=>this.processProvider(t,e,a))}return void 0!==s&&void 0!==t.providers}processProvider(t,e,n){let r=qi(t=ee(t))?t:ee(t&&t.provide);const s=function(t,e,n){return Hi(t)?ji(void 0,t.useValue):ji(Wi(t,e,n),Fi)}(t,e,n);if(qi(t)||!0!==t.multi){const t=this.records.get(r);t&&void 0!==t.multi&&Xr()}else{let e=this.records.get(r);e?void 0===e.multi&&Xr():(e=ji(void 0,Fi,!0),e.factory=()=>Ae(e.multi),this.records.set(r,e)),r=t,e.multi.push(t)}this.records.set(r,s)}hydrate(t,e){var n;return e.value===Mi?function(t){throw new Error("Cannot instantiate cyclic dependency! "+t)}(Zt(t)):e.value===Fi&&(e.value=Mi,e.value=e.factory()),"object"==typeof e.value&&e.value&&null!==(n=e.value)&&"object"==typeof n&&"function"==typeof n.ngOnDestroy&&this.onDestroy.add(e.value),e.value}injectableDefInScope(t){return!!t.providedIn&&("string"==typeof t.providedIn?"any"===t.providedIn||t.providedIn===this.scope:this.injectorDefTypes.has(t.providedIn))}}function Ui(t){const e=Wt(t),n=null!==e?e.factory:Ze(t);if(null!==n)return n;const r=Ht(t);if(null!==r)return r.factory;if(t instanceof me)throw new Error(`Token ${Zt(t)} is missing a \u0275prov definition.`);if(t instanceof Function)return function(t){const e=t.length;if(e>0){const n=Oe(e,"?");throw new Error(`Can't resolve all parameters for ${Zt(t)}: (${n.join(", ")}).`)}const n=function(t){const e=t&&(t[qt]||t[Xt]||t[Kt]&&t[Kt]());if(e){const n=function(t){if(t.hasOwnProperty("name"))return t.name;const e=(""+t).match(/^function\s*([^\s(]+)/);return null===e?"":e[1]}(t);return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`),e}return null}(t);return null!==n?()=>n.factory(t):()=>new t}(t);throw new Error("unreachable")}function Wi(t,e,n){let r=void 0;if(qi(t)){const e=ee(t);return Ze(e)||Ui(e)}if(Hi(t))r=()=>ee(t.useValue);else if((s=t)&&s.useFactory)r=()=>t.useFactory(...Ae(t.deps||[]));else if(function(t){return!(!t||!t.useExisting)}(t))r=()=>Ee(ee(t.useExisting));else{const s=ee(t&&(t.useClass||t.provide));if(s||function(t,e,n){let r="";throw t&&e&&(r=` - only instances of Provider and Type are allowed, got: [${e.map(t=>t==n?"?"+n+"?":"...").join(", ")}]`),new Error(`Invalid provider for the NgModule '${Zt(t)}'`+r)}(e,n,t),!function(t){return!!t.deps}(t))return Ze(s)||Ui(s);r=()=>new s(...Ae(t.deps))}var s;return r}function ji(t,e,n=!1){return{factory:t,value:e,multi:n?[]:void 0}}function Hi(t){return null!==t&&"object"==typeof t&&ve in t}function qi(t){return"function"==typeof t}const Gi=function(t,e,n){return function(t,e=null,n=null,r){const s=Bi(t,e,n,r);return s._resolveInjectorDefTypes(),s}({name:n},e,t,n)};let Ki=(()=>{class t{static create(t,e){return Array.isArray(t)?Gi(t,e,""):Gi(t.providers,t.parent,t.name||"")}}return t.THROW_IF_NOT_FOUND=ye,t.NULL=new Ie,t.\u0275prov=Vt({token:t,providedIn:"any",factory:()=>Ee(ge)}),t.__NG_ELEMENT_ID__=-1,t})();const Xi=new me("AnalyzeForEntryComponents");function Yi(t,e,n){let r=n?t.styles:null,s=n?t.classes:null,i=0;if(null!==e)for(let o=0;o<e.length;o++){const t=e[o];"number"==typeof t?i=t:1==i?s=Jt(s,t):2==i&&(r=Jt(r,t+": "+e[++o]+";"))}n?t.styles=r:t.stylesWithoutHost=r,n?t.classes=s:t.classesWithoutHost=s}let Zi=null;function Ji(){if(!Zi){const t=ae.Symbol;if(t&&t.iterator)Zi=t.iterator;else{const t=Object.getOwnPropertyNames(Map.prototype);for(let e=0;e<t.length;++e){const n=t[e];"entries"!==n&&"size"!==n&&Map.prototype[n]===Map.prototype.entries&&(Zi=n)}}}return Zi}function Qi(t){return!!to(t)&&(Array.isArray(t)||!(t instanceof Map)&&Ji()in t)}function to(t){return null!==t&&("function"==typeof t||"object"==typeof t)}function eo(t,e,n){return!Object.is(t[e],n)&&(t[e]=n,!0)}function no(t,e,n,r){const s=Nn();return eo(s,Ln(),e)&&(Tn(),function(t,e,n,r,s,i){const o=bn(t,e),a=e[11];if(null==r)fn(a)?a.removeAttribute(o,n,i):o.removeAttribute(n);else{const e=null==s?yr(r):s(r,t.tagName||"",n);fn(a)?a.setAttribute(o,n,e,i):i?o.setAttributeNS(i,n,e):o.setAttribute(n,e)}}(Jn(),s,t,e,n,r)),no}function ro(t,e=Pt.Default){const n=Nn();return null==n?Ee(t,e):Nr(Rn(),n,ee(t),e)}function so(t,e,n){const r=Nn();return eo(r,Ln(),e)&&$s(Tn(),Jn(),r,t,e,r[11],n,!1),so}function io(t,e,n,r,s){const i=s?"class":"style";ti(t,n,e.inputs[i],i,r)}function oo(t,e,n,r){const s=Nn(),i=Tn(),o=20+t,a=s[11],l=s[o]=xs(e,a,An.lFrame.currentNamespace),u=i.firstCreatePass?function(t,e,n,r,s,i,o){const a=e.consts,l=_n(a,i),u=Cs(e,n[6],t,3,s,l);return function(t,e,n,r){let s=!1;if(In()){const i=function(t,e,n){const r=t.directiveRegistry;let s=null;if(r)for(let i=0;i<r.length;i++){const o=r[i];rs(n,o.selectors,!1)&&(s||(s=[]),Ir(_r(n,e),t,o.type),sn(o)?(2&n.flags&&Kr(n),Ls(t,n),s.unshift(o)):s.push(o))}return s}(t,e,n),o=null===r?null:{"":-1};if(null!==i){let r=0;s=!0,zs(n,t.data.length,i.length);for(let t=0;t<i.length;t++){const e=i[t];e.providersResolver&&e.providersResolver(e)}Ms(t,n,i.length);let a=!1,l=!1;for(let s=0;s<i.length;s++){const u=i[s];n.mergedAttrs=hr(n.mergedAttrs,u.hostAttrs),Bs(t,e,u),Ps(t.data.length-1,u,o),null!==u.contentQueries&&(n.flags|=8),null===u.hostBindings&&null===u.hostAttrs&&0===u.hostVars||(n.flags|=128);const c=u.type.prototype;!a&&(c.ngOnChanges||c.ngOnInit||c.ngDoCheck)&&((t.preOrderHooks||(t.preOrderHooks=[])).push(n.index-20),a=!0),l||!c.ngOnChanges&&!c.ngDoCheck||((t.preOrderCheckHooks||(t.preOrderCheckHooks=[])).push(n.index-20),l=!0),Ds(t,u),r+=u.hostVars}!function(t,e){const n=e.directiveEnd,r=t.data,s=e.attrs,i=[];let o=null,a=null;for(let l=e.directiveStart;l<n;l++){const t=r[l],n=t.inputs,u=null===s||Jr(e)?null:Ws(n,s);i.push(u),o=Rs(n,l,o),a=Rs(t.outputs,l,a)}null!==o&&(o.hasOwnProperty("class")&&(e.flags|=16),o.hasOwnProperty("style")&&(e.flags|=32)),e.initialInputs=i,e.inputs=o,e.outputs=a}(t,n),Os(t,e,r)}o&&function(t,e,n){if(e){const r=t.localNames=[];for(let t=0;t<e.length;t+=2){const s=n[e[t+1]];if(null==s)throw new Error(`Export of name '${e[t+1]}' not found!`);r.push(e[t],s)}}}(n,r,o)}n.mergedAttrs=hr(n.mergedAttrs,n.attrs)}(e,n,u,_n(a,o)),null!==u.attrs&&Yi(u,u.attrs,!1),null!==u.mergedAttrs&&Yi(u,u.mergedAttrs,!0),null!==e.queries&&e.queries.elementStart(e,u),u}(t,i,s,0,e,n,r):i.data[o];$n(u,!0);const c=u.mergedAttrs;null!==c&&lr(a,l,c);const h=u.classes;null!==h&&Ci(a,l,h);const d=u.styles;null!==d&&wi(a,l,d),gi(i,s,l,u),0===An.lFrame.elementDepthCount&&Gr(l,s),An.lFrame.elementDepthCount++,rn(u)&&(function(t,e,n){In()&&(function(t,e,n,r){const s=n.directiveStart,i=n.directiveEnd;t.firstCreatePass||_r(n,e),Gr(r,e);const o=n.initialInputs;for(let a=s;a<i;a++){const r=t.data[a],i=sn(r);i&&Vs(e,n,r);const l=Dr(e,t,a,n);Gr(l,e),null!==o&&Us(0,a-s,l,r,0,o),i&&(xn(n.index,e)[8]=l)}}(t,e,n,bn(n,e)),128==(128&n.flags)&&function(t,e,n){const r=n.directiveStart,s=n.directiveEnd,i=t.expandoInstructions,o=t.firstCreatePass,a=n.index-20,l=An.lFrame.currentDirectiveIndex;try{Zn(a);for(let n=r;n<s;n++){const r=t.data[n],s=e[n];Bn(n),null!==r.hostBindings||0!==r.hostVars||null!==r.hostAttrs?Fs(r,s):o&&i.push(null)}}finally{Zn(-1),Bn(l)}}(t,e,n))}(i,s,u),function(t,e,n){if(en(e)){const r=e.directiveEnd;for(let s=e.directiveStart;s<r;s++){const e=t.data[s];e.contentQueries&&e.contentQueries(1,n[s],s)}}}(i,u,s)),null!==r&&function(t,e,n=bn){const r=e.localNames;if(null!==r){let s=e.index+1;for(let i=0;i<r.length;i+=2){const o=r[i+1],a=-1===o?n(e,t):t[o];t[s++]=a}}}(s,u)}function ao(){let t=Rn();Dn()?On():(t=t.parent,$n(t,!1));const e=t;An.lFrame.elementDepthCount--;const n=Tn();n.firstCreatePass&&(er(n,t),en(t)&&n.queries.elementEnd(t)),null!=e.classesWithoutHost&&function(t){return 0!=(16&t.flags)}(e)&&io(n,e,Nn(),e.classesWithoutHost,!0),null!=e.stylesWithoutHost&&function(t){return 0!=(32&t.flags)}(e)&&io(n,e,Nn(),e.stylesWithoutHost,!1)}function lo(t,e,n,r){oo(t,e,n,r),ao()}function uo(t){return!!t&&"function"==typeof t.then}function co(t){return!!t&&"function"==typeof t.subscribe}function ho(t,e,n=!1,r){const s=Nn(),i=Tn(),o=Rn();return function(t,e,n,r,s,i,o=!1,a){const l=rn(r),u=t.firstCreatePass&&(t.cleanup||(t.cleanup=[])),c=Js(e);let h=!0;if(3===r.type){const d=bn(r,e),p=a?a(d):Be,f=p.target||d,m=c.length,g=a?t=>a(gn(t[r.index])).target:r.index;if(fn(n)){let o=null;if(!a&&l&&(o=function(t,e,n,r){const s=t.cleanup;if(null!=s)for(let i=0;i<s.length-1;i+=2){const t=s[i];if(t===n&&s[i+1]===r){const t=e[7],n=s[i+2];return t.length>n?t[n]:null}"string"==typeof t&&(i+=2)}return null}(t,e,s,r.index)),null!==o)(o.__ngLastListenerFn__||o).__ngNextListenerFn__=i,o.__ngLastListenerFn__=i,h=!1;else{i=fo(r,e,i,!1);const t=n.listen(p.name||f,s,i);c.push(i,t),u&&u.push(s,g,m,m+1)}}else i=fo(r,e,i,!0),f.addEventListener(s,i,o),c.push(i),u&&u.push(s,g,m,o)}const d=r.outputs;let p;if(h&&null!==d&&(p=d[s])){const t=p.length;if(t)for(let n=0;n<t;n+=2){const t=e[p[n]][p[n+1]].subscribe(i),o=c.length;c.push(i,t),u&&u.push(s,r.index,o,-(o+1))}}}(i,s,s[11],o,t,e,n,r),ho}function po(t,e,n){try{return!1!==e(n)}catch(r){return Qs(t,r),!1}}function fo(t,e,n,r){return function s(i){if(i===Function)return n;const o=2&t.flags?xn(t.index,e):e;0==(32&e[2])&&Gs(o);let a=po(e,n,i),l=s.__ngNextListenerFn__;for(;l;)a=po(e,l,i)&&a,l=l.__ngNextListenerFn__;return r&&!1===a&&(i.preventDefault(),i.returnValue=!1),a}}const mo=[];function go(t,e,n,r,s){const i=t[n+1],o=null===e;let a=r?fs(i):gs(i),l=!1;for(;0!==a&&(!1===l||o);){const n=t[a+1];yo(t[a],e)&&(l=!0,t[a+1]=r?bs(n):ms(n)),a=r?fs(n):gs(n)}l&&(t[n+1]=r?ms(i):bs(i))}function yo(t,e){return null===t||null==e||(Array.isArray(t)?t[1]:t)===e||!(!Array.isArray(t)||"string"!=typeof e)&&Le(t,e)>=0}const bo={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function vo(t){return t.substring(bo.key,bo.keyEnd)}function xo(t,e){const n=bo.textEnd;return n===e?-1:(e=bo.keyEnd=function(t,e,n){for(;e<n&&t.charCodeAt(e)>32;)e++;return e}(t,bo.key=e,n),wo(t,e,n))}function wo(t,e,n){for(;e<n&&t.charCodeAt(e)<=32;)e++;return e}function Co(t,e){return function(t,e,n,r){const s=Nn(),i=Tn(),o=Pn(2);i.firstUpdatePass&&ko(i,t,o,!0),e!==os&&eo(s,o,e)&&No(i,i.data[Yn()+20],s,s[11],t,s[o+1]=function(t,e){return null==t||"object"==typeof t&&(t=Zt(Wr(t))),t}(e),!0,o)}(t,e),Co}function So(t){!function(t,e,n,r){const s=Tn(),i=Pn(2);s.firstUpdatePass&&ko(s,null,i,!0);const o=Nn();if(n!==os&&eo(o,i,n)){const r=s.data[Yn()+20];if($o(r,!0)&&!Eo(s,i)){let t=r.classesWithoutHost;null!==t&&(n=Jt(t,n||"")),io(s,r,o,n,!0)}else!function(t,e,n,r,s,i,o,a){s===os&&(s=mo);let l=0,u=0,c=0<s.length?s[0]:null,h=0<i.length?i[0]:null;for(;null!==c||null!==h;){const o=l<s.length?s[l+1]:void 0,d=u<i.length?i[u+1]:void 0;let p=null,f=void 0;c===h?(l+=2,u+=2,o!==d&&(p=h,f=d)):null===h||null!==c&&c<h?(l+=2,p=c):(u+=2,p=h,f=d),null!==p&&No(t,e,n,r,p,f,!0,a),c=l<s.length?s[l]:null,h=u<i.length?i[u]:null}}(s,r,o,o[11],o[i+1],o[i+1]=function(t,e,n){if(null==n||""===n)return mo;const r=[],s=Wr(n);if(Array.isArray(s))for(let i=0;i<s.length;i++)t(r,s[i],!0);else if("object"==typeof s)for(const i in s)s.hasOwnProperty(i)&&t(r,i,s[i]);else"string"==typeof s&&e(r,s);return r}(t,e,n),0,i)}}(Fe,_o,t)}function _o(t,e){for(let n=function(t){return function(t){bo.key=0,bo.keyEnd=0,bo.value=0,bo.valueEnd=0,bo.textEnd=t.length}(t),xo(t,wo(t,0,bo.textEnd))}(e);n>=0;n=xo(e,n))Fe(t,vo(e),!0)}function Eo(t,e){return e>=t.expandoStartIndex}function ko(t,e,n,r){const s=t.data;if(null===s[n+1]){const i=s[Yn()+20],o=Eo(t,n);$o(i,r)&&null===e&&!o&&(e=!1),e=function(t,e,n,r){const s=function(t){const e=An.lFrame.currentDirectiveIndex;return-1===e?null:t[e]}(t);let i=r?e.residualClasses:e.residualStyles;if(null===s)0===(r?e.classBindings:e.styleBindings)&&(n=Io(n=Ao(null,t,e,n,r),e.attrs,r),i=null);else{const o=e.directiveStylingLast;if(-1===o||t[o]!==s)if(n=Ao(s,t,e,n,r),null===i){let n=function(t,e,n){const r=n?e.classBindings:e.styleBindings;if(0!==gs(r))return t[fs(r)]}(t,e,r);void 0!==n&&Array.isArray(n)&&(n=Ao(null,t,e,n[1],r),n=Io(n,e.attrs,r),function(t,e,n,r){t[fs(n?e.classBindings:e.styleBindings)]=r}(t,e,r,n))}else i=function(t,e,n){let r=void 0;const s=e.directiveEnd;for(let i=1+e.directiveStylingLast;i<s;i++)r=Io(r,t[i].hostAttrs,n);return Io(r,e.attrs,n)}(t,e,r)}return void 0!==i&&(r?e.residualClasses=i:e.residualStyles=i),n}(s,i,e,r),function(t,e,n,r,s,i){let o=i?e.classBindings:e.styleBindings,a=fs(o),l=gs(o);t[r]=n;let u,c=!1;if(Array.isArray(n)){const t=n;u=t[1],(null===u||Le(t,u)>0)&&(c=!0)}else u=n;if(s)if(0!==l){const e=fs(t[a+1]);t[r+1]=ps(e,a),0!==e&&(t[e+1]=ys(t[e+1],r)),t[a+1]=131071&t[a+1]|r<<17}else t[r+1]=ps(a,0),0!==a&&(t[a+1]=ys(t[a+1],r)),a=r;else t[r+1]=ps(l,0),0===a?a=r:t[l+1]=ys(t[l+1],r),l=r;c&&(t[r+1]=ms(t[r+1])),go(t,u,r,!0),go(t,u,r,!1),function(t,e,n,r,s){const i=s?t.residualClasses:t.residualStyles;null!=i&&"string"==typeof e&&Le(i,e)>=0&&(n[r+1]=bs(n[r+1]))}(e,u,t,r,i),o=ps(a,l),i?e.classBindings=o:e.styleBindings=o}(s,i,e,n,o,r)}}function Ao(t,e,n,r,s){let i=null;const o=n.directiveEnd;let a=n.directiveStylingLast;for(-1===a?a=n.directiveStart:a++;a<o&&(i=e[a],r=Io(r,i.hostAttrs,s),i!==t);)a++;return null!==t&&(n.directiveStylingLast=a),r}function Io(t,e,n){const r=n?1:2;let s=-1;if(null!==e)for(let i=0;i<e.length;i++){const o=e[i];"number"==typeof o?s=o:s===r&&(Array.isArray(t)||(t=void 0===t?[]:["",t]),Fe(t,o,!!n||e[++i]))}return void 0===t?null:t}function No(t,e,n,r,s,i,o,a){if(3!==e.type)return;const l=t.data,u=l[a+1];Ro(1==(1&u)?To(l,e,n,s,gs(u),o):void 0)||(Ro(i)||function(t){return 2==(2&t)}(u)&&(i=To(l,null,n,s,a,o)),function(t,e,n,r,s){const i=fn(t);if(e)s?i?t.addClass(n,r):n.classList.add(r):i?t.removeClass(n,r):n.classList.remove(r);else{const e=-1==r.indexOf("-")?void 0:2;null==s?i?t.removeStyle(n,r,e):n.style.removeProperty(r):i?t.setStyle(n,r,s,e):n.style.setProperty(r,s)}}(r,o,yn(Yn(),n),s,i))}function To(t,e,n,r,s,i){const o=null===e;let a=void 0;for(;s>0;){const e=t[s],i=Array.isArray(e),l=i?e[1]:e,u=null===l;let c=n[s+1];c===os&&(c=u?mo:void 0);let h=u?Me(c,r):l===r?c:void 0;if(i&&!Ro(h)&&(h=Me(e,r)),Ro(h)&&(a=h,o))return a;const d=t[s+1];s=o?fs(d):gs(d)}if(null!==e){let t=i?e.residualClasses:e.residualStyles;null!=t&&(a=Me(t,r))}return a}function Ro(t){return void 0!==t}function $o(t,e){return 0!=(t.flags&(e?16:32))}function Do(t,e=""){const n=Nn(),r=Tn(),s=t+20,i=r.firstCreatePass?Cs(r,n[6],t,3,null,null):r.data[s],o=n[s]=function(t,e){return fn(e)?e.createText(t):e.createTextNode(t)}(e,n[11]);gi(r,n,o,i),$n(i,!1)}function Oo(t,e,n){const r=Nn(),s=function(t,e,n,r){return eo(t,Ln(),n)?e+yr(n)+r:os}(r,t,e,n);return s!==os&&function(t,e,n){const r=yn(e,t),s=t[11];fn(s)?s.setValue(r,n):r.textContent=n}(r,Yn(),s),Oo}function Fo(t,e,n){const r=Nn();return eo(r,Ln(),e)&&$s(Tn(),Jn(),r,t,e,r[11],n,!0),Fo}function Mo(t,e){const n=wn(t)[1],r=n.data.length-1;er(n,{directiveStart:r,directiveEnd:r+1})}function Lo(t){let e=Object.getPrototypeOf(t.type.prototype).constructor,n=!0;const r=[t];for(;e;){let s=void 0;if(sn(t))s=e.\u0275cmp||e.\u0275dir;else{if(e.\u0275cmp)throw new Error("Directives cannot inherit Components");s=e.\u0275dir}if(s){if(n){r.push(s);const e=t;e.inputs=Po(t.inputs),e.declaredInputs=Po(t.declaredInputs),e.outputs=Po(t.outputs);const n=s.hostBindings;n&&Vo(t,n);const i=s.viewQuery,o=s.contentQueries;if(i&&zo(t,i),o&&Bo(t,o),Bt(t.inputs,s.inputs),Bt(t.declaredInputs,s.declaredInputs),Bt(t.outputs,s.outputs),sn(s)&&s.data.animation){const e=t.data;e.animation=(e.animation||[]).concat(s.data.animation)}}const e=s.features;if(e)for(let r=0;r<e.length;r++){const s=e[r];s&&s.ngInherit&&s(t),s===Lo&&(n=!1)}}e=Object.getPrototypeOf(e)}!function(t){let e=0,n=null;for(let r=t.length-1;r>=0;r--){const s=t[r];s.hostVars=e+=s.hostVars,s.hostAttrs=hr(s.hostAttrs,n=hr(n,s.hostAttrs))}}(r)}function Po(t){return t===Be?{}:t===Ve?[]:t}function zo(t,e){const n=t.viewQuery;t.viewQuery=n?(t,r)=>{e(t,r),n(t,r)}:e}function Bo(t,e){const n=t.contentQueries;t.contentQueries=n?(t,r,s)=>{e(t,r,s),n(t,r,s)}:e}function Vo(t,e){const n=t.hostBindings;t.hostBindings=n?(t,r)=>{e(t,r),n(t,r)}:e}function Uo(t,e,n,r,s){if(t=ee(t),Array.isArray(t))for(let i=0;i<t.length;i++)Uo(t[i],e,n,r,s);else{const i=Tn(),o=Nn();let a=qi(t)?t:ee(t.provide),l=Wi(t);const u=Rn(),c=1048575&u.providerIndexes,h=u.directiveStart,d=u.providerIndexes>>20;if(qi(t)||!t.multi){const r=new ar(l,s,ro),p=Ho(a,e,s?c:c+d,h);-1===p?(Ir(_r(u,o),i,a),Wo(i,t,e.length),e.push(a),u.directiveStart++,u.directiveEnd++,s&&(u.providerIndexes+=1048576),n.push(r),o.push(r)):(n[p]=r,o[p]=r)}else{const p=Ho(a,e,c+d,h),f=Ho(a,e,c,c+d),m=p>=0&&n[p],g=f>=0&&n[f];if(s&&!g||!s&&!m){Ir(_r(u,o),i,a);const c=function(t,e,n,r,s){const i=new ar(t,n,ro);return i.multi=[],i.index=e,i.componentProviders=0,jo(i,s,r&&!n),i}(s?Go:qo,n.length,s,r,l);!s&&g&&(n[f].providerFactory=c),Wo(i,t,e.length,0),e.push(a),u.directiveStart++,u.directiveEnd++,s&&(u.providerIndexes+=1048576),n.push(c),o.push(c)}else Wo(i,t,p>-1?p:f,jo(n[s?f:p],l,!s&&r));!s&&r&&g&&n[f].componentProviders++}}}function Wo(t,e,n,r){const s=qi(e);if(s||e.useClass){const i=(e.useClass||e).prototype.ngOnDestroy;if(i){const o=t.destroyHooks||(t.destroyHooks=[]);if(!s&&e.multi){const t=o.indexOf(n);-1===t?o.push(n,[r,i]):o[t+1].push(r,i)}else o.push(n,i)}}}function jo(t,e,n){return n&&t.componentProviders++,t.multi.push(e)-1}function Ho(t,e,n,r){for(let s=n;s<r;s++)if(e[s]===t)return s;return-1}function qo(t,e,n,r){return Ko(this.multi,[])}function Go(t,e,n,r){const s=this.multi;let i;if(this.providerFactory){const t=this.providerFactory.componentProviders,e=Dr(n,n[1],this.providerFactory.index,r);i=e.slice(0,t),Ko(s,i);for(let n=t;n<e.length;n++)i.push(e[n])}else i=[],Ko(s,i);return i}function Ko(t,e){for(let n=0;n<t.length;n++)e.push((0,t[n])());return e}function Xo(t,e=[]){return n=>{n.providersResolver=(n,r)=>function(t,e,n){const r=Tn();if(r.firstCreatePass){const s=sn(t);Uo(n,r.data,r.blueprint,s,!0),Uo(e,r.data,r.blueprint,s,!1)}}(n,r?r(t):t,e)}}class Yo{}class Zo{resolveComponentFactory(t){throw function(t){const e=Error(`No component factory found for ${Zt(t)}. Did you add it to @NgModule.entryComponents?`);return e.ngComponent=t,e}(t)}}let Jo=(()=>{class t{}return t.NULL=new Zo,t})(),Qo=(()=>{class t{constructor(t){this.nativeElement=t}}return t.__NG_ELEMENT_ID__=()=>ta(t),t})();const ta=function(t){return Ii(t,Rn(),Nn())};class ea{}var na=function(t){return t[t.Important=1]="Important",t[t.DashCase=2]="DashCase",t}({});let ra=(()=>{class t{}return t.__NG_ELEMENT_ID__=()=>sa(),t})();const sa=function(){const t=Nn(),e=xn(Rn().index,t);return function(t){const e=t[11];if(fn(e))return e;throw new Error("Cannot inject Renderer2 when the application uses Renderer3!")}(Qe(e)?e:t)};let ia=(()=>{class t{}return t.\u0275prov=Vt({token:t,providedIn:"root",factory:()=>null}),t})();class oa{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const aa=new oa("10.0.5");class la{constructor(){}supports(t){return Qi(t)}create(t){return new ca(t)}}const ua=(t,e)=>e;class ca{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||ua}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,n=this._removalsHead,r=0,s=null;for(;e||n;){const i=!n||e&&e.currentIndex<fa(n,r,s)?e:n,o=fa(i,r,s),a=i.currentIndex;if(i===n)r--,n=n._nextRemoved;else if(e=e._next,null==i.previousIndex)r++;else{s||(s=[]);const t=o-r,e=a-r;if(t!=e){for(let n=0;n<t;n++){const r=n<s.length?s[n]:s[n]=0,i=r+n;e<=i&&i<t&&(s[n]=r+1)}s[i.previousIndex]=e-t}}o!==a&&t(i,o,a)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!Qi(t))throw new Error(`Error trying to diff '${Zt(t)}'. Only arrays and iterables are allowed`);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e,n,r,s=this._itHead,i=!1;if(Array.isArray(t)){this.length=t.length;for(let e=0;e<this.length;e++)n=t[e],r=this._trackByFn(e,n),null!==s&&Object.is(s.trackById,r)?(i&&(s=this._verifyReinsertion(s,n,r,e)),Object.is(s.item,n)||this._addIdentityChange(s,n)):(s=this._mismatch(s,n,r,e),i=!0),s=s._next}else e=0,function(t,e){if(Array.isArray(t))for(let n=0;n<t.length;n++)e(t[n]);else{const n=t[Ji()]();let r;for(;!(r=n.next()).done;)e(r.value)}}(t,t=>{r=this._trackByFn(e,t),null!==s&&Object.is(s.trackById,r)?(i&&(s=this._verifyReinsertion(s,t,r,e)),Object.is(s.item,t)||this._addIdentityChange(s,t)):(s=this._mismatch(s,t,r,e),i=!0),s=s._next,e++}),this.length=e;return this._truncate(s),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t,e;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=e)t.previousIndex=t.currentIndex,e=t._nextMoved;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,n,r){let s;return null===t?s=this._itTail:(s=t._prev,this._remove(t)),null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(n,r))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,s,r)):null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,s,r)):t=this._addAfter(new ha(e,n),s,r),t}_verifyReinsertion(t,e,n,r){let s=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null);return null!==s?t=this._reinsertAfter(s,t._prev,r):t.currentIndex!=r&&(t.currentIndex=r,this._addToMoves(t,r)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,n){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const r=t._prevRemoved,s=t._nextRemoved;return null===r?this._removalsHead=s:r._nextRemoved=s,null===s?this._removalsTail=r:s._prevRemoved=r,this._insertAfter(t,e,n),this._addToMoves(t,n),t}_moveAfter(t,e,n){return this._unlink(t),this._insertAfter(t,e,n),this._addToMoves(t,n),t}_addAfter(t,e,n){return this._insertAfter(t,e,n),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,n){const r=null===e?this._itHead:e._next;return t._next=r,t._prev=e,null===r?this._itTail=t:r._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new pa),this._linkedRecords.put(t),t.currentIndex=n,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,n=t._next;return null===e?this._itHead=n:e._next=n,null===n?this._itTail=e:n._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new pa),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class ha{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class da{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let n;for(n=this._head;null!==n;n=n._nextDup)if((null===e||e<=n.currentIndex)&&Object.is(n.trackById,t))return n;return null}remove(t){const e=t._prevDup,n=t._nextDup;return null===e?this._head=n:e._nextDup=n,null===n?this._tail=e:n._prevDup=e,null===this._head}}class pa{constructor(){this.map=new Map}put(t){const e=t.trackById;let n=this.map.get(e);n||(n=new da,this.map.set(e,n)),n.add(t)}get(t,e){const n=this.map.get(t);return n?n.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function fa(t,e,n){const r=t.previousIndex;if(null===r)return r;let s=0;return n&&r<n.length&&(s=n[r]),r+e+s}class ma{constructor(){}supports(t){return t instanceof Map||to(t)}create(){return new ga}}class ga{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(t){let e;for(e=this._mapHead;null!==e;e=e._next)t(e)}forEachPreviousItem(t){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)t(e)}forEachChangedItem(t){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}diff(t){if(t){if(!(t instanceof Map||to(t)))throw new Error(`Error trying to diff '${Zt(t)}'. Only maps and objects are allowed`)}else t=new Map;return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(t,(t,n)=>{if(e&&e.key===n)this._maybeAddToChanges(e,t),this._appendAfter=e,e=e._next;else{const r=this._getOrCreateRecordForKey(n,t);e=this._insertBeforeOrAppend(e,r)}}),e){e._prev&&(e._prev._next=null),this._removalsHead=e;for(let t=e;null!==t;t=t._nextRemoved)t===this._mapHead&&(this._mapHead=null),this._records.delete(t.key),t._nextRemoved=t._next,t.previousValue=t.currentValue,t.currentValue=null,t._prev=null,t._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,e){if(t){const n=t._prev;return e._next=t,e._prev=n,t._prev=e,n&&(n._next=e),t===this._mapHead&&(this._mapHead=e),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(t,e){if(this._records.has(t)){const n=this._records.get(t);this._maybeAddToChanges(n,e);const r=n._prev,s=n._next;return r&&(r._next=s),s&&(s._prev=r),n._next=null,n._prev=null,n}const n=new ya(t);return this._records.set(t,n),n.currentValue=e,this._addToAdditions(n),n}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;null!==t;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;null!=t;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,e){Object.is(e,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=e,this._addToChanges(t))}_addToAdditions(t){null===this._additionsHead?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){null===this._changesHead?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,e){t instanceof Map?t.forEach(e):Object.keys(t).forEach(n=>e(t[n],n))}}class ya{constructor(t){this.key=t,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}let ba=(()=>{class t{constructor(t){this.factories=t}static create(e,n){if(null!=n){const t=n.factories.slice();e=e.concat(t)}return new t(e)}static extend(e){return{provide:t,useFactory:n=>{if(!n)throw new Error("Cannot extend IterableDiffers without a parent injector");return t.create(e,n)},deps:[[t,new Lt,new Ft]]}}find(t){const e=this.factories.find(e=>e.supports(t));if(null!=e)return e;throw new Error(`Cannot find a differ supporting object '${t}' of type '${n=t,n.name||typeof n}'`);var n}}return t.\u0275prov=Vt({token:t,providedIn:"root",factory:()=>new t([new la])}),t})(),va=(()=>{class t{constructor(t){this.factories=t}static create(e,n){if(n){const t=n.factories.slice();e=e.concat(t)}return new t(e)}static extend(e){return{provide:t,useFactory:n=>{if(!n)throw new Error("Cannot extend KeyValueDiffers without a parent injector");return t.create(e,n)},deps:[[t,new Lt,new Ft]]}}find(t){const e=this.factories.find(e=>e.supports(t));if(e)return e;throw new Error(`Cannot find a differ supporting object '${t}'`)}}return t.\u0275prov=Vt({token:t,providedIn:"root",factory:()=>new t([new ma])}),t})();const xa=[new ma],wa=new ba([new la]),Ca=new va(xa);let Sa=(()=>{class t{}return t.__NG_ELEMENT_ID__=()=>_a(t,Qo),t})();const _a=function(t,e){return Ni(t,e,Rn(),Nn())};let Ea=(()=>{class t{}return t.__NG_ELEMENT_ID__=()=>ka(t,Qo),t})();const ka=function(t,e){return Ti(t,e,Rn(),Nn())},Aa={};class Ia extends Jo{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=Ye(t);return new Ra(e,this.ngModule)}}function Na(t){const e=[];for(let n in t)t.hasOwnProperty(n)&&e.push({propName:t[n],templateName:n});return e}const Ta=new me("SCHEDULER_TOKEN",{providedIn:"root",factory:()=>vr});class Ra extends Yo{constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=t.selectors.map(is).join(","),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}get inputs(){return Na(this.componentDef.inputs)}get outputs(){return Na(this.componentDef.outputs)}create(t,e,n,r){const s=(r=r||this.ngModule)?function(t,e){return{get:(n,r,s)=>{const i=t.get(n,Aa,s);return i!==Aa||r===Aa?i:e.get(n,r,s)}}}(t,r.injector):t,i=s.get(ea,mn),o=s.get(ia,null),a=i.createRenderer(null,this.componentDef),l=this.componentDef.selectors[0][0]||"div",u=n?function(t,e,n){if(fn(t))return t.selectRootElement(e,n===ze.ShadowDom);let r="string"==typeof e?t.querySelector(e):e;return r.textContent="",r}(a,n,this.componentDef.encapsulation):xs(l,i.createRenderer(null,this.componentDef),function(t){const e=t.toLowerCase();return"svg"===e?"http://www.w3.org/2000/svg":"math"===e?"http://www.w3.org/1998/MathML/":null}(l)),c=this.componentDef.onPush?576:528,h={components:[],scheduler:vr,clean:Zs,playerHandler:null,flags:0},d=Is(0,-1,null,1,0,null,null,null,null,null),p=ws(null,d,h,c,null,null,i,a,o,s);let f,m;jn(p,null);try{const t=function(t,e,n,r,s,i){const o=n[1];n[20]=t;const a=Cs(o,null,0,3,null,null),l=a.mergedAttrs=e.hostAttrs;null!==l&&(Yi(a,l,!0),null!==t&&(lr(s,t,l),null!==a.classes&&Ci(s,t,a.classes),null!==a.styles&&wi(s,t,a.styles)));const u=r.createRenderer(t,e),c=ws(n,As(e),null,e.onPush?64:16,n[20],a,r,u,void 0);return o.firstCreatePass&&(Ir(_r(a,n),o,e.type),Ls(o,a),zs(a,n.length,1)),qs(n,c),n[20]=c}(u,this.componentDef,p,i,a);if(u)if(n)lr(a,u,["ng-version",aa.full]);else{const{attrs:t,classes:e}=function(t){const e=[],n=[];let r=1,s=2;for(;r<t.length;){let i=t[r];if("string"==typeof i)2===s?""!==i&&e.push(i,t[++r]):8===s&&n.push(i);else{if(!es(s))break;s=i}r++}return{attrs:e,classes:n}}(this.componentDef.selectors[0]);t&&lr(a,u,t),e&&e.length>0&&Ci(a,u,e.join(" "))}if(m=vn(d,0),void 0!==e){const t=m.projection=[];for(let n=0;n<this.ngContentSelectors.length;n++){const r=e[n];t.push(null!=r?Array.from(r):null)}}f=function(t,e,n,r,s){const i=n[1],o=function(t,e,n){const r=Rn();t.firstCreatePass&&(n.providersResolver&&n.providersResolver(n),Ms(t,r,1),Bs(t,e,n));const s=Dr(e,t,e.length-1,r);Gr(s,e);const i=bn(r,e);return i&&Gr(i,e),s}(i,n,e);r.components.push(o),t[8]=o,s&&s.forEach(t=>t(o,e)),e.contentQueries&&e.contentQueries(1,o,n.length-1);const a=Rn();if(i.firstCreatePass&&(null!==e.hostBindings||null!==e.hostAttrs)){Zn(a.index-20);const t=n[1];Ds(t,e),Os(t,n,e.hostVars),Fs(e,o)}return o}(t,this.componentDef,p,h,[Mo]),Ss(d,p,null)}finally{Xn()}const g=new $a(this.componentType,f,Ii(Qo,m,p),p,m);return d.node.child=m,g}}class $a extends class{}{constructor(t,e,n,r,s){super(),this.location=n,this._rootLView=r,this._tNode=s,this.destroyCbs=[],this.instance=e,this.hostView=this.changeDetectorRef=new _i(r),function(t,e,n,r){let s=t.node;null==s&&(t.node=s=Ts(0,null,2,-1,null,null)),r[6]=s}(r[1],0,0,r),this.componentType=t}get injector(){return new Mr(this._tNode,this._rootLView)}destroy(){this.destroyCbs&&(this.destroyCbs.forEach(t=>t()),this.destroyCbs=null,!this.hostView.destroyed&&this.hostView.destroy())}onDestroy(t){this.destroyCbs&&this.destroyCbs.push(t)}}const Da=void 0;var Oa=["en",[["a","p"],["AM","PM"],Da],[["AM","PM"],Da,Da],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],Da,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],Da,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",Da,"{1} 'at' {0}",Da],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function(t){let e=Math.floor(Math.abs(t)),n=t.toString().replace(/^[^.]*\.?/,"").length;return 1===e&&0===n?1:5}];let Fa={};function Ma(t){return t in Fa||(Fa[t]=ae.ng&&ae.ng.common&&ae.ng.common.locales&&ae.ng.common.locales[t]),Fa[t]}var La=function(t){return t[t.LocaleId=0]="LocaleId",t[t.DayPeriodsFormat=1]="DayPeriodsFormat",t[t.DayPeriodsStandalone=2]="DayPeriodsStandalone",t[t.DaysFormat=3]="DaysFormat",t[t.DaysStandalone=4]="DaysStandalone",t[t.MonthsFormat=5]="MonthsFormat",t[t.MonthsStandalone=6]="MonthsStandalone",t[t.Eras=7]="Eras",t[t.FirstDayOfWeek=8]="FirstDayOfWeek",t[t.WeekendRange=9]="WeekendRange",t[t.DateFormat=10]="DateFormat",t[t.TimeFormat=11]="TimeFormat",t[t.DateTimeFormat=12]="DateTimeFormat",t[t.NumberSymbols=13]="NumberSymbols",t[t.NumberFormats=14]="NumberFormats",t[t.CurrencyCode=15]="CurrencyCode",t[t.CurrencySymbol=16]="CurrencySymbol",t[t.CurrencyName=17]="CurrencyName",t[t.Currencies=18]="Currencies",t[t.Directionality=19]="Directionality",t[t.PluralCase=20]="PluralCase",t[t.ExtraData=21]="ExtraData",t}({});let Pa="en-US";function za(t){var e,n;n="Expected localeId to be defined",null==(e=t)&&function(t,e,n,r){throw new Error("ASSERTION ERROR: "+t+` [Expected=> null != ${e} <=Actual]`)}(n,e),"string"==typeof t&&(Pa=t.toLowerCase().replace(/_/g,"-"))}const Ba=new Map;class Va extends Ne{constructor(t,e){super(),this._parent=e,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new Ia(this);const n=Je(t),r=t[de]||null;r&&za(r),this._bootstrapComponents=xr(n.bootstrap),this._r3Injector=Bi(t,e,[{provide:Ne,useValue:this},{provide:Jo,useValue:this.componentFactoryResolver}],Zt(t)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(t)}get(t,e=Ki.THROW_IF_NOT_FOUND,n=Pt.Default){return t===Ki||t===Ne||t===ge?this:this._r3Injector.get(t,e,n)}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(t=>t()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class Ua extends Te{constructor(t){super(),this.moduleType=t,null!==Je(t)&&function t(e){if(null!==e.\u0275mod.id){const t=e.\u0275mod.id;(function(t,e,n){if(e&&e!==n)throw new Error(`Duplicate module registered for ${t} - ${Zt(e)} vs ${Zt(e.name)}`)})(t,Ba.get(t),e),Ba.set(t,e)}let n=e.\u0275mod.imports;n instanceof Function&&(n=n()),n&&n.forEach(e=>t(e))}(t)}create(t){return new Va(this.moduleType,t)}}const Wa=class extends rt{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,n){let r,s=t=>null,i=()=>null;t&&"object"==typeof t?(r=this.__isAsync?e=>{setTimeout(()=>t.next(e))}:e=>{t.next(e)},t.error&&(s=this.__isAsync?e=>{setTimeout(()=>t.error(e))}:e=>{t.error(e)}),t.complete&&(i=this.__isAsync?()=>{setTimeout(()=>t.complete())}:()=>{t.complete()})):(r=this.__isAsync?e=>{setTimeout(()=>t(e))}:e=>{t(e)},e&&(s=this.__isAsync?t=>{setTimeout(()=>e(t))}:t=>{e(t)}),n&&(i=this.__isAsync?()=>{setTimeout(()=>n())}:()=>{n()}));const o=super.subscribe(r,s,i);return t instanceof H&&t.add(o),o}};function ja(){return this._results[Ji()]()}class Ha{constructor(){this.dirty=!0,this._results=[],this.changes=new Wa,this.length=0;const t=Ji(),e=Ha.prototype;e[t]||(e[t]=ja)}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t){this._results=function t(e,n){void 0===n&&(n=e);for(let r=0;r<e.length;r++){let s=e[r];Array.isArray(s)?(n===e&&(n=e.slice(0,r)),t(s,n)):n!==e&&n.push(s)}return n}(t),this.dirty=!1,this.length=this._results.length,this.last=this._results[this.length-1],this.first=this._results[0]}notifyOnChanges(){this.changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}class qa{constructor(t){this.queryList=t,this.matches=null}clone(){return new qa(this.queryList)}setDirty(){this.queryList.setDirty()}}class Ga{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const n=null!==t.contentQueries?t.contentQueries[0]:e.length,r=[];for(let t=0;t<n;t++){const n=e.getByIndex(t);r.push(this.queries[n.indexInDeclarationView].clone())}return new Ga(r)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==tl(t,e).matches&&this.queries[e].setDirty()}}class Ka{constructor(t,e,n,r=null){this.predicate=t,this.descendants=e,this.isStatic=n,this.read=r}}class Xa{constructor(t=[]){this.queries=t}elementStart(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let n=0;n<this.length;n++){const r=null!==e?e.length:0,s=this.getByIndex(n).embeddedTView(t,r);s&&(s.indexInDeclarationView=n,null!==e?e.push(s):e=[s])}return null!==e?new Xa(e):null}template(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class Ya{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new Ya(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&!1===this.metadata.descendants){const e=this._declarationNodeIndex;let n=t.parent;for(;null!==n&&4===n.type&&n.index!==e;)n=n.parent;return e===(null!==n?n.index:-1)}return this._appliesToNextNode}matchTNode(t,e){if(Array.isArray(this.metadata.predicate)){const n=this.metadata.predicate;for(let r=0;r<n.length;r++)this.matchTNodeWithReadOption(t,e,Za(e,n[r]))}else{const n=this.metadata.predicate;n===Sa?0===e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,$r(e,t,n,!1,!1))}}matchTNodeWithReadOption(t,e,n){if(null!==n){const r=this.metadata.read;if(null!==r)if(r===Qo||r===Ea||r===Sa&&0===e.type)this.addMatch(e.index,-2);else{const n=$r(e,t,r,!1,!1);null!==n&&this.addMatch(e.index,n)}else this.addMatch(e.index,n)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function Za(t,e){const n=t.localNames;if(null!==n)for(let r=0;r<n.length;r+=2)if(n[r]===e)return n[r+1];return null}function Ja(t,e,n,r){return-1===n?function(t,e){return 3===t.type||4===t.type?Ii(Qo,t,e):0===t.type?Ni(Sa,Qo,t,e):null}(e,t):-2===n?function(t,e,n){return n===Qo?Ii(Qo,e,t):n===Sa?Ni(Sa,Qo,e,t):n===Ea?Ti(Ea,Qo,e,t):void 0}(t,e,r):Dr(t,t[1],n,e)}function Qa(t,e,n,r){const s=e[19].queries[r];if(null===s.matches){const r=t.data,i=n.matches,o=[];for(let t=0;t<i.length;t+=2){const s=i[t];o.push(s<0?null:Ja(e,r[s],i[t+1],n.metadata.read))}s.matches=o}return s.matches}function tl(t,e){return t.queries.getByIndex(e)}const el=new me("Application Initializer");let nl=(()=>{class t{constructor(t){this.appInits=t,this.initialized=!1,this.done=!1,this.donePromise=new Promise((t,e)=>{this.resolve=t,this.reject=e})}runInitializers(){if(this.initialized)return;const t=[],e=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let n=0;n<this.appInits.length;n++){const e=this.appInits[n]();uo(e)&&t.push(e)}Promise.all(t).then(()=>{e()}).catch(t=>{this.reject(t)}),0===t.length&&e(),this.initialized=!0}}return t.\u0275fac=function(e){return new(e||t)(Ee(el,8))},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})();const rl=new me("AppId"),sl={provide:rl,useFactory:function(){return`${il()}${il()}${il()}`},deps:[]};function il(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const ol=new me("Platform Initializer"),al=new me("Platform ID"),ll=new me("appBootstrapListener");let ul=(()=>{class t{log(t){console.log(t)}warn(t){console.warn(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})();const cl=new me("LocaleId"),hl=new me("DefaultCurrencyCode");class dl{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}const pl=function(t){return new Ua(t)},fl=pl,ml=function(t){return Promise.resolve(pl(t))},gl=function(t){const e=pl(t),n=xr(Je(t).declarations).reduce((t,e)=>{const n=Ye(e);return n&&t.push(new Ra(n)),t},[]);return new dl(e,n)},yl=gl,bl=function(t){return Promise.resolve(gl(t))};let vl=(()=>{class t{constructor(){this.compileModuleSync=fl,this.compileModuleAsync=ml,this.compileModuleAndAllComponentsSync=yl,this.compileModuleAndAllComponentsAsync=bl}clearCache(){}clearCacheFor(t){}getModuleId(t){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})();const xl=(()=>Promise.resolve(0))();function wl(t){"undefined"==typeof Zone?xl.then(()=>{t&&t.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",t)}class Cl{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Wa(!1),this.onMicrotaskEmpty=new Wa(!1),this.onStable=new Wa(!1),this.onError=new Wa(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched(),this._nesting=0,this._outer=this._inner=Zone.current,Zone.wtfZoneSpec&&(this._inner=this._inner.fork(Zone.wtfZoneSpec)),Zone.TaskTrackingZoneSpec&&(this._inner=this._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(this._inner=this._inner.fork(Zone.longStackTraceZoneSpec)),this.shouldCoalesceEventChangeDetection=e,this.lastRequestAnimationFrameId=-1,this.nativeRequestAnimationFrame=function(){let t=ae.requestAnimationFrame,e=ae.cancelAnimationFrame;if("undefined"!=typeof Zone&&t&&e){const n=t[Zone.__symbol__("OriginalDelegate")];n&&(t=n);const r=e[Zone.__symbol__("OriginalDelegate")];r&&(e=r)}return{nativeRequestAnimationFrame:t,nativeCancelAnimationFrame:e}}().nativeRequestAnimationFrame,function(t){const e=!!t.shouldCoalesceEventChangeDetection&&t.nativeRequestAnimationFrame&&(()=>{!function(t){-1===t.lastRequestAnimationFrameId&&(t.lastRequestAnimationFrameId=t.nativeRequestAnimationFrame.call(ae,()=>{t.fakeTopEventTask||(t.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{t.lastRequestAnimationFrameId=-1,kl(t),El(t)},void 0,()=>{},()=>{})),t.fakeTopEventTask.invoke()}),kl(t))}(t)});t._inner=t._inner.fork({name:"angular",properties:{isAngularZone:!0,maybeDelayChangeDetection:e},onInvokeTask:(n,r,s,i,o,a)=>{try{return Al(t),n.invokeTask(s,i,o,a)}finally{e&&"eventTask"===i.type&&e(),Il(t)}},onInvoke:(e,n,r,s,i,o,a)=>{try{return Al(t),e.invoke(r,s,i,o,a)}finally{Il(t)}},onHasTask:(e,n,r,s)=>{e.hasTask(r,s),n===r&&("microTask"==s.change?(t._hasPendingMicrotasks=s.microTask,kl(t),El(t)):"macroTask"==s.change&&(t.hasPendingMacrotasks=s.macroTask))},onHandleError:(e,n,r,s)=>(e.handleError(r,s),t.runOutsideAngular(()=>t.onError.emit(s)),!1)})}(this)}static isInAngularZone(){return!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Cl.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(Cl.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(t,e,n){return this._inner.run(t,e,n)}runTask(t,e,n,r){const s=this._inner,i=s.scheduleEventTask("NgZoneEvent: "+r,t,_l,Sl,Sl);try{return s.runTask(i,e,n)}finally{s.cancelTask(i)}}runGuarded(t,e,n){return this._inner.runGuarded(t,e,n)}runOutsideAngular(t){return this._outer.run(t)}}function Sl(){}const _l={};function El(t){if(0==t._nesting&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function kl(t){t.hasPendingMicrotasks=!!(t._hasPendingMicrotasks||t.shouldCoalesceEventChangeDetection&&-1!==t.lastRequestAnimationFrameId)}function Al(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function Il(t){t._nesting--,El(t)}class Nl{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Wa,this.onMicrotaskEmpty=new Wa,this.onStable=new Wa,this.onError=new Wa}run(t,e,n){return t.apply(e,n)}runGuarded(t,e,n){return t.apply(e,n)}runOutsideAngular(t){return t()}runTask(t,e,n,r){return t.apply(e,n)}}let Tl=(()=>{class t{constructor(t){this._ngZone=t,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),t.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Cl.assertNotInAngularZone(),wl(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())wl(()=>{for(;0!==this._callbacks.length;){let t=this._callbacks.pop();clearTimeout(t.timeoutId),t.doneCb(this._didWork)}this._didWork=!1});else{let t=this.getPendingTasks();this._callbacks=this._callbacks.filter(e=>!e.updateCb||!e.updateCb(t)||(clearTimeout(e.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(t=>({source:t.source,creationLocation:t.creationLocation,data:t.data})):[]}addCallback(t,e,n){let r=-1;e&&e>0&&(r=setTimeout(()=>{this._callbacks=this._callbacks.filter(t=>t.timeoutId!==r),t(this._didWork,this.getPendingTasks())},e)),this._callbacks.push({doneCb:t,timeoutId:r,updateCb:n})}whenStable(t,e,n){if(n&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');this.addCallback(t,e,n),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(t,e,n){return[]}}return t.\u0275fac=function(e){return new(e||t)(Ee(Cl))},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})(),Rl=(()=>{class t{constructor(){this._applications=new Map,Ol.addToWindow(this)}registerApplication(t,e){this._applications.set(t,e)}unregisterApplication(t){this._applications.delete(t)}unregisterAllApplications(){this._applications.clear()}getTestability(t){return this._applications.get(t)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(t,e=!0){return Ol.findTestabilityInTree(this,t,e)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})();class $l{addToWindow(t){}findTestabilityInTree(t,e,n){return null}}let Dl,Ol=new $l;const Fl=new me("AllowMultipleToken");class Ml{constructor(t,e){this.name=t,this.token=e}}function Ll(t,e,n=[]){const r="Platform: "+e,s=new me(r);return(e=[])=>{let i=Pl();if(!i||i.injector.get(Fl,!1))if(t)t(n.concat(e).concat({provide:s,useValue:!0}));else{const t=n.concat(e).concat({provide:s,useValue:!0},{provide:Oi,useValue:"platform"});!function(t){if(Dl&&!Dl.destroyed&&!Dl.injector.get(Fl,!1))throw new Error("There can be only one platform. Destroy the previous one to create a new one.");Dl=t.get(zl);const e=t.get(ol,null);e&&e.forEach(t=>t())}(Ki.create({providers:t,name:r}))}return function(t){const e=Pl();if(!e)throw new Error("No platform exists!");if(!e.injector.get(t,null))throw new Error("A platform with a different configuration has been created. Please destroy it first.");return e}(s)}}function Pl(){return Dl&&!Dl.destroyed?Dl:null}let zl=(()=>{class t{constructor(t){this._injector=t,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(t,e){const n=function(t,e){let n;return n="noop"===t?new Nl:("zone.js"===t?void 0:t)||new Cl({enableLongStackTrace:qr(),shouldCoalesceEventChangeDetection:e}),n}(e?e.ngZone:void 0,e&&e.ngZoneEventCoalescing||!1),r=[{provide:Cl,useValue:n}];return n.run(()=>{const e=Ki.create({providers:r,parent:this.injector,name:t.moduleType.name}),s=t.create(e),i=s.injector.get(Ur,null);if(!i)throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");return s.onDestroy(()=>Ul(this._modules,s)),n.runOutsideAngular(()=>n.onError.subscribe({next:t=>{i.handleError(t)}})),function(t,e,n){try{const r=n();return uo(r)?r.catch(n=>{throw e.runOutsideAngular(()=>t.handleError(n)),n}):r}catch(r){throw e.runOutsideAngular(()=>t.handleError(r)),r}}(i,n,()=>{const t=s.injector.get(nl);return t.runInitializers(),t.donePromise.then(()=>(za(s.injector.get(cl,"en-US")||"en-US"),this._moduleDoBootstrap(s),s))})})}bootstrapModule(t,e=[]){const n=Bl({},e);return function(t,e,n){const r=new Ua(n);return Promise.resolve(r)}(0,0,t).then(t=>this.bootstrapModuleFactory(t,n))}_moduleDoBootstrap(t){const e=t.injector.get(Vl);if(t._bootstrapComponents.length>0)t._bootstrapComponents.forEach(t=>e.bootstrap(t));else{if(!t.instance.ngDoBootstrap)throw new Error(`The module ${Zt(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);t.instance.ngDoBootstrap(e)}this._modules.push(t)}onDestroy(t){this._destroyListeners.push(t)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Error("The platform has already been destroyed!");this._modules.slice().forEach(t=>t.destroy()),this._destroyListeners.forEach(t=>t()),this._destroyed=!0}get destroyed(){return this._destroyed}}return t.\u0275fac=function(e){return new(e||t)(Ee(Ki))},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})();function Bl(t,e){return Array.isArray(e)?e.reduce(Bl,t):Object.assign(Object.assign({},t),e)}let Vl=(()=>{class t{constructor(t,e,n,r,s,i){this._zone=t,this._console=e,this._injector=n,this._exceptionHandler=r,this._componentFactoryResolver=s,this._initStatus=i,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._enforceNoNewChanges=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._enforceNoNewChanges=qr(),this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const o=new J(t=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{t.next(this._stable),t.complete()})}),a=new J(t=>{let e;this._zone.runOutsideAngular(()=>{e=this._zone.onStable.subscribe(()=>{Cl.assertNotInAngularZone(),wl(()=>{this._stable||this._zone.hasPendingMacrotasks||this._zone.hasPendingMicrotasks||(this._stable=!0,t.next(!0))})})});const n=this._zone.onUnstable.subscribe(()=>{Cl.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{t.next(!1)}))});return()=>{e.unsubscribe(),n.unsubscribe()}});this.isStable=function(...t){let e=Number.POSITIVE_INFINITY,n=null,r=t[t.length-1];return it(r)?(n=t.pop(),t.length>1&&"number"==typeof t[t.length-1]&&(e=t.pop())):"number"==typeof r&&(e=t.pop()),null===n&&1===t.length&&t[0]instanceof J?t[0]:St(e)(_t(t,n))}(o,a.pipe(t=>{return Et()((e=Rt,function(t){let n;n="function"==typeof e?e:function(){return e};const r=Object.create(t,Nt);return r.source=t,r.subjectFactory=n,r})(t));var e}))}bootstrap(t,e){if(!this._initStatus.done)throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");let n;n=t instanceof Yo?t:this._componentFactoryResolver.resolveComponentFactory(t),this.componentTypes.push(n.componentType);const r=n.isBoundToModule?void 0:this._injector.get(Ne),s=n.create(Ki.NULL,[],e||n.selector,r);s.onDestroy(()=>{this._unloadComponent(s)});const i=s.injector.get(Tl,null);return i&&s.injector.get(Rl).registerApplication(s.location.nativeElement,i),this._loadComponent(s),qr()&&this._console.log("Angular is running in development mode. Call enableProdMode() to enable production mode."),s}tick(){if(this._runningTick)throw new Error("ApplicationRef.tick is called recursively");try{this._runningTick=!0;for(let t of this._views)t.detectChanges();if(this._enforceNoNewChanges)for(let t of this._views)t.checkNoChanges()}catch(t){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(t))}finally{this._runningTick=!1}}attachView(t){const e=t;this._views.push(e),e.attachToAppRef(this)}detachView(t){const e=t;Ul(this._views,e),e.detachFromAppRef()}_loadComponent(t){this.attachView(t.hostView),this.tick(),this.components.push(t),this._injector.get(ll,[]).concat(this._bootstrapListeners).forEach(e=>e(t))}_unloadComponent(t){this.detachView(t.hostView),Ul(this.components,t)}ngOnDestroy(){this._views.slice().forEach(t=>t.destroy())}get viewCount(){return this._views.length}}return t.\u0275fac=function(e){return new(e||t)(Ee(Cl),Ee(ul),Ee(Ki),Ee(Ur),Ee(Jo),Ee(nl))},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})();function Ul(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}class Wl{}class jl{}const Hl={factoryPathPrefix:"",factoryPathSuffix:".ngfactory"};let ql=(()=>{class t{constructor(t,e){this._compiler=t,this._config=e||Hl}load(t){return this.loadAndCompile(t)}loadAndCompile(t){let[e,r]=t.split("#");return void 0===r&&(r="default"),n("zn8P")(e).then(t=>t[r]).then(t=>Gl(t,e,r)).then(t=>this._compiler.compileModuleAsync(t))}loadFactory(t){let[e,r]=t.split("#"),s="NgFactory";return void 0===r&&(r="default",s=""),n("zn8P")(this._config.factoryPathPrefix+e+this._config.factoryPathSuffix).then(t=>t[r+s]).then(t=>Gl(t,e,r))}}return t.\u0275fac=function(e){return new(e||t)(Ee(vl),Ee(jl,8))},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})();function Gl(t,e,n){if(!t)throw new Error(`Cannot find '${n}' in '${e}'`);return t}const Kl=Ll(null,"core",[{provide:al,useValue:"unknown"},{provide:zl,deps:[Ki]},{provide:Rl,deps:[]},{provide:ul,deps:[]}]),Xl=[{provide:Vl,useClass:Vl,deps:[Cl,ul,Ki,Ur,Jo,nl]},{provide:Ta,deps:[Cl],useFactory:function(t){let e=[];return t.onStable.subscribe(()=>{for(;e.length;)e.pop()()}),function(t){e.push(t)}}},{provide:nl,useClass:nl,deps:[[new Ft,el]]},{provide:vl,useClass:vl,deps:[]},sl,{provide:ba,useFactory:function(){return wa},deps:[]},{provide:va,useFactory:function(){return Ca},deps:[]},{provide:cl,useFactory:function(t){return za(t=t||"undefined"!=typeof $localize&&$localize.locale||"en-US"),t},deps:[[new Ot(cl),new Ft,new Lt]]},{provide:hl,useValue:"USD"}];let Yl=(()=>{class t{constructor(t){}}return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)(Ee(Vl))},providers:Xl}),t})(),Zl=null;function Jl(){return Zl}const Ql=new me("DocumentToken");let tu=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Vt({factory:eu,token:t,providedIn:"platform"}),t})();function eu(){return Ee(ru)}const nu=new me("Location Initialized");let ru=(()=>{class t extends tu{constructor(t){super(),this._doc=t,this._init()}_init(){this.location=Jl().getLocation(),this._history=Jl().getHistory()}getBaseHrefFromDOM(){return Jl().getBaseHref(this._doc)}onPopState(t){Jl().getGlobalEventTarget(this._doc,"window").addEventListener("popstate",t,!1)}onHashChange(t){Jl().getGlobalEventTarget(this._doc,"window").addEventListener("hashchange",t,!1)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(t){this.location.pathname=t}pushState(t,e,n){su()?this._history.pushState(t,e,n):this.location.hash=n}replaceState(t,e,n){su()?this._history.replaceState(t,e,n):this.location.hash=n}forward(){this._history.forward()}back(){this._history.back()}getState(){return this._history.state}}return t.\u0275fac=function(e){return new(e||t)(Ee(Ql))},t.\u0275prov=Vt({factory:iu,token:t,providedIn:"platform"}),t})();function su(){return!!window.history.pushState}function iu(){return new ru(Ee(Ql))}function ou(t,e){if(0==t.length)return e;if(0==e.length)return t;let n=0;return t.endsWith("/")&&n++,e.startsWith("/")&&n++,2==n?t+e.substring(1):1==n?t+e:t+"/"+e}function au(t){const e=t.match(/#|\?|$/),n=e&&e.index||t.length;return t.slice(0,n-("/"===t[n-1]?1:0))+t.slice(n)}function lu(t){return t&&"?"!==t[0]?"?"+t:t}let uu=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Vt({factory:cu,token:t,providedIn:"root"}),t})();function cu(t){const e=Ee(Ql).location;return new du(Ee(tu),e&&e.origin||"")}const hu=new me("appBaseHref");let du=(()=>{class t extends uu{constructor(t,e){if(super(),this._platformLocation=t,null==e&&(e=this._platformLocation.getBaseHrefFromDOM()),null==e)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=e}onPopState(t){this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t)}getBaseHref(){return this._baseHref}prepareExternalUrl(t){return ou(this._baseHref,t)}path(t=!1){const e=this._platformLocation.pathname+lu(this._platformLocation.search),n=this._platformLocation.hash;return n&&t?`${e}${n}`:e}pushState(t,e,n,r){const s=this.prepareExternalUrl(n+lu(r));this._platformLocation.pushState(t,e,s)}replaceState(t,e,n,r){const s=this.prepareExternalUrl(n+lu(r));this._platformLocation.replaceState(t,e,s)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}}return t.\u0275fac=function(e){return new(e||t)(Ee(tu),Ee(hu,8))},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})(),pu=(()=>{class t extends uu{constructor(t,e){super(),this._platformLocation=t,this._baseHref="",null!=e&&(this._baseHref=e)}onPopState(t){this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t)}getBaseHref(){return this._baseHref}path(t=!1){let e=this._platformLocation.hash;return null==e&&(e="#"),e.length>0?e.substring(1):e}prepareExternalUrl(t){const e=ou(this._baseHref,t);return e.length>0?"#"+e:e}pushState(t,e,n,r){let s=this.prepareExternalUrl(n+lu(r));0==s.length&&(s=this._platformLocation.pathname),this._platformLocation.pushState(t,e,s)}replaceState(t,e,n,r){let s=this.prepareExternalUrl(n+lu(r));0==s.length&&(s=this._platformLocation.pathname),this._platformLocation.replaceState(t,e,s)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}}return t.\u0275fac=function(e){return new(e||t)(Ee(tu),Ee(hu,8))},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})(),fu=(()=>{class t{constructor(t,e){this._subject=new Wa,this._urlChangeListeners=[],this._platformStrategy=t;const n=this._platformStrategy.getBaseHref();this._platformLocation=e,this._baseHref=au(gu(n)),this._platformStrategy.onPopState(t=>{this._subject.emit({url:this.path(!0),pop:!0,state:t.state,type:t.type})})}path(t=!1){return this.normalize(this._platformStrategy.path(t))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(t,e=""){return this.path()==this.normalize(t+lu(e))}normalize(e){return t.stripTrailingSlash(function(t,e){return t&&e.startsWith(t)?e.substring(t.length):e}(this._baseHref,gu(e)))}prepareExternalUrl(t){return t&&"/"!==t[0]&&(t="/"+t),this._platformStrategy.prepareExternalUrl(t)}go(t,e="",n=null){this._platformStrategy.pushState(n,"",t,e),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+lu(e)),n)}replaceState(t,e="",n=null){this._platformStrategy.replaceState(n,"",t,e),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+lu(e)),n)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}onUrlChange(t){this._urlChangeListeners.push(t),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(t=>{this._notifyUrlChangeListeners(t.url,t.state)}))}_notifyUrlChangeListeners(t="",e){this._urlChangeListeners.forEach(n=>n(t,e))}subscribe(t,e,n){return this._subject.subscribe({next:t,error:e,complete:n})}}return t.\u0275fac=function(e){return new(e||t)(Ee(uu),Ee(tu))},t.normalizeQueryParams=lu,t.joinWithSlash=ou,t.stripTrailingSlash=au,t.\u0275prov=Vt({factory:mu,token:t,providedIn:"root"}),t})();function mu(){return new fu(Ee(uu),Ee(tu))}function gu(t){return t.replace(/\/index.html$/,"")}var yu=function(t){return t[t.Zero=0]="Zero",t[t.One=1]="One",t[t.Two=2]="Two",t[t.Few=3]="Few",t[t.Many=4]="Many",t[t.Other=5]="Other",t}({});class bu{}let vu=(()=>{class t extends bu{constructor(t){super(),this.locale=t}getPluralCategory(t,e){switch(function(t){return function(t){const e=function(t){return t.toLowerCase().replace(/_/g,"-")}(t);let n=Ma(e);if(n)return n;const r=e.split("-")[0];if(n=Ma(r),n)return n;if("en"===r)return Oa;throw new Error(`Missing locale data for the locale "${t}".`)}(t)[La.PluralCase]}(e||this.locale)(t)){case yu.Zero:return"zero";case yu.One:return"one";case yu.Two:return"two";case yu.Few:return"few";case yu.Many:return"many";default:return"other"}}}return t.\u0275fac=function(e){return new(e||t)(Ee(cl))},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})(),xu=(()=>{class t{}return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},providers:[{provide:bu,useClass:vu}]}),t})(),wu=(()=>{class t{}return t.\u0275prov=Vt({token:t,providedIn:"root",factory:()=>new Cu(Ee(Ql),window,Ee(Ur))}),t})();class Cu{constructor(t,e,n){this.document=t,this.window=e,this.errorHandler=n,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return this.supportScrollRestoration()?[this.window.scrollX,this.window.scrollY]:[0,0]}scrollToPosition(t){this.supportScrollRestoration()&&this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){if(this.supportScrollRestoration()){t=this.window.CSS&&this.window.CSS.escape?this.window.CSS.escape(t):t.replace(/(\"|\'\ |:|\.|\[|\]|,|=)/g,"\\$1");try{const e=this.document.querySelector("#"+t);if(e)return void this.scrollToElement(e);const n=this.document.querySelector(`[name='${t}']`);if(n)return void this.scrollToElement(n)}catch(e){this.errorHandler.handleError(e)}}}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),n=e.left+this.window.pageXOffset,r=e.top+this.window.pageYOffset,s=this.offset();this.window.scrollTo(n-s[0],r-s[1])}supportScrollRestoration(){try{return!!this.window&&!!this.window.scrollTo}catch(t){return!1}}}class Su extends class extends class{}{constructor(){super()}supportsDOMEvents(){return!0}}{static makeCurrent(){var t;t=new Su,Zl||(Zl=t)}getProperty(t,e){return t[e]}log(t){window.console&&window.console.log&&window.console.log(t)}logGroup(t){window.console&&window.console.group&&window.console.group(t)}logGroupEnd(){window.console&&window.console.groupEnd&&window.console.groupEnd()}onAndCancel(t,e,n){return t.addEventListener(e,n,!1),()=>{t.removeEventListener(e,n,!1)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){return t.parentNode&&t.parentNode.removeChild(t),t}getValue(t){return t.value}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getHistory(){return window.history}getLocation(){return window.location}getBaseHref(t){const e=Eu||(Eu=document.querySelector("base"),Eu)?Eu.getAttribute("href"):null;return null==e?null:(n=e,_u||(_u=document.createElement("a")),_u.setAttribute("href",n),"/"===_u.pathname.charAt(0)?_u.pathname:"/"+_u.pathname);var n}resetBaseElement(){Eu=null}getUserAgent(){return window.navigator.userAgent}performanceNow(){return window.performance&&window.performance.now?window.performance.now():(new Date).getTime()}supportsCookies(){return!0}getCookie(t){return function(t,e){e=encodeURIComponent(e);for(const n of t.split(";")){const t=n.indexOf("="),[r,s]=-1==t?[n,""]:[n.slice(0,t),n.slice(t+1)];if(r.trim()===e)return decodeURIComponent(s)}return null}(document.cookie,t)}}let _u,Eu=null;const ku=new me("TRANSITION_ID"),Au=[{provide:el,useFactory:function(t,e,n){return()=>{n.get(nl).donePromise.then(()=>{const n=Jl();Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e=>e.getAttribute("ng-transition")===t).forEach(t=>n.remove(t))})}},deps:[ku,Ql,Ki],multi:!0}];class Iu{static init(){var t;t=new Iu,Ol=t}addToWindow(t){ae.getAngularTestability=(e,n=!0)=>{const r=t.findTestabilityInTree(e,n);if(null==r)throw new Error("Could not find testability for element.");return r},ae.getAllAngularTestabilities=()=>t.getAllTestabilities(),ae.getAllAngularRootElements=()=>t.getAllRootElements(),ae.frameworkStabilizers||(ae.frameworkStabilizers=[]),ae.frameworkStabilizers.push(t=>{const e=ae.getAllAngularTestabilities();let n=e.length,r=!1;const s=function(e){r=r||e,n--,0==n&&t(r)};e.forEach((function(t){t.whenStable(s)}))})}findTestabilityInTree(t,e,n){if(null==e)return null;const r=t.getTestability(e);return null!=r?r:n?Jl().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null}}const Nu=new me("EventManagerPlugins");let Tu=(()=>{class t{constructor(t,e){this._zone=e,this._eventNameToPlugin=new Map,t.forEach(t=>t.manager=this),this._plugins=t.slice().reverse()}addEventListener(t,e,n){return this._findPluginFor(e).addEventListener(t,e,n)}addGlobalEventListener(t,e,n){return this._findPluginFor(e).addGlobalEventListener(t,e,n)}getZone(){return this._zone}_findPluginFor(t){const e=this._eventNameToPlugin.get(t);if(e)return e;const n=this._plugins;for(let r=0;r<n.length;r++){const e=n[r];if(e.supports(t))return this._eventNameToPlugin.set(t,e),e}throw new Error("No event manager plugin found for event "+t)}}return t.\u0275fac=function(e){return new(e||t)(Ee(Nu),Ee(Cl))},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})();class Ru{constructor(t){this._doc=t}addGlobalEventListener(t,e,n){const r=Jl().getGlobalEventTarget(this._doc,t);if(!r)throw new Error(`Unsupported event target ${r} for event ${e}`);return this.addEventListener(r,e,n)}}let $u=(()=>{class t{constructor(){this._stylesSet=new Set}addStyles(t){const e=new Set;t.forEach(t=>{this._stylesSet.has(t)||(this._stylesSet.add(t),e.add(t))}),this.onStylesAdded(e)}onStylesAdded(t){}getAllStyles(){return Array.from(this._stylesSet)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})(),Du=(()=>{class t extends $u{constructor(t){super(),this._doc=t,this._hostNodes=new Set,this._styleNodes=new Set,this._hostNodes.add(t.head)}_addStylesToHost(t,e){t.forEach(t=>{const n=this._doc.createElement("style");n.textContent=t,this._styleNodes.add(e.appendChild(n))})}addHost(t){this._addStylesToHost(this._stylesSet,t),this._hostNodes.add(t)}removeHost(t){this._hostNodes.delete(t)}onStylesAdded(t){this._hostNodes.forEach(e=>this._addStylesToHost(t,e))}ngOnDestroy(){this._styleNodes.forEach(t=>Jl().remove(t))}}return t.\u0275fac=function(e){return new(e||t)(Ee(Ql))},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})();const Ou={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},Fu=/%COMP%/g;function Mu(t,e,n){for(let r=0;r<e.length;r++){let s=e[r];Array.isArray(s)?Mu(t,s,n):(s=s.replace(Fu,t),n.push(s))}return n}function Lu(t){return e=>{if("__ngUnwrap__"===e)return t;!1===t(e)&&(e.preventDefault(),e.returnValue=!1)}}let Pu=(()=>{class t{constructor(t,e,n){this.eventManager=t,this.sharedStylesHost=e,this.appId=n,this.rendererByCompId=new Map,this.defaultRenderer=new zu(t)}createRenderer(t,e){if(!t||!e)return this.defaultRenderer;switch(e.encapsulation){case ze.Emulated:{let n=this.rendererByCompId.get(e.id);return n||(n=new Bu(this.eventManager,this.sharedStylesHost,e,this.appId),this.rendererByCompId.set(e.id,n)),n.applyToHost(t),n}case ze.Native:case ze.ShadowDom:return new Vu(this.eventManager,this.sharedStylesHost,t,e);default:if(!this.rendererByCompId.has(e.id)){const t=Mu(e.id,e.styles,[]);this.sharedStylesHost.addStyles(t),this.rendererByCompId.set(e.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return t.\u0275fac=function(e){return new(e||t)(Ee(Tu),Ee(Du),Ee(rl))},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})();class zu{constructor(t){this.eventManager=t,this.data=Object.create(null)}destroy(){}createElement(t,e){return e?document.createElementNS(Ou[e]||e,t):document.createElement(t)}createComment(t){return document.createComment(t)}createText(t){return document.createTextNode(t)}appendChild(t,e){t.appendChild(e)}insertBefore(t,e,n){t&&t.insertBefore(e,n)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let n="string"==typeof t?document.querySelector(t):t;if(!n)throw new Error(`The selector "${t}" did not match any elements`);return e||(n.textContent=""),n}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,n,r){if(r){e=r+":"+e;const s=Ou[r];s?t.setAttributeNS(s,e,n):t.setAttribute(e,n)}else t.setAttribute(e,n)}removeAttribute(t,e,n){if(n){const r=Ou[n];r?t.removeAttributeNS(r,e):t.removeAttribute(`${n}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,n,r){r&na.DashCase?t.style.setProperty(e,n,r&na.Important?"important":""):t.style[e]=n}removeStyle(t,e,n){n&na.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,n){t[e]=n}setValue(t,e){t.nodeValue=e}listen(t,e,n){return"string"==typeof t?this.eventManager.addGlobalEventListener(t,e,Lu(n)):this.eventManager.addEventListener(t,e,Lu(n))}}class Bu extends zu{constructor(t,e,n,r){super(t),this.component=n;const s=Mu(r+"-"+n.id,n.styles,[]);e.addStyles(s),this.contentAttr="_ngcontent-%COMP%".replace(Fu,r+"-"+n.id),this.hostAttr=function(t){return"_nghost-%COMP%".replace(Fu,t)}(r+"-"+n.id)}applyToHost(t){super.setAttribute(t,this.hostAttr,"")}createElement(t,e){const n=super.createElement(t,e);return super.setAttribute(n,this.contentAttr,""),n}}class Vu extends zu{constructor(t,e,n,r){super(t),this.sharedStylesHost=e,this.hostEl=n,this.component=r,this.shadowRoot=r.encapsulation===ze.ShadowDom?n.attachShadow({mode:"open"}):n.createShadowRoot(),this.sharedStylesHost.addHost(this.shadowRoot);const s=Mu(r.id,r.styles,[]);for(let i=0;i<s.length;i++){const t=document.createElement("style");t.textContent=s[i],this.shadowRoot.appendChild(t)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,n){return super.insertBefore(this.nodeOrShadowRoot(t),e,n)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}}let Uu=(()=>{class t extends Ru{constructor(t){super(t)}supports(t){return!0}addEventListener(t,e,n){return t.addEventListener(e,n,!1),()=>this.removeEventListener(t,e,n)}removeEventListener(t,e,n){return t.removeEventListener(e,n)}}return t.\u0275fac=function(e){return new(e||t)(Ee(Ql))},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})();const Wu=["alt","control","meta","shift"],ju={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},Hu={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},qu={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey};let Gu=(()=>{class t extends Ru{constructor(t){super(t)}supports(e){return null!=t.parseEventName(e)}addEventListener(e,n,r){const s=t.parseEventName(n),i=t.eventCallback(s.fullKey,r,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Jl().onAndCancel(e,s.domEventName,i))}static parseEventName(e){const n=e.toLowerCase().split("."),r=n.shift();if(0===n.length||"keydown"!==r&&"keyup"!==r)return null;const s=t._normalizeKey(n.pop());let i="";if(Wu.forEach(t=>{const e=n.indexOf(t);e>-1&&(n.splice(e,1),i+=t+".")}),i+=s,0!=n.length||0===s.length)return null;const o={};return o.domEventName=r,o.fullKey=i,o}static getEventFullKey(t){let e="",n=function(t){let e=t.key;if(null==e){if(e=t.keyIdentifier,null==e)return"Unidentified";e.startsWith("U+")&&(e=String.fromCharCode(parseInt(e.substring(2),16)),3===t.location&&Hu.hasOwnProperty(e)&&(e=Hu[e]))}return ju[e]||e}(t);return n=n.toLowerCase()," "===n?n="space":"."===n&&(n="dot"),Wu.forEach(r=>{r!=n&&(0,qu[r])(t)&&(e+=r+".")}),e+=n,e}static eventCallback(e,n,r){return s=>{t.getEventFullKey(s)===e&&r.runGuarded(()=>n(s))}}static _normalizeKey(t){switch(t){case"esc":return"escape";default:return t}}}return t.\u0275fac=function(e){return new(e||t)(Ee(Ql))},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})();const Ku=Ll(Kl,"browser",[{provide:al,useValue:"browser"},{provide:ol,useValue:function(){Su.makeCurrent(),Iu.init()},multi:!0},{provide:Ql,useFactory:function(){return function(t){pn=t}(document),document},deps:[]}]),Xu=[[],{provide:Oi,useValue:"root"},{provide:Ur,useFactory:function(){return new Ur},deps:[]},{provide:Nu,useClass:Uu,multi:!0,deps:[Ql,Cl,al]},{provide:Nu,useClass:Gu,multi:!0,deps:[Ql]},[],{provide:Pu,useClass:Pu,deps:[Tu,Du,rl]},{provide:ea,useExisting:Pu},{provide:$u,useExisting:Du},{provide:Du,useClass:Du,deps:[Ql]},{provide:Tl,useClass:Tl,deps:[Cl]},{provide:Tu,useClass:Tu,deps:[Nu,Cl]},[]];let Yu=(()=>{class t{constructor(t){if(t)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(e){return{ngModule:t,providers:[{provide:rl,useValue:e.appId},{provide:ku,useExisting:rl},Au]}}}return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)(Ee(t,12))},providers:Xu,imports:[xu,Yl]}),t})();function Zu(...t){let e=t[t.length-1];return it(e)?(t.pop(),bt(t,e)):_t(t)}"undefined"!=typeof window&&window;class Ju extends rt{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return e&&!e.closed&&t.next(this._value),e}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new tt;return this._value}next(t){super.next(this._value=t)}}const Qu=(()=>{function t(){return Error.call(this),this.message="no elements in sequence",this.name="EmptyError",this}return t.prototype=Object.create(Error.prototype),t})(),tc={};class ec{constructor(t){this.resultSelector=t}call(t,e){return e.subscribe(new nc(t,this.resultSelector))}}class nc extends ft{constructor(t,e){super(t),this.resultSelector=e,this.active=0,this.values=[],this.observables=[]}_next(t){this.values.push(tc),this.observables.push(t)}_complete(){const t=this.observables,e=t.length;if(0===e)this.destination.complete();else{this.active=e,this.toRespond=e;for(let n=0;n<e;n++){const e=t[n];this.add(pt(this,e,e,n))}}}notifyComplete(t){0==(this.active-=1)&&this.destination.complete()}notifyNext(t,e,n,r,s){const i=this.values,o=this.toRespond?i[n]===tc?--this.toRespond:this.toRespond:0;i[n]=e,0===o&&(this.resultSelector?this._tryResultSelector(i):this.destination.next(i.slice()))}_tryResultSelector(t){let e;try{e=this.resultSelector.apply(this,t)}catch(n){return void this.destination.error(n)}this.destination.next(e)}}const rc=new J(t=>t.complete());function sc(t){return t?function(t){return new J(e=>t.schedule(()=>e.complete()))}(t):rc}function ic(t){return new J(e=>{let n;try{n=t()}catch(r){return void e.error(r)}return(n?vt(n):sc()).subscribe(e)})}function oc(){return St(1)}function ac(t,e){return function(n){return n.lift(new lc(t,e))}}class lc{constructor(t,e){this.predicate=t,this.thisArg=e}call(t,e){return e.subscribe(new uc(t,this.predicate,this.thisArg))}}class uc extends K{constructor(t,e,n){super(t),this.predicate=e,this.thisArg=n,this.count=0}_next(t){let e;try{e=this.predicate.call(this.thisArg,t,this.count++)}catch(n){return void this.destination.error(n)}e&&this.destination.next(t)}}const cc=(()=>{function t(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return t.prototype=Object.create(Error.prototype),t})();function hc(t){return function(e){return 0===t?sc():e.lift(new dc(t))}}class dc{constructor(t){if(this.total=t,this.total<0)throw new cc}call(t,e){return e.subscribe(new pc(t,this.total))}}class pc extends K{constructor(t,e){super(t),this.total=e,this.ring=new Array,this.count=0}_next(t){const e=this.ring,n=this.total,r=this.count++;e.length<n?e.push(t):e[r%n]=t}_complete(){const t=this.destination;let e=this.count;if(e>0){const n=this.count>=this.total?this.total:this.count,r=this.ring;for(let s=0;s<n;s++){const s=e++%n;t.next(r[s])}}t.complete()}}function fc(t=yc){return e=>e.lift(new mc(t))}class mc{constructor(t){this.errorFactory=t}call(t,e){return e.subscribe(new gc(t,this.errorFactory))}}class gc extends K{constructor(t,e){super(t),this.errorFactory=e,this.hasValue=!1}_next(t){this.hasValue=!0,this.destination.next(t)}_complete(){if(this.hasValue)return this.destination.complete();{let e;try{e=this.errorFactory()}catch(t){e=t}this.destination.error(e)}}}function yc(){return new Qu}function bc(t=null){return e=>e.lift(new vc(t))}class vc{constructor(t){this.defaultValue=t}call(t,e){return e.subscribe(new xc(t,this.defaultValue))}}class xc extends K{constructor(t,e){super(t),this.defaultValue=e,this.isEmpty=!0}_next(t){this.isEmpty=!1,this.destination.next(t)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}function wc(t){return function(e){const n=new Cc(t),r=e.lift(n);return n.caught=r}}class Cc{constructor(t){this.selector=t}call(t,e){return e.subscribe(new Sc(t,this.selector,this.caught))}}class Sc extends ft{constructor(t,e,n){super(t),this.selector=e,this.caught=n}error(t){if(!this.isStopped){let n;try{n=this.selector(t,this.caught)}catch(e){return void super.error(e)}this._unsubscribeAndRecycle();const r=new ot(this,void 0,void 0);this.add(r);const s=pt(this,n,void 0,void 0,r);s!==r&&this.add(s)}}}function _c(t){return e=>0===t?sc():e.lift(new Ec(t))}class Ec{constructor(t){if(this.total=t,this.total<0)throw new cc}call(t,e){return e.subscribe(new kc(t,this.total))}}class kc extends K{constructor(t,e){super(t),this.total=e,this.count=0}_next(t){const e=this.total,n=++this.count;n<=e&&(this.destination.next(t),n===e&&(this.destination.complete(),this.unsubscribe()))}}function Ac(t,e){const n=arguments.length>=2;return r=>r.pipe(t?ac((e,n)=>t(e,n,r)):Z,_c(1),n?bc(e):fc(()=>new Qu))}function Ic(){}function Nc(t,e,n){return function(r){return r.lift(new Tc(t,e,n))}}class Tc{constructor(t,e,n){this.nextOrObserver=t,this.error=e,this.complete=n}call(t,e){return e.subscribe(new Rc(t,this.nextOrObserver,this.error,this.complete))}}class Rc extends K{constructor(t,e,n,r){super(t),this._tapNext=Ic,this._tapError=Ic,this._tapComplete=Ic,this._tapError=n||Ic,this._tapComplete=r||Ic,L(e)?(this._context=this,this._tapNext=e):e&&(this._context=e,this._tapNext=e.next||Ic,this._tapError=e.error||Ic,this._tapComplete=e.complete||Ic)}_next(t){try{this._tapNext.call(this._context,t)}catch(e){return void this.destination.error(e)}this.destination.next(t)}_error(t){try{this._tapError.call(this._context,t)}catch(t){return void this.destination.error(t)}this.destination.error(t)}_complete(){try{this._tapComplete.call(this._context)}catch(t){return void this.destination.error(t)}return this.destination.complete()}}class $c{constructor(t,e,n){this.predicate=t,this.thisArg=e,this.source=n}call(t,e){return e.subscribe(new Dc(t,this.predicate,this.thisArg,this.source))}}class Dc extends K{constructor(t,e,n,r){super(t),this.predicate=e,this.thisArg=n,this.source=r,this.index=0,this.thisArg=n||this}notifyComplete(t){this.destination.next(t),this.destination.complete()}_next(t){let e=!1;try{e=this.predicate.call(this.thisArg,t,this.index++,this.source)}catch(n){return void this.destination.error(n)}e||this.notifyComplete(!1)}_complete(){this.notifyComplete(!0)}}function Oc(t,e){return"function"==typeof e?n=>n.pipe(Oc((n,r)=>vt(t(n,r)).pipe(mt((t,s)=>e(n,t,r,s))))):e=>e.lift(new Fc(t))}class Fc{constructor(t){this.project=t}call(t,e){return e.subscribe(new Mc(t,this.project))}}class Mc extends ft{constructor(t,e){super(t),this.project=e,this.index=0}_next(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(r){return void this.destination.error(r)}this._innerSub(e,t,n)}_innerSub(t,e,n){const r=this.innerSubscription;r&&r.unsubscribe();const s=new ot(this,e,n),i=this.destination;i.add(s),this.innerSubscription=pt(this,t,void 0,void 0,s),this.innerSubscription!==s&&i.add(this.innerSubscription)}_complete(){const{innerSubscription:t}=this;t&&!t.closed||super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=null}notifyComplete(t){this.destination.remove(t),this.innerSubscription=null,this.isStopped&&super._complete()}notifyNext(t,e,n,r,s){this.destination.next(e)}}function Lc(...t){return oc()(Zu(...t))}class Pc{constructor(t,e,n=!1){this.accumulator=t,this.seed=e,this.hasSeed=n}call(t,e){return e.subscribe(new zc(t,this.accumulator,this.seed,this.hasSeed))}}class zc extends K{constructor(t,e,n,r){super(t),this.accumulator=e,this._seed=n,this.hasSeed=r,this.index=0}get seed(){return this._seed}set seed(t){this.hasSeed=!0,this._seed=t}_next(t){if(this.hasSeed)return this._tryNext(t);this.seed=t,this.destination.next(t)}_tryNext(t){const e=this.index++;let n;try{n=this.accumulator(this.seed,t,e)}catch(r){this.destination.error(r)}this.seed=n,this.destination.next(n)}}function Bc(t,e){return xt(t,e,1)}class Vc{constructor(t){this.callback=t}call(t,e){return e.subscribe(new Uc(t,this.callback))}}class Uc extends K{constructor(t,e){super(t),this.add(new H(e))}}class Wc{constructor(t,e){this.id=t,this.url=e}}class jc extends Wc{constructor(t,e,n="imperative",r=null){super(t,e),this.navigationTrigger=n,this.restoredState=r}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class Hc extends Wc{constructor(t,e,n){super(t,e),this.urlAfterRedirects=n}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class qc extends Wc{constructor(t,e,n){super(t,e),this.reason=n}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class Gc extends Wc{constructor(t,e,n){super(t,e),this.error=n}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class Kc extends Wc{constructor(t,e,n,r){super(t,e),this.urlAfterRedirects=n,this.state=r}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Xc extends Wc{constructor(t,e,n,r){super(t,e),this.urlAfterRedirects=n,this.state=r}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Yc extends Wc{constructor(t,e,n,r,s){super(t,e),this.urlAfterRedirects=n,this.state=r,this.shouldActivate=s}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class Zc extends Wc{constructor(t,e,n,r){super(t,e),this.urlAfterRedirects=n,this.state=r}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Jc extends Wc{constructor(t,e,n,r){super(t,e),this.urlAfterRedirects=n,this.state=r}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Qc{constructor(t){this.route=t}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class th{constructor(t){this.route=t}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class eh{constructor(t){this.snapshot=t}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class nh{constructor(t){this.snapshot=t}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class rh{constructor(t){this.snapshot=t}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class sh{constructor(t){this.snapshot=t}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class ih{constructor(t,e,n){this.routerEvent=t,this.position=e,this.anchor=n}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}let oh=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=We({type:t,selectors:[["ng-component"]],decls:1,vars:0,template:function(t,e){1&t&&lo(0,"router-outlet")},directives:function(){return[op]},encapsulation:2}),t})();class ah{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function lh(t){return new ah(t)}function uh(t){const e=Error("NavigationCancelingError: "+t);return e.ngNavigationCancelingError=!0,e}function ch(t,e,n){const r=n.path.split("/");if(r.length>t.length)return null;if("full"===n.pathMatch&&(e.hasChildren()||r.length<t.length))return null;const s={};for(let i=0;i<r.length;i++){const e=r[i],n=t[i];if(e.startsWith(":"))s[e.substring(1)]=n;else if(e!==n.path)return null}return{consumed:t.slice(0,r.length),posParams:s}}class hh{constructor(t,e){this.routes=t,this.module=e}}function dh(t,e=""){for(let n=0;n<t.length;n++){const r=t[n];ph(r,fh(e,r))}}function ph(t,e){if(!t)throw new Error(`\n      Invalid configuration of route '${e}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);if(Array.isArray(t))throw new Error(`Invalid configuration of route '${e}': Array cannot be specified`);if(!t.component&&!t.children&&!t.loadChildren&&t.outlet&&"primary"!==t.outlet)throw new Error(`Invalid configuration of route '${e}': a componentless route without children or loadChildren cannot have a named outlet set`);if(t.redirectTo&&t.children)throw new Error(`Invalid configuration of route '${e}': redirectTo and children cannot be used together`);if(t.redirectTo&&t.loadChildren)throw new Error(`Invalid configuration of route '${e}': redirectTo and loadChildren cannot be used together`);if(t.children&&t.loadChildren)throw new Error(`Invalid configuration of route '${e}': children and loadChildren cannot be used together`);if(t.redirectTo&&t.component)throw new Error(`Invalid configuration of route '${e}': redirectTo and component cannot be used together`);if(t.path&&t.matcher)throw new Error(`Invalid configuration of route '${e}': path and matcher cannot be used together`);if(void 0===t.redirectTo&&!t.component&&!t.children&&!t.loadChildren)throw new Error(`Invalid configuration of route '${e}'. One of the following must be provided: component, redirectTo, children or loadChildren`);if(void 0===t.path&&void 0===t.matcher)throw new Error(`Invalid configuration of route '${e}': routes must have either a path or a matcher specified`);if("string"==typeof t.path&&"/"===t.path.charAt(0))throw new Error(`Invalid configuration of route '${e}': path cannot start with a slash`);if(""===t.path&&void 0!==t.redirectTo&&void 0===t.pathMatch)throw new Error(`Invalid configuration of route '{path: "${e}", redirectTo: "${t.redirectTo}"}': please provide 'pathMatch'. The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`);if(void 0!==t.pathMatch&&"full"!==t.pathMatch&&"prefix"!==t.pathMatch)throw new Error(`Invalid configuration of route '${e}': pathMatch can only be set to 'prefix' or 'full'`);t.children&&dh(t.children,e)}function fh(t,e){return e?t||e.path?t&&!e.path?t+"/":!t&&e.path?e.path:`${t}/${e.path}`:"":t}function mh(t){const e=t.children&&t.children.map(mh),n=e?Object.assign(Object.assign({},t),{children:e}):Object.assign({},t);return!n.component&&(e||n.loadChildren)&&n.outlet&&"primary"!==n.outlet&&(n.component=oh),n}function gh(t,e){const n=Object.keys(t),r=Object.keys(e);if(!n||!r||n.length!=r.length)return!1;let s;for(let i=0;i<n.length;i++)if(s=n[i],!yh(t[s],e[s]))return!1;return!0}function yh(t,e){return Array.isArray(t)&&Array.isArray(e)?t.length==e.length&&t.every(t=>e.indexOf(t)>-1):t===e}function bh(t){return Array.prototype.concat.apply([],t)}function vh(t){return t.length>0?t[t.length-1]:null}function xh(t,e){for(const n in t)t.hasOwnProperty(n)&&e(t[n],n)}function wh(t){return co(t)?t:uo(t)?vt(Promise.resolve(t)):Zu(t)}function Ch(t,e,n){return n?function(t,e){return gh(t,e)}(t.queryParams,e.queryParams)&&function t(e,n){if(!kh(e.segments,n.segments))return!1;if(e.numberOfChildren!==n.numberOfChildren)return!1;for(const r in n.children){if(!e.children[r])return!1;if(!t(e.children[r],n.children[r]))return!1}return!0}(t.root,e.root):function(t,e){return Object.keys(e).length<=Object.keys(t).length&&Object.keys(e).every(n=>yh(t[n],e[n]))}(t.queryParams,e.queryParams)&&function t(e,n){return function e(n,r,s){if(n.segments.length>s.length)return!!kh(n.segments.slice(0,s.length),s)&&!r.hasChildren();if(n.segments.length===s.length){if(!kh(n.segments,s))return!1;for(const e in r.children){if(!n.children[e])return!1;if(!t(n.children[e],r.children[e]))return!1}return!0}{const t=s.slice(0,n.segments.length),i=s.slice(n.segments.length);return!!kh(n.segments,t)&&!!n.children.primary&&e(n.children.primary,r,i)}}(e,n,n.segments)}(t.root,e.root)}class Sh{constructor(t,e,n){this.root=t,this.queryParams=e,this.fragment=n}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=lh(this.queryParams)),this._queryParamMap}toString(){return Th.serialize(this)}}class _h{constructor(t,e){this.segments=t,this.children=e,this.parent=null,xh(e,(t,e)=>t.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return Rh(this)}}class Eh{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=lh(this.parameters)),this._parameterMap}toString(){return Lh(this)}}function kh(t,e){return t.length===e.length&&t.every((t,n)=>t.path===e[n].path)}function Ah(t,e){let n=[];return xh(t.children,(t,r)=>{"primary"===r&&(n=n.concat(e(t,r)))}),xh(t.children,(t,r)=>{"primary"!==r&&(n=n.concat(e(t,r)))}),n}class Ih{}class Nh{parse(t){const e=new Uh(t);return new Sh(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){return`${"/"+function t(e,n){if(!e.hasChildren())return Rh(e);if(n){const n=e.children.primary?t(e.children.primary,!1):"",r=[];return xh(e.children,(e,n)=>{"primary"!==n&&r.push(`${n}:${t(e,!1)}`)}),r.length>0?`${n}(${r.join("//")})`:n}{const n=Ah(e,(n,r)=>"primary"===r?[t(e.children.primary,!1)]:[`${r}:${t(n,!1)}`]);return`${Rh(e)}/(${n.join("//")})`}}(t.root,!0)}${function(t){const e=Object.keys(t).map(e=>{const n=t[e];return Array.isArray(n)?n.map(t=>`${Dh(e)}=${Dh(t)}`).join("&"):`${Dh(e)}=${Dh(n)}`});return e.length?"?"+e.join("&"):""}(t.queryParams)}${"string"==typeof t.fragment?"#"+encodeURI(t.fragment):""}`}}const Th=new Nh;function Rh(t){return t.segments.map(t=>Lh(t)).join("/")}function $h(t){return encodeURIComponent(t).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Dh(t){return $h(t).replace(/%3B/gi,";")}function Oh(t){return $h(t).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Fh(t){return decodeURIComponent(t)}function Mh(t){return Fh(t.replace(/\+/g,"%20"))}function Lh(t){return`${Oh(t.path)}${e=t.parameters,Object.keys(e).map(t=>`;${Oh(t)}=${Oh(e[t])}`).join("")}`;var e}const Ph=/^[^\/()?;=#]+/;function zh(t){const e=t.match(Ph);return e?e[0]:""}const Bh=/^[^=?&#]+/,Vh=/^[^?&#]+/;class Uh{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new _h([],{}):new _h([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let n={};return this.peekStartsWith("(")&&(n=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(n.primary=new _h(t,e)),n}parseSegment(){const t=zh(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(t),new Eh(Fh(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const e=zh(this.remaining);if(!e)return;this.capture(e);let n="";if(this.consumeOptional("=")){const t=zh(this.remaining);t&&(n=t,this.capture(n))}t[Fh(e)]=Fh(n)}parseQueryParam(t){const e=function(t){const e=t.match(Bh);return e?e[0]:""}(this.remaining);if(!e)return;this.capture(e);let n="";if(this.consumeOptional("=")){const t=function(t){const e=t.match(Vh);return e?e[0]:""}(this.remaining);t&&(n=t,this.capture(n))}const r=Mh(e),s=Mh(n);if(t.hasOwnProperty(r)){let e=t[r];Array.isArray(e)||(e=[e],t[r]=e),e.push(s)}else t[r]=s}parseParens(t){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const n=zh(this.remaining),r=this.remaining[n.length];if("/"!==r&&")"!==r&&";"!==r)throw new Error(`Cannot parse url '${this.url}'`);let s=void 0;n.indexOf(":")>-1?(s=n.substr(0,n.indexOf(":")),this.capture(s),this.capture(":")):t&&(s="primary");const i=this.parseChildren();e[s]=1===Object.keys(i).length?i.primary:new _h([],i),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new Error(`Expected "${t}".`)}}class Wh{constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){const e=jh(t,this._root);return e?e.children.map(t=>t.value):[]}firstChild(t){const e=jh(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){const e=Hh(t,this._root);return e.length<2?[]:e[e.length-2].children.map(t=>t.value).filter(e=>e!==t)}pathFromRoot(t){return Hh(t,this._root).map(t=>t.value)}}function jh(t,e){if(t===e.value)return e;for(const n of e.children){const e=jh(t,n);if(e)return e}return null}function Hh(t,e){if(t===e.value)return[e];for(const n of e.children){const r=Hh(t,n);if(r.length)return r.unshift(e),r}return[]}class qh{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function Gh(t){const e={};return t&&t.children.forEach(t=>e[t.value.outlet]=t),e}class Kh extends Wh{constructor(t,e){super(t),this.snapshot=e,td(this,t)}toString(){return this.snapshot.toString()}}function Xh(t,e){const n=function(t,e){const n=new Jh([],{},{},"",{},"primary",e,null,t.root,-1,{});return new Qh("",new qh(n,[]))}(t,e),r=new Ju([new Eh("",{})]),s=new Ju({}),i=new Ju({}),o=new Ju({}),a=new Ju(""),l=new Yh(r,s,o,a,i,"primary",e,n.root);return l.snapshot=n.root,new Kh(new qh(l,[]),n)}class Yh{constructor(t,e,n,r,s,i,o,a){this.url=t,this.params=e,this.queryParams=n,this.fragment=r,this.data=s,this.outlet=i,this.component=o,this._futureSnapshot=a}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(mt(t=>lh(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(mt(t=>lh(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function Zh(t,e="emptyOnly"){const n=t.pathFromRoot;let r=0;if("always"!==e)for(r=n.length-1;r>=1;){const t=n[r],e=n[r-1];if(t.routeConfig&&""===t.routeConfig.path)r--;else{if(e.component)break;r--}}return function(t){return t.reduce((t,e)=>({params:Object.assign(Object.assign({},t.params),e.params),data:Object.assign(Object.assign({},t.data),e.data),resolve:Object.assign(Object.assign({},t.resolve),e._resolvedData)}),{params:{},data:{},resolve:{}})}(n.slice(r))}class Jh{constructor(t,e,n,r,s,i,o,a,l,u,c){this.url=t,this.params=e,this.queryParams=n,this.fragment=r,this.data=s,this.outlet=i,this.component=o,this.routeConfig=a,this._urlSegment=l,this._lastPathIndex=u,this._resolve=c}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=lh(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=lh(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(t=>t.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class Qh extends Wh{constructor(t,e){super(e),this.url=t,td(this,e)}toString(){return ed(this._root)}}function td(t,e){e.value._routerState=t,e.children.forEach(e=>td(t,e))}function ed(t){const e=t.children.length>0?` { ${t.children.map(ed).join(", ")} } `:"";return`${t.value}${e}`}function nd(t){if(t.snapshot){const e=t.snapshot,n=t._futureSnapshot;t.snapshot=n,gh(e.queryParams,n.queryParams)||t.queryParams.next(n.queryParams),e.fragment!==n.fragment&&t.fragment.next(n.fragment),gh(e.params,n.params)||t.params.next(n.params),function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;++n)if(!gh(t[n],e[n]))return!1;return!0}(e.url,n.url)||t.url.next(n.url),gh(e.data,n.data)||t.data.next(n.data)}else t.snapshot=t._futureSnapshot,t.data.next(t._futureSnapshot.data)}function rd(t,e){var n,r;return gh(t.params,e.params)&&kh(n=t.url,r=e.url)&&n.every((t,e)=>gh(t.parameters,r[e].parameters))&&!(!t.parent!=!e.parent)&&(!t.parent||rd(t.parent,e.parent))}function sd(t){return"object"==typeof t&&null!=t&&!t.outlets&&!t.segmentPath}function id(t,e,n,r,s){let i={};return r&&xh(r,(t,e)=>{i[e]=Array.isArray(t)?t.map(t=>""+t):""+t}),new Sh(n.root===t?e:function t(e,n,r){const s={};return xh(e.children,(e,i)=>{s[i]=e===n?r:t(e,n,r)}),new _h(e.segments,s)}(n.root,t,e),i,s)}class od{constructor(t,e,n){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=n,t&&n.length>0&&sd(n[0]))throw new Error("Root segment cannot have matrix parameters");const r=n.find(t=>"object"==typeof t&&null!=t&&t.outlets);if(r&&r!==vh(n))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class ad{constructor(t,e,n){this.segmentGroup=t,this.processChildren=e,this.index=n}}function ld(t){return"object"==typeof t&&null!=t&&t.outlets?t.outlets.primary:""+t}function ud(t,e,n){if(t||(t=new _h([],{})),0===t.segments.length&&t.hasChildren())return cd(t,e,n);const r=function(t,e,n){let r=0,s=e;const i={match:!1,pathIndex:0,commandIndex:0};for(;s<t.segments.length;){if(r>=n.length)return i;const e=t.segments[s],o=ld(n[r]),a=r<n.length-1?n[r+1]:null;if(s>0&&void 0===o)break;if(o&&a&&"object"==typeof a&&void 0===a.outlets){if(!fd(o,a,e))return i;r+=2}else{if(!fd(o,{},e))return i;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(t,e,n),s=n.slice(r.commandIndex);if(r.match&&r.pathIndex<t.segments.length){const e=new _h(t.segments.slice(0,r.pathIndex),{});return e.children.primary=new _h(t.segments.slice(r.pathIndex),t.children),cd(e,0,s)}return r.match&&0===s.length?new _h(t.segments,{}):r.match&&!t.hasChildren()?hd(t,e,n):r.match?cd(t,0,s):hd(t,e,n)}function cd(t,e,n){if(0===n.length)return new _h(t.segments,{});{const r=function(t){return"object"==typeof t[0]&&null!==t[0]&&t[0].outlets?t[0].outlets:{primary:t}}(n),s={};return xh(r,(n,r)=>{null!==n&&(s[r]=ud(t.children[r],e,n))}),xh(t.children,(t,e)=>{void 0===r[e]&&(s[e]=t)}),new _h(t.segments,s)}}function hd(t,e,n){const r=t.segments.slice(0,e);let s=0;for(;s<n.length;){if("object"==typeof n[s]&&null!==n[s]&&void 0!==n[s].outlets){const t=dd(n[s].outlets);return new _h(r,t)}if(0===s&&sd(n[0])){r.push(new Eh(t.segments[e].path,n[0])),s++;continue}const i=ld(n[s]),o=s<n.length-1?n[s+1]:null;i&&o&&sd(o)?(r.push(new Eh(i,pd(o))),s+=2):(r.push(new Eh(i,{})),s++)}return new _h(r,{})}function dd(t){const e={};return xh(t,(t,n)=>{null!==t&&(e[n]=hd(new _h([],{}),0,t))}),e}function pd(t){const e={};return xh(t,(t,n)=>e[n]=""+t),e}function fd(t,e,n){return t==n.path&&gh(e,n.parameters)}class md{constructor(t,e,n,r){this.routeReuseStrategy=t,this.futureState=e,this.currState=n,this.forwardEvent=r}activate(t){const e=this.futureState._root,n=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,n,t),nd(this.futureState.root),this.activateChildRoutes(e,n,t)}deactivateChildRoutes(t,e,n){const r=Gh(e);t.children.forEach(t=>{const e=t.value.outlet;this.deactivateRoutes(t,r[e],n),delete r[e]}),xh(r,(t,e)=>{this.deactivateRouteAndItsChildren(t,n)})}deactivateRoutes(t,e,n){const r=t.value,s=e?e.value:null;if(r===s)if(r.component){const s=n.getContext(r.outlet);s&&this.deactivateChildRoutes(t,e,s.children)}else this.deactivateChildRoutes(t,e,n);else s&&this.deactivateRouteAndItsChildren(e,n)}deactivateRouteAndItsChildren(t,e){this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const n=e.getContext(t.value.outlet);if(n&&n.outlet){const e=n.outlet.detach(),r=n.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:e,route:t,contexts:r})}}deactivateRouteAndOutlet(t,e){const n=e.getContext(t.value.outlet);if(n){const r=Gh(t),s=t.value.component?n.children:e;xh(r,(t,e)=>this.deactivateRouteAndItsChildren(t,s)),n.outlet&&(n.outlet.deactivate(),n.children.onOutletDeactivated())}}activateChildRoutes(t,e,n){const r=Gh(e);t.children.forEach(t=>{this.activateRoutes(t,r[t.value.outlet],n),this.forwardEvent(new sh(t.value.snapshot))}),t.children.length&&this.forwardEvent(new nh(t.value.snapshot))}activateRoutes(t,e,n){const r=t.value,s=e?e.value:null;if(nd(r),r===s)if(r.component){const s=n.getOrCreateContext(r.outlet);this.activateChildRoutes(t,e,s.children)}else this.activateChildRoutes(t,e,n);else if(r.component){const e=n.getOrCreateContext(r.outlet);if(this.routeReuseStrategy.shouldAttach(r.snapshot)){const t=this.routeReuseStrategy.retrieve(r.snapshot);this.routeReuseStrategy.store(r.snapshot,null),e.children.onOutletReAttached(t.contexts),e.attachRef=t.componentRef,e.route=t.route.value,e.outlet&&e.outlet.attach(t.componentRef,t.route.value),gd(t.route)}else{const n=function(t){for(let e=t.parent;e;e=e.parent){const t=e.routeConfig;if(t&&t._loadedConfig)return t._loadedConfig;if(t&&t.component)return null}return null}(r.snapshot),s=n?n.module.componentFactoryResolver:null;e.attachRef=null,e.route=r,e.resolver=s,e.outlet&&e.outlet.activateWith(r,s),this.activateChildRoutes(t,null,e.children)}}else this.activateChildRoutes(t,null,n)}}function gd(t){nd(t.value),t.children.forEach(gd)}function yd(t){return"function"==typeof t}function bd(t){return t instanceof Sh}class vd{constructor(t){this.segmentGroup=t||null}}class xd{constructor(t){this.urlTree=t}}function wd(t){return new J(e=>e.error(new vd(t)))}function Cd(t){return new J(e=>e.error(new xd(t)))}function Sd(t){return new J(e=>e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`)))}class _d{constructor(t,e,n,r,s){this.configLoader=e,this.urlSerializer=n,this.urlTree=r,this.config=s,this.allowRedirects=!0,this.ngModule=t.get(Ne)}apply(){return this.expandSegmentGroup(this.ngModule,this.config,this.urlTree.root,"primary").pipe(mt(t=>this.createUrlTree(t,this.urlTree.queryParams,this.urlTree.fragment))).pipe(wc(t=>{if(t instanceof xd)return this.allowRedirects=!1,this.match(t.urlTree);if(t instanceof vd)throw this.noMatchError(t);throw t}))}match(t){return this.expandSegmentGroup(this.ngModule,this.config,t.root,"primary").pipe(mt(e=>this.createUrlTree(e,t.queryParams,t.fragment))).pipe(wc(t=>{if(t instanceof vd)throw this.noMatchError(t);throw t}))}noMatchError(t){return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`)}createUrlTree(t,e,n){const r=t.segments.length>0?new _h([],{primary:t}):t;return new Sh(r,e,n)}expandSegmentGroup(t,e,n,r){return 0===n.segments.length&&n.hasChildren()?this.expandChildren(t,e,n).pipe(mt(t=>new _h([],t))):this.expandSegment(t,n,e,n.segments,r,!0)}expandChildren(t,e,n){return function(t,e){if(0===Object.keys(t).length)return Zu({});const n=[],r=[],s={};return xh(t,(t,i)=>{const o=e(i,t).pipe(mt(t=>s[i]=t));"primary"===i?n.push(o):r.push(o)}),Zu.apply(null,n.concat(r)).pipe(oc(),function(t,e){const n=arguments.length>=2;return r=>r.pipe(t?ac((e,n)=>t(e,n,r)):Z,hc(1),n?bc(e):fc(()=>new Qu))}(),mt(()=>s))}(n.children,(n,r)=>this.expandSegmentGroup(t,e,r,n))}expandSegment(t,e,n,r,s,i){return Zu(...n).pipe(mt(o=>this.expandSegmentAgainstRoute(t,e,n,o,r,s,i).pipe(wc(t=>{if(t instanceof vd)return Zu(null);throw t}))),oc(),Ac(t=>!!t),wc((t,n)=>{if(t instanceof Qu||"EmptyError"===t.name){if(this.noLeftoversInUrl(e,r,s))return Zu(new _h([],{}));throw new vd(e)}throw t}))}noLeftoversInUrl(t,e,n){return 0===e.length&&!t.children[n]}expandSegmentAgainstRoute(t,e,n,r,s,i,o){return Id(r)!==i?wd(e):void 0===r.redirectTo?this.matchSegmentAgainstRoute(t,e,r,s):o&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,e,n,r,s,i):wd(e)}expandSegmentAgainstRouteUsingRedirect(t,e,n,r,s,i){return"**"===r.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,n,r,i):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,n,r,s,i)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,n,r){const s=this.applyRedirectCommands([],n.redirectTo,{});return n.redirectTo.startsWith("/")?Cd(s):this.lineralizeSegments(n,s).pipe(xt(n=>{const s=new _h(n,{});return this.expandSegment(t,s,e,n,r,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,n,r,s,i){const{matched:o,consumedSegments:a,lastChild:l,positionalParamSegments:u}=Ed(e,r,s);if(!o)return wd(e);const c=this.applyRedirectCommands(a,r.redirectTo,u);return r.redirectTo.startsWith("/")?Cd(c):this.lineralizeSegments(r,c).pipe(xt(r=>this.expandSegment(t,e,n,r.concat(s.slice(l)),i,!1)))}matchSegmentAgainstRoute(t,e,n,r){if("**"===n.path)return n.loadChildren?this.configLoader.load(t.injector,n).pipe(mt(t=>(n._loadedConfig=t,new _h(r,{})))):Zu(new _h(r,{}));const{matched:s,consumedSegments:i,lastChild:o}=Ed(e,n,r);if(!s)return wd(e);const a=r.slice(o);return this.getChildConfig(t,n,r).pipe(xt(t=>{const n=t.module,r=t.routes,{segmentGroup:s,slicedSegments:o}=function(t,e,n,r){return n.length>0&&function(t,e,n){return n.some(n=>Ad(t,e,n)&&"primary"!==Id(n))}(t,n,r)?{segmentGroup:kd(new _h(e,function(t,e){const n={};n.primary=e;for(const r of t)""===r.path&&"primary"!==Id(r)&&(n[Id(r)]=new _h([],{}));return n}(r,new _h(n,t.children)))),slicedSegments:[]}:0===n.length&&function(t,e,n){return n.some(n=>Ad(t,e,n))}(t,n,r)?{segmentGroup:kd(new _h(t.segments,function(t,e,n,r){const s={};for(const i of n)Ad(t,e,i)&&!r[Id(i)]&&(s[Id(i)]=new _h([],{}));return Object.assign(Object.assign({},r),s)}(t,n,r,t.children))),slicedSegments:n}:{segmentGroup:t,slicedSegments:n}}(e,i,a,r);return 0===o.length&&s.hasChildren()?this.expandChildren(n,r,s).pipe(mt(t=>new _h(i,t))):0===r.length&&0===o.length?Zu(new _h(i,{})):this.expandSegment(n,s,r,o,"primary",!0).pipe(mt(t=>new _h(i.concat(t.segments),t.children)))}))}getChildConfig(t,e,n){return e.children?Zu(new hh(e.children,t)):e.loadChildren?void 0!==e._loadedConfig?Zu(e._loadedConfig):this.runCanLoadGuards(t.injector,e,n).pipe(xt(n=>n?this.configLoader.load(t.injector,e).pipe(mt(t=>(e._loadedConfig=t,t))):function(t){return new J(e=>e.error(uh(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`)))}(e))):Zu(new hh([],t))}runCanLoadGuards(t,e,n){const r=e.canLoad;return r&&0!==r.length?vt(r).pipe(mt(r=>{const s=t.get(r);let i;if(function(t){return t&&yd(t.canLoad)}(s))i=s.canLoad(e,n);else{if(!yd(s))throw new Error("Invalid CanLoad guard");i=s(e,n)}return wh(i)})).pipe(oc(),Nc(t=>{if(!bd(t))return;const e=uh(`Redirecting to "${this.urlSerializer.serialize(t)}"`);throw e.url=t,e}),(s=t=>!0===t,t=>t.lift(new $c(s,void 0,t)))):Zu(!0);var s}lineralizeSegments(t,e){let n=[],r=e.root;for(;;){if(n=n.concat(r.segments),0===r.numberOfChildren)return Zu(n);if(r.numberOfChildren>1||!r.children.primary)return Sd(t.redirectTo);r=r.children.primary}}applyRedirectCommands(t,e,n){return this.applyRedirectCreatreUrlTree(e,this.urlSerializer.parse(e),t,n)}applyRedirectCreatreUrlTree(t,e,n,r){const s=this.createSegmentGroup(t,e.root,n,r);return new Sh(s,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const n={};return xh(t,(t,r)=>{if("string"==typeof t&&t.startsWith(":")){const s=t.substring(1);n[r]=e[s]}else n[r]=t}),n}createSegmentGroup(t,e,n,r){const s=this.createSegments(t,e.segments,n,r);let i={};return xh(e.children,(e,s)=>{i[s]=this.createSegmentGroup(t,e,n,r)}),new _h(s,i)}createSegments(t,e,n,r){return e.map(e=>e.path.startsWith(":")?this.findPosParam(t,e,r):this.findOrReturn(e,n))}findPosParam(t,e,n){const r=n[e.path.substring(1)];if(!r)throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`);return r}findOrReturn(t,e){let n=0;for(const r of e){if(r.path===t.path)return e.splice(n),r;n++}return t}}function Ed(t,e,n){if(""===e.path)return"full"===e.pathMatch&&(t.hasChildren()||n.length>0)?{matched:!1,consumedSegments:[],lastChild:0,positionalParamSegments:{}}:{matched:!0,consumedSegments:[],lastChild:0,positionalParamSegments:{}};const r=(e.matcher||ch)(n,t,e);return r?{matched:!0,consumedSegments:r.consumed,lastChild:r.consumed.length,positionalParamSegments:r.posParams}:{matched:!1,consumedSegments:[],lastChild:0,positionalParamSegments:{}}}function kd(t){if(1===t.numberOfChildren&&t.children.primary){const e=t.children.primary;return new _h(t.segments.concat(e.segments),e.children)}return t}function Ad(t,e,n){return(!(t.hasChildren()||e.length>0)||"full"!==n.pathMatch)&&""===n.path&&void 0!==n.redirectTo}function Id(t){return t.outlet||"primary"}class Nd{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class Td{constructor(t,e){this.component=t,this.route=e}}function Rd(t,e,n){const r=t._root;return function t(e,n,r,s,i={canDeactivateChecks:[],canActivateChecks:[]}){const o=Gh(n);return e.children.forEach(e=>{!function(e,n,r,s,i={canDeactivateChecks:[],canActivateChecks:[]}){const o=e.value,a=n?n.value:null,l=r?r.getContext(e.value.outlet):null;if(a&&o.routeConfig===a.routeConfig){const u=function(t,e,n){if("function"==typeof n)return n(t,e);switch(n){case"pathParamsChange":return!kh(t.url,e.url);case"pathParamsOrQueryParamsChange":return!kh(t.url,e.url)||!gh(t.queryParams,e.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!rd(t,e)||!gh(t.queryParams,e.queryParams);case"paramsChange":default:return!rd(t,e)}}(a,o,o.routeConfig.runGuardsAndResolvers);u?i.canActivateChecks.push(new Nd(s)):(o.data=a.data,o._resolvedData=a._resolvedData),t(e,n,o.component?l?l.children:null:r,s,i),u&&i.canDeactivateChecks.push(new Td(l&&l.outlet&&l.outlet.component||null,a))}else a&&Dd(n,l,i),i.canActivateChecks.push(new Nd(s)),t(e,null,o.component?l?l.children:null:r,s,i)}(e,o[e.value.outlet],r,s.concat([e.value]),i),delete o[e.value.outlet]}),xh(o,(t,e)=>Dd(t,r.getContext(e),i)),i}(r,e?e._root:null,n,[r.value])}function $d(t,e,n){const r=function(t){if(!t)return null;for(let e=t.parent;e;e=e.parent){const t=e.routeConfig;if(t&&t._loadedConfig)return t._loadedConfig}return null}(e);return(r?r.module.injector:n).get(t)}function Dd(t,e,n){const r=Gh(t),s=t.value;xh(r,(t,r)=>{Dd(t,s.component?e?e.children.getContext(r):null:e,n)}),n.canDeactivateChecks.push(new Td(s.component&&e&&e.outlet&&e.outlet.isActivated?e.outlet.component:null,s))}const Od=Symbol("INITIAL_VALUE");function Fd(){return Oc(t=>function(...t){let e=null,n=null;return it(t[t.length-1])&&(n=t.pop()),"function"==typeof t[t.length-1]&&(e=t.pop()),1===t.length&&U(t[0])&&(t=t[0]),_t(t,n).lift(new ec(e))}(...t.map(t=>t.pipe(_c(1),function(...t){const e=t[t.length-1];return it(e)?(t.pop(),n=>Lc(t,n,e)):e=>Lc(t,e)}(Od)))).pipe(function(t,e){let n=!1;return arguments.length>=2&&(n=!0),function(r){return r.lift(new Pc(t,e,n))}}((t,e)=>{let n=!1;return e.reduce((t,r,s)=>{if(t!==Od)return t;if(r===Od&&(n=!0),!n){if(!1===r)return r;if(s===e.length-1||bd(r))return r}return t},t)},Od),ac(t=>t!==Od),mt(t=>bd(t)?t:!0===t),_c(1)))}function Md(t,e){return null!==t&&e&&e(new rh(t)),Zu(!0)}function Ld(t,e){return null!==t&&e&&e(new eh(t)),Zu(!0)}function Pd(t,e,n){const r=e.routeConfig?e.routeConfig.canActivate:null;return r&&0!==r.length?Zu(r.map(r=>ic(()=>{const s=$d(r,e,n);let i;if(function(t){return t&&yd(t.canActivate)}(s))i=wh(s.canActivate(e,t));else{if(!yd(s))throw new Error("Invalid CanActivate guard");i=wh(s(e,t))}return i.pipe(Ac())}))).pipe(Fd()):Zu(!0)}function zd(t,e,n){const r=e[e.length-1],s=e.slice(0,e.length-1).reverse().map(t=>function(t){const e=t.routeConfig?t.routeConfig.canActivateChild:null;return e&&0!==e.length?{node:t,guards:e}:null}(t)).filter(t=>null!==t).map(e=>ic(()=>Zu(e.guards.map(s=>{const i=$d(s,e.node,n);let o;if(function(t){return t&&yd(t.canActivateChild)}(i))o=wh(i.canActivateChild(r,t));else{if(!yd(i))throw new Error("Invalid CanActivateChild guard");o=wh(i(r,t))}return o.pipe(Ac())})).pipe(Fd())));return Zu(s).pipe(Fd())}class Bd{}class Vd{constructor(t,e,n,r,s,i){this.rootComponentType=t,this.config=e,this.urlTree=n,this.url=r,this.paramsInheritanceStrategy=s,this.relativeLinkResolution=i}recognize(){try{const t=jd(this.urlTree.root,[],[],this.config,this.relativeLinkResolution).segmentGroup,e=this.processSegmentGroup(this.config,t,"primary"),n=new Jh([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},"primary",this.rootComponentType,null,this.urlTree.root,-1,{}),r=new qh(n,e),s=new Qh(this.url,r);return this.inheritParamsAndData(s._root),Zu(s)}catch(t){return new J(e=>e.error(t))}}inheritParamsAndData(t){const e=t.value,n=Zh(e,this.paramsInheritanceStrategy);e.params=Object.freeze(n.params),e.data=Object.freeze(n.data),t.children.forEach(t=>this.inheritParamsAndData(t))}processSegmentGroup(t,e,n){return 0===e.segments.length&&e.hasChildren()?this.processChildren(t,e):this.processSegment(t,e,e.segments,n)}processChildren(t,e){const n=Ah(e,(e,n)=>this.processSegmentGroup(t,e,n));return function(t){const e={};t.forEach(t=>{const n=e[t.value.outlet];if(n){const e=n.url.map(t=>t.toString()).join("/"),r=t.value.url.map(t=>t.toString()).join("/");throw new Error(`Two segments cannot have the same outlet name: '${e}' and '${r}'.`)}e[t.value.outlet]=t.value})}(n),n.sort((t,e)=>"primary"===t.value.outlet?-1:"primary"===e.value.outlet?1:t.value.outlet.localeCompare(e.value.outlet)),n}processSegment(t,e,n,r){for(const i of t)try{return this.processSegmentAgainstRoute(i,e,n,r)}catch(s){if(!(s instanceof Bd))throw s}if(this.noLeftoversInUrl(e,n,r))return[];throw new Bd}noLeftoversInUrl(t,e,n){return 0===e.length&&!t.children[n]}processSegmentAgainstRoute(t,e,n,r){if(t.redirectTo)throw new Bd;if((t.outlet||"primary")!==r)throw new Bd;let s,i=[],o=[];if("**"===t.path){const i=n.length>0?vh(n).parameters:{};s=new Jh(n,i,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Gd(t),r,t.component,t,Ud(e),Wd(e)+n.length,Kd(t))}else{const a=function(t,e,n){if(""===e.path){if("full"===e.pathMatch&&(t.hasChildren()||n.length>0))throw new Bd;return{consumedSegments:[],lastChild:0,parameters:{}}}const r=(e.matcher||ch)(n,t,e);if(!r)throw new Bd;const s={};xh(r.posParams,(t,e)=>{s[e]=t.path});const i=r.consumed.length>0?Object.assign(Object.assign({},s),r.consumed[r.consumed.length-1].parameters):s;return{consumedSegments:r.consumed,lastChild:r.consumed.length,parameters:i}}(e,t,n);i=a.consumedSegments,o=n.slice(a.lastChild),s=new Jh(i,a.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Gd(t),r,t.component,t,Ud(e),Wd(e)+i.length,Kd(t))}const a=function(t){return t.children?t.children:t.loadChildren?t._loadedConfig.routes:[]}(t),{segmentGroup:l,slicedSegments:u}=jd(e,i,o,a,this.relativeLinkResolution);if(0===u.length&&l.hasChildren()){const t=this.processChildren(a,l);return[new qh(s,t)]}if(0===a.length&&0===u.length)return[new qh(s,[])];const c=this.processSegment(a,l,u,"primary");return[new qh(s,c)]}}function Ud(t){let e=t;for(;e._sourceSegment;)e=e._sourceSegment;return e}function Wd(t){let e=t,n=e._segmentIndexShift?e._segmentIndexShift:0;for(;e._sourceSegment;)e=e._sourceSegment,n+=e._segmentIndexShift?e._segmentIndexShift:0;return n-1}function jd(t,e,n,r,s){if(n.length>0&&function(t,e,n){return n.some(n=>Hd(t,e,n)&&"primary"!==qd(n))}(t,n,r)){const s=new _h(e,function(t,e,n,r){const s={};s.primary=r,r._sourceSegment=t,r._segmentIndexShift=e.length;for(const i of n)if(""===i.path&&"primary"!==qd(i)){const n=new _h([],{});n._sourceSegment=t,n._segmentIndexShift=e.length,s[qd(i)]=n}return s}(t,e,r,new _h(n,t.children)));return s._sourceSegment=t,s._segmentIndexShift=e.length,{segmentGroup:s,slicedSegments:[]}}if(0===n.length&&function(t,e,n){return n.some(n=>Hd(t,e,n))}(t,n,r)){const i=new _h(t.segments,function(t,e,n,r,s,i){const o={};for(const a of r)if(Hd(t,n,a)&&!s[qd(a)]){const n=new _h([],{});n._sourceSegment=t,n._segmentIndexShift="legacy"===i?t.segments.length:e.length,o[qd(a)]=n}return Object.assign(Object.assign({},s),o)}(t,e,n,r,t.children,s));return i._sourceSegment=t,i._segmentIndexShift=e.length,{segmentGroup:i,slicedSegments:n}}const i=new _h(t.segments,t.children);return i._sourceSegment=t,i._segmentIndexShift=e.length,{segmentGroup:i,slicedSegments:n}}function Hd(t,e,n){return(!(t.hasChildren()||e.length>0)||"full"!==n.pathMatch)&&""===n.path&&void 0===n.redirectTo}function qd(t){return t.outlet||"primary"}function Gd(t){return t.data||{}}function Kd(t){return t.resolve||{}}function Xd(t){return function(e){return e.pipe(Oc(e=>{const n=t(e);return n?vt(n).pipe(mt(()=>e)):vt([e])}))}}class Yd{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}const Zd=new me("ROUTES");class Jd{constructor(t,e,n,r){this.loader=t,this.compiler=e,this.onLoadStartListener=n,this.onLoadEndListener=r}load(t,e){return this.onLoadStartListener&&this.onLoadStartListener(e),this.loadModuleFactory(e.loadChildren).pipe(mt(n=>{this.onLoadEndListener&&this.onLoadEndListener(e);const r=n.create(t);return new hh(bh(r.injector.get(Zd)).map(mh),r)}))}loadModuleFactory(t){return"string"==typeof t?vt(this.loader.load(t)):wh(t()).pipe(xt(t=>t instanceof Te?Zu(t):vt(this.compiler.compileModuleAsync(t))))}}class Qd{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new tp,this.attachRef=null}}class tp{constructor(){this.contexts=new Map}onChildOutletCreated(t,e){const n=this.getOrCreateContext(t);n.outlet=e,this.contexts.set(t,n)}onChildOutletDestroyed(t){const e=this.getContext(t);e&&(e.outlet=null)}onOutletDeactivated(){const t=this.contexts;return this.contexts=new Map,t}onOutletReAttached(t){this.contexts=t}getOrCreateContext(t){let e=this.getContext(t);return e||(e=new Qd,this.contexts.set(t,e)),e}getContext(t){return this.contexts.get(t)||null}}class ep{shouldProcessUrl(t){return!0}extract(t){return t}merge(t,e){return t}}function np(t){throw t}function rp(t,e,n){return e.parse("/")}function sp(t,e){return Zu(null)}let ip=(()=>{class t{constructor(t,e,n,r,s,i,o,a){this.rootComponentType=t,this.urlSerializer=e,this.rootContexts=n,this.location=r,this.config=a,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.navigationId=0,this.isNgZoneEnabled=!1,this.events=new rt,this.errorHandler=np,this.malformedUriErrorHandler=rp,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:sp,afterPreactivation:sp},this.urlHandlingStrategy=new ep,this.routeReuseStrategy=new Yd,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="legacy",this.ngModule=s.get(Ne),this.console=s.get(ul);const l=s.get(Cl);this.isNgZoneEnabled=l instanceof Cl,this.resetConfig(a),this.currentUrlTree=new Sh(new _h([],{}),{},null),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new Jd(i,o,t=>this.triggerEvent(new Qc(t)),t=>this.triggerEvent(new th(t))),this.routerState=Xh(this.currentUrlTree,this.rootComponentType),this.transitions=new Ju({id:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}setupNavigations(t){const e=this.events;return t.pipe(ac(t=>0!==t.id),mt(t=>Object.assign(Object.assign({},t),{extractedUrl:this.urlHandlingStrategy.extract(t.rawUrl)})),Oc(t=>{let n=!1,r=!1;return Zu(t).pipe(Nc(t=>{this.currentNavigation={id:t.id,initialUrl:t.currentRawUrl,extractedUrl:t.extractedUrl,trigger:t.source,extras:t.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),Oc(t=>{const n=!this.navigated||t.extractedUrl.toString()!==this.browserUrlTree.toString();if(("reload"===this.onSameUrlNavigation||n)&&this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl))return Zu(t).pipe(Oc(t=>{const n=this.transitions.getValue();return e.next(new jc(t.id,this.serializeUrl(t.extractedUrl),t.source,t.restoredState)),n!==this.transitions.getValue()?rc:[t]}),Oc(t=>Promise.resolve(t)),(r=this.ngModule.injector,s=this.configLoader,i=this.urlSerializer,o=this.config,function(t){return t.pipe(Oc(t=>function(t,e,n,r,s){return new _d(t,e,n,r,s).apply()}(r,s,i,t.extractedUrl,o).pipe(mt(e=>Object.assign(Object.assign({},t),{urlAfterRedirects:e})))))}),Nc(t=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:t.urlAfterRedirects})}),function(t,e,n,r,s){return function(i){return i.pipe(xt(i=>function(t,e,n,r,s="emptyOnly",i="legacy"){return new Vd(t,e,n,r,s,i).recognize()}(t,e,i.urlAfterRedirects,n(i.urlAfterRedirects),r,s).pipe(mt(t=>Object.assign(Object.assign({},i),{targetSnapshot:t})))))}}(this.rootComponentType,this.config,t=>this.serializeUrl(t),this.paramsInheritanceStrategy,this.relativeLinkResolution),Nc(t=>{"eager"===this.urlUpdateStrategy&&(t.extras.skipLocationChange||this.setBrowserUrl(t.urlAfterRedirects,!!t.extras.replaceUrl,t.id,t.extras.state),this.browserUrlTree=t.urlAfterRedirects)}),Nc(t=>{const n=new Kc(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);e.next(n)}));var r,s,i,o;if(n&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:n,extractedUrl:r,source:s,restoredState:i,extras:o}=t,a=new jc(n,this.serializeUrl(r),s,i);e.next(a);const l=Xh(r,this.rootComponentType).snapshot;return Zu(Object.assign(Object.assign({},t),{targetSnapshot:l,urlAfterRedirects:r,extras:Object.assign(Object.assign({},o),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=t.rawUrl,this.browserUrlTree=t.urlAfterRedirects,t.resolve(null),rc}),Xd(t=>{const{targetSnapshot:e,id:n,extractedUrl:r,rawUrl:s,extras:{skipLocationChange:i,replaceUrl:o}}=t;return this.hooks.beforePreactivation(e,{navigationId:n,appliedUrlTree:r,rawUrlTree:s,skipLocationChange:!!i,replaceUrl:!!o})}),Nc(t=>{const e=new Xc(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}),mt(t=>Object.assign(Object.assign({},t),{guards:Rd(t.targetSnapshot,t.currentSnapshot,this.rootContexts)})),function(t,e){return function(n){return n.pipe(xt(n=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:i,canDeactivateChecks:o}}=n;return 0===o.length&&0===i.length?Zu(Object.assign(Object.assign({},n),{guardsResult:!0})):function(t,e,n,r){return vt(t).pipe(xt(t=>function(t,e,n,r,s){const i=e&&e.routeConfig?e.routeConfig.canDeactivate:null;return i&&0!==i.length?Zu(i.map(i=>{const o=$d(i,e,s);let a;if(function(t){return t&&yd(t.canDeactivate)}(o))a=wh(o.canDeactivate(t,e,n,r));else{if(!yd(o))throw new Error("Invalid CanDeactivate guard");a=wh(o(t,e,n,r))}return a.pipe(Ac())})).pipe(Fd()):Zu(!0)}(t.component,t.route,n,e,r)),Ac(t=>!0!==t,!0))}(o,r,s,t).pipe(xt(n=>n&&"boolean"==typeof n?function(t,e,n,r){return vt(e).pipe(Bc(e=>vt([Ld(e.route.parent,r),Md(e.route,r),zd(t,e.path,n),Pd(t,e.route,n)]).pipe(oc(),Ac(t=>!0!==t,!0))),Ac(t=>!0!==t,!0))}(r,i,t,e):Zu(n)),mt(t=>Object.assign(Object.assign({},n),{guardsResult:t})))}))}}(this.ngModule.injector,t=>this.triggerEvent(t)),Nc(t=>{if(bd(t.guardsResult)){const e=uh(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`);throw e.url=t.guardsResult,e}}),Nc(t=>{const e=new Yc(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot,!!t.guardsResult);this.triggerEvent(e)}),ac(t=>{if(!t.guardsResult){this.resetUrlToCurrentUrlTree();const n=new qc(t.id,this.serializeUrl(t.extractedUrl),"");return e.next(n),t.resolve(!1),!1}return!0}),Xd(t=>{if(t.guards.canActivateChecks.length)return Zu(t).pipe(Nc(t=>{const e=new Zc(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}),Oc(t=>{let n=!1;return Zu(t).pipe((r=this.paramsInheritanceStrategy,s=this.ngModule.injector,function(t){return t.pipe(xt(t=>{const{targetSnapshot:e,guards:{canActivateChecks:n}}=t;if(!n.length)return Zu(t);let i=0;return vt(n).pipe(Bc(t=>function(t,e,n,r){return function(t,e,n,r){const s=Object.keys(t);if(0===s.length)return Zu({});const i={};return vt(s).pipe(xt(s=>function(t,e,n,r){const s=$d(t,e,r);return wh(s.resolve?s.resolve(e,n):s(e,n))}(t[s],e,n,r).pipe(Nc(t=>{i[s]=t}))),hc(1),xt(()=>Object.keys(i).length===s.length?Zu(i):rc))}(t._resolve,t,e,r).pipe(mt(e=>(t._resolvedData=e,t.data=Object.assign(Object.assign({},t.data),Zh(t,n).resolve),null)))}(t.route,e,r,s)),Nc(()=>i++),hc(1),xt(e=>i===n.length?Zu(t):rc))}))}),Nc({next:()=>n=!0,complete:()=>{if(!n){const n=new qc(t.id,this.serializeUrl(t.extractedUrl),"At least one route resolver didn't emit any value.");e.next(n),t.resolve(!1)}}}));var r,s}),Nc(t=>{const e=new Jc(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}))}),Xd(t=>{const{targetSnapshot:e,id:n,extractedUrl:r,rawUrl:s,extras:{skipLocationChange:i,replaceUrl:o}}=t;return this.hooks.afterPreactivation(e,{navigationId:n,appliedUrlTree:r,rawUrlTree:s,skipLocationChange:!!i,replaceUrl:!!o})}),mt(t=>{const e=function(t,e,n){const r=function t(e,n,r){if(r&&e.shouldReuseRoute(n.value,r.value.snapshot)){const s=r.value;s._futureSnapshot=n.value;const i=function(e,n,r){return n.children.map(n=>{for(const s of r.children)if(e.shouldReuseRoute(s.value.snapshot,n.value))return t(e,n,s);return t(e,n)})}(e,n,r);return new qh(s,i)}{const r=e.retrieve(n.value);if(r){const t=r.route;return function t(e,n){if(e.value.routeConfig!==n.value.routeConfig)throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route");if(e.children.length!==n.children.length)throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children");n.value._futureSnapshot=e.value;for(let r=0;r<e.children.length;++r)t(e.children[r],n.children[r])}(n,t),t}{const r=new Yh(new Ju((s=n.value).url),new Ju(s.params),new Ju(s.queryParams),new Ju(s.fragment),new Ju(s.data),s.outlet,s.component,s),i=n.children.map(n=>t(e,n));return new qh(r,i)}}var s}(t,e._root,n?n._root:void 0);return new Kh(r,e)}(this.routeReuseStrategy,t.targetSnapshot,t.currentRouterState);return Object.assign(Object.assign({},t),{targetRouterState:e})}),Nc(t=>{this.currentUrlTree=t.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,t.rawUrl),this.routerState=t.targetRouterState,"deferred"===this.urlUpdateStrategy&&(t.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,!!t.extras.replaceUrl,t.id,t.extras.state),this.browserUrlTree=t.urlAfterRedirects)}),(i=this.rootContexts,o=this.routeReuseStrategy,a=t=>this.triggerEvent(t),mt(t=>(new md(o,t.targetRouterState,t.currentRouterState,a).activate(i),t))),Nc({next(){n=!0},complete(){n=!0}}),(s=()=>{if(!n&&!r){this.resetUrlToCurrentUrlTree();const n=new qc(t.id,this.serializeUrl(t.extractedUrl),`Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`);e.next(n),t.resolve(!1)}this.currentNavigation=null},t=>t.lift(new Vc(s))),wc(n=>{if(r=!0,(s=n)&&s.ngNavigationCancelingError){const r=bd(n.url);r||(this.navigated=!0,this.resetStateAndUrl(t.currentRouterState,t.currentUrlTree,t.rawUrl));const s=new qc(t.id,this.serializeUrl(t.extractedUrl),n.message);e.next(s),r?setTimeout(()=>{const e=this.urlHandlingStrategy.merge(n.url,this.rawUrlTree);return this.scheduleNavigation(e,"imperative",null,{skipLocationChange:t.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy},{resolve:t.resolve,reject:t.reject,promise:t.promise})},0):t.resolve(!1)}else{this.resetStateAndUrl(t.currentRouterState,t.currentUrlTree,t.rawUrl);const r=new Gc(t.id,this.serializeUrl(t.extractedUrl),n);e.next(r);try{t.resolve(this.errorHandler(n))}catch(i){t.reject(i)}}var s;return rc}));var s,i,o,a}))}resetRootComponentType(t){this.rootComponentType=t,this.routerState.root.component=this.rootComponentType}getTransition(){const t=this.transitions.value;return t.urlAfterRedirects=this.browserUrlTree,t}setTransition(t){this.transitions.next(Object.assign(Object.assign({},this.getTransition()),t))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(t=>{let e=this.parseUrl(t.url);const n="popstate"===t.type?"popstate":"hashchange",r=t.state&&t.state.navigationId?t.state:null;setTimeout(()=>{this.scheduleNavigation(e,n,r,{replaceUrl:!0})},0)}))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(t){this.events.next(t)}resetConfig(t){dh(t),this.config=t.map(mh),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=null)}createUrlTree(t,e={}){const{relativeTo:n,queryParams:r,fragment:s,preserveQueryParams:i,queryParamsHandling:o,preserveFragment:a}=e;qr()&&i&&console&&console.warn&&console.warn("preserveQueryParams is deprecated, use queryParamsHandling instead.");const l=n||this.routerState.root,u=a?this.currentUrlTree.fragment:s;let c=null;if(o)switch(o){case"merge":c=Object.assign(Object.assign({},this.currentUrlTree.queryParams),r);break;case"preserve":c=this.currentUrlTree.queryParams;break;default:c=r||null}else c=i?this.currentUrlTree.queryParams:r||null;return null!==c&&(c=this.removeEmptyProps(c)),function(t,e,n,r,s){if(0===n.length)return id(e.root,e.root,e,r,s);const i=function(t){if("string"==typeof t[0]&&1===t.length&&"/"===t[0])return new od(!0,0,t);let e=0,n=!1;const r=t.reduce((t,r,s)=>{if("object"==typeof r&&null!=r){if(r.outlets){const e={};return xh(r.outlets,(t,n)=>{e[n]="string"==typeof t?t.split("/"):t}),[...t,{outlets:e}]}if(r.segmentPath)return[...t,r.segmentPath]}return"string"!=typeof r?[...t,r]:0===s?(r.split("/").forEach((r,s)=>{0==s&&"."===r||(0==s&&""===r?n=!0:".."===r?e++:""!=r&&t.push(r))}),t):[...t,r]},[]);return new od(n,e,r)}(n);if(i.toRoot())return id(e.root,new _h([],{}),e,r,s);const o=function(t,e,n){if(t.isAbsolute)return new ad(e.root,!0,0);if(-1===n.snapshot._lastPathIndex){const t=n.snapshot._urlSegment;return new ad(t,t===e.root,0)}const r=sd(t.commands[0])?0:1;return function(t,e,n){let r=t,s=e,i=n;for(;i>s;){if(i-=s,r=r.parent,!r)throw new Error("Invalid number of '../'");s=r.segments.length}return new ad(r,!1,s-i)}(n.snapshot._urlSegment,n.snapshot._lastPathIndex+r,t.numberOfDoubleDots)}(i,e,t),a=o.processChildren?cd(o.segmentGroup,o.index,i.commands):ud(o.segmentGroup,o.index,i.commands);return id(o.segmentGroup,a,e,r,s)}(l,this.currentUrlTree,t,c,u)}navigateByUrl(t,e={skipLocationChange:!1}){qr()&&this.isNgZoneEnabled&&!Cl.isInAngularZone()&&this.console.warn("Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?");const n=bd(t)?t:this.parseUrl(t),r=this.urlHandlingStrategy.merge(n,this.rawUrlTree);return this.scheduleNavigation(r,"imperative",null,e)}navigate(t,e={skipLocationChange:!1}){return function(t){for(let e=0;e<t.length;e++){const n=t[e];if(null==n)throw new Error(`The requested path contains ${n} segment at index ${e}`)}}(t),this.navigateByUrl(this.createUrlTree(t,e),e)}serializeUrl(t){return this.urlSerializer.serialize(t)}parseUrl(t){let e;try{e=this.urlSerializer.parse(t)}catch(n){e=this.malformedUriErrorHandler(n,this.urlSerializer,t)}return e}isActive(t,e){if(bd(t))return Ch(this.currentUrlTree,t,e);const n=this.parseUrl(t);return Ch(this.currentUrlTree,n,e)}removeEmptyProps(t){return Object.keys(t).reduce((e,n)=>{const r=t[n];return null!=r&&(e[n]=r),e},{})}processNavigations(){this.navigations.subscribe(t=>{this.navigated=!0,this.lastSuccessfulId=t.id,this.events.next(new Hc(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,this.currentNavigation=null,t.resolve(!0)},t=>{this.console.warn("Unhandled Navigation Error: ")})}scheduleNavigation(t,e,n,r,s){const i=this.getTransition();if(i&&"imperative"!==e&&"imperative"===i.source&&i.rawUrl.toString()===t.toString())return Promise.resolve(!0);if(i&&"hashchange"==e&&"popstate"===i.source&&i.rawUrl.toString()===t.toString())return Promise.resolve(!0);if(i&&"popstate"==e&&"hashchange"===i.source&&i.rawUrl.toString()===t.toString())return Promise.resolve(!0);let o,a,l;s?(o=s.resolve,a=s.reject,l=s.promise):l=new Promise((t,e)=>{o=t,a=e});const u=++this.navigationId;return this.setTransition({id:u,source:e,restoredState:n,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:t,extras:r,resolve:o,reject:a,promise:l,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),l.catch(t=>Promise.reject(t))}setBrowserUrl(t,e,n,r){const s=this.urlSerializer.serialize(t);r=r||{},this.location.isCurrentPathEqualTo(s)||e?this.location.replaceState(s,"",Object.assign(Object.assign({},r),{navigationId:n})):this.location.go(s,"",Object.assign(Object.assign({},r),{navigationId:n}))}resetStateAndUrl(t,e,n){this.routerState=t,this.currentUrlTree=e,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,n),this.resetUrlToCurrentUrlTree()}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",{navigationId:this.lastSuccessfulId})}}return t.\u0275fac=function(e){return new(e||t)(Ee(Di),Ee(Ih),Ee(tp),Ee(fu),Ee(Ki),Ee(Wl),Ee(vl),Ee(void 0))},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})(),op=(()=>{class t{constructor(t,e,n,r,s){this.parentContexts=t,this.location=e,this.resolver=n,this.changeDetector=s,this.activated=null,this._activatedRoute=null,this.activateEvents=new Wa,this.deactivateEvents=new Wa,this.name=r||"primary",t.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const t=this.parentContexts.getContext(this.name);t&&t.route&&(t.attachRef?this.attach(t.attachRef,t.route):this.activateWith(t.route,t.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const t=this.activated;return this.activated=null,this._activatedRoute=null,t}attach(t,e){this.activated=t,this._activatedRoute=e,this.location.insert(t.hostView)}deactivate(){if(this.activated){const t=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(t)}}activateWith(t,e){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=t;const n=(e=e||this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component),r=this.parentContexts.getOrCreateContext(this.name).children,s=new ap(t,r,this.location.injector);this.activated=this.location.createComponent(n,this.location.length,s),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return t.\u0275fac=function(e){return new(e||t)(ro(tp),ro(Ea),ro(Jo),("name",function(t,e){const n=t.attrs;if(n){const t=n.length;let e=0;for(;e<t;){const r=n[e];if(ur(r))break;if(0===r)e+=2;else if("number"==typeof r)for(e++;e<t&&"string"==typeof n[e];)e++;else{if("name"===r)return n[e+1];e+=2}}}return null}(Rn())),ro(Ri))},t.\u0275dir=Xe({type:t,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate"},exportAs:["outlet"]}),t})();class ap{constructor(t,e,n){this.route=t,this.childContexts=e,this.parent=n}get(t,e){return t===Yh?this.route:t===tp?this.childContexts:this.parent.get(t,e)}}class lp{}class up{preload(t,e){return Zu(null)}}let cp=(()=>{class t{constructor(t,e,n,r,s){this.router=t,this.injector=r,this.preloadingStrategy=s,this.loader=new Jd(e,n,e=>t.triggerEvent(new Qc(e)),e=>t.triggerEvent(new th(e)))}setUpPreloading(){this.subscription=this.router.events.pipe(ac(t=>t instanceof Hc),Bc(()=>this.preload())).subscribe(()=>{})}preload(){const t=this.injector.get(Ne);return this.processRoutes(t,this.router.config)}ngOnDestroy(){this.subscription.unsubscribe()}processRoutes(t,e){const n=[];for(const r of e)if(r.loadChildren&&!r.canLoad&&r._loadedConfig){const t=r._loadedConfig;n.push(this.processRoutes(t.module,t.routes))}else r.loadChildren&&!r.canLoad?n.push(this.preloadConfig(t,r)):r.children&&n.push(this.processRoutes(t,r.children));return vt(n).pipe(St(),mt(t=>{}))}preloadConfig(t,e){return this.preloadingStrategy.preload(e,()=>this.loader.load(t.injector,e).pipe(xt(t=>(e._loadedConfig=t,this.processRoutes(t.module,t.routes)))))}}return t.\u0275fac=function(e){return new(e||t)(Ee(ip),Ee(Wl),Ee(vl),Ee(Ki),Ee(lp))},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})(),hp=(()=>{class t{constructor(t,e,n={}){this.router=t,this.viewportScroller=e,this.options=n,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},n.scrollPositionRestoration=n.scrollPositionRestoration||"disabled",n.anchorScrolling=n.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(t=>{t instanceof jc?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=t.navigationTrigger,this.restoredId=t.restoredState?t.restoredState.navigationId:0):t instanceof Hc&&(this.lastId=t.id,this.scheduleScrollEvent(t,this.router.parseUrl(t.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(t=>{t instanceof ih&&(t.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(t.position):t.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(t.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(t,e){this.router.triggerEvent(new ih(t,"popstate"===this.lastSource?this.store[this.restoredId]:null,e))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return t.\u0275fac=function(e){return new(e||t)(Ee(ip),Ee(wu),Ee(void 0))},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})();const dp=new me("ROUTER_CONFIGURATION"),pp=new me("ROUTER_FORROOT_GUARD"),fp=[fu,{provide:Ih,useClass:Nh},{provide:ip,useFactory:function(t,e,n,r,s,i,o,a={},l,u){const c=new ip(null,t,e,n,r,s,i,bh(o));if(l&&(c.urlHandlingStrategy=l),u&&(c.routeReuseStrategy=u),a.errorHandler&&(c.errorHandler=a.errorHandler),a.malformedUriErrorHandler&&(c.malformedUriErrorHandler=a.malformedUriErrorHandler),a.enableTracing){const t=Jl();c.events.subscribe(e=>{t.logGroup("Router Event: "+e.constructor.name),t.log(e.toString()),t.log(e),t.logGroupEnd()})}return a.onSameUrlNavigation&&(c.onSameUrlNavigation=a.onSameUrlNavigation),a.paramsInheritanceStrategy&&(c.paramsInheritanceStrategy=a.paramsInheritanceStrategy),a.urlUpdateStrategy&&(c.urlUpdateStrategy=a.urlUpdateStrategy),a.relativeLinkResolution&&(c.relativeLinkResolution=a.relativeLinkResolution),c},deps:[Ih,tp,fu,Ki,Wl,vl,Zd,dp,[class{},new Ft],[class{},new Ft]]},tp,{provide:Yh,useFactory:function(t){return t.routerState.root},deps:[ip]},{provide:Wl,useClass:ql},cp,up,class{preload(t,e){return e().pipe(wc(()=>Zu(null)))}},{provide:dp,useValue:{enableTracing:!1}}];function mp(){return new Ml("Router",ip)}let gp=(()=>{class t{constructor(t,e){}static forRoot(e,n){return{ngModule:t,providers:[fp,xp(e),{provide:pp,useFactory:vp,deps:[[ip,new Ft,new Lt]]},{provide:dp,useValue:n||{}},{provide:uu,useFactory:bp,deps:[tu,[new Ot(hu),new Ft],dp]},{provide:hp,useFactory:yp,deps:[ip,wu,dp]},{provide:lp,useExisting:n&&n.preloadingStrategy?n.preloadingStrategy:up},{provide:Ml,multi:!0,useFactory:mp},[wp,{provide:el,multi:!0,useFactory:Cp,deps:[wp]},{provide:_p,useFactory:Sp,deps:[wp]},{provide:ll,multi:!0,useExisting:_p}]]}}static forChild(e){return{ngModule:t,providers:[xp(e)]}}}return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)(Ee(pp,8),Ee(ip,8))}}),t})();function yp(t,e,n){return n.scrollOffset&&e.setOffset(n.scrollOffset),new hp(t,e,n)}function bp(t,e,n={}){return n.useHash?new pu(t,e):new du(t,e)}function vp(t){if(t)throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.");return"guarded"}function xp(t){return[{provide:Xi,multi:!0,useValue:t},{provide:Zd,multi:!0,useValue:t}]}let wp=(()=>{class t{constructor(t){this.injector=t,this.initNavigation=!1,this.resultOfPreactivationDone=new rt}appInitializer(){return this.injector.get(nu,Promise.resolve(null)).then(()=>{let t=null;const e=new Promise(e=>t=e),n=this.injector.get(ip),r=this.injector.get(dp);if(this.isLegacyDisabled(r)||this.isLegacyEnabled(r))t(!0);else if("disabled"===r.initialNavigation)n.setUpLocationChangeListener(),t(!0);else{if("enabled"!==r.initialNavigation)throw new Error(`Invalid initialNavigation options: '${r.initialNavigation}'`);n.hooks.afterPreactivation=()=>this.initNavigation?Zu(null):(this.initNavigation=!0,t(!0),this.resultOfPreactivationDone),n.initialNavigation()}return e})}bootstrapListener(t){const e=this.injector.get(dp),n=this.injector.get(cp),r=this.injector.get(hp),s=this.injector.get(ip),i=this.injector.get(Vl);t===i.components[0]&&(this.isLegacyEnabled(e)?s.initialNavigation():this.isLegacyDisabled(e)&&s.setUpLocationChangeListener(),n.setUpPreloading(),r.init(),s.resetRootComponentType(i.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}isLegacyEnabled(t){return"legacy_enabled"===t.initialNavigation||!0===t.initialNavigation||void 0===t.initialNavigation}isLegacyDisabled(t){return"legacy_disabled"===t.initialNavigation||!1===t.initialNavigation}}return t.\u0275fac=function(e){return new(e||t)(Ee(Ki))},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})();function Cp(t){return t.appInitializer.bind(t)}function Sp(t){return t.bootstrapListener.bind(t)}const _p=new me("Router Initializer"),Ep=[];let kp=(()=>{class t{}return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},imports:[[gp.forRoot(Ep)],gp]}),t})();function Ap(t,e,n,r){return new(n||(n=Promise))((function(s,i){function o(t){try{l(r.next(t))}catch(e){i(e)}}function a(t){try{l(r.throw(t))}catch(e){i(e)}}function l(t){var e;t.done?s(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(o,a)}l((r=r.apply(t,e||[])).next())}))}class Ip{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(e instanceof Promise)throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=function(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("="))),e}(this.global.location.search);"tfjsflags"in t&&t.tfjsflags.split(",").forEach(t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)})}}function Np(){return Rp}let Tp,Rp=null;function $p(){if(null==Tp){let t;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof global)t=global;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}Tp=t}return Tp}function Dp(t,e){const n=function(){const t=$p();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const Op=Dp("kernelRegistry",()=>new Map),Fp=Dp("gradRegistry",()=>new Map);function Mp(t,e){const n=Vp(t,e);return Op.get(n)}function Lp(t){return Fp.get(t)}function Pp(t){const e=Op.entries(),n=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[i,o]=s,[a]=i.split("_");a===t&&n.push(o)}return n}function zp(t){const{kernelName:e,backendName:n}=t,r=Vp(e,n);Op.has(r)&&console.warn(`The kernel '${e}' for backend '${n}' is already registered`),Op.set(r,t)}function Bp(t){const{kernelName:e}=t;Fp.has(e)&&console.warn(`Overriding the gradient for '${e}'`),Fp.set(e,t)}function Vp(t,e){return`${e}_${t}`}function Up(t){let e=t.length,n=0,r=0;for(;e>0;)r=Math.random()*e|0,e--,n=t[e],t[e]=t[r],t[r]=n}function Wp(t,e,n){return Math.max(t,Math.min(e,n))}function jp(t){return t%2==0?t:t+1}function Hp(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function qp(t,e){const n=Math.random();return e*n+(1-n)*t}function Gp(t,e){let n=0;for(let r=0;r<t.length;r++){const s=Number(t[r])-Number(e[r]);n+=s*s}return n}function Kp(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function Xp(t,e,n=""){Kp(tf(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function Yp(t){Kp(null!=t,()=>"The input to the tensor constructor must be a non-null value.")}function Zp(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||gf(t)&&!n)for(let r=0;r<t.length;++r)Zp(t[r],e,n);else e.push(t);return e}function Jp(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function Qp(t){return 0===t.length}function tf(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function ef(t){return t%1==0}function nf(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function rf(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function sf(t){const e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return Up(e),e}function of(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function af(t,e=(t=>0),n){return new Promise((r,s)=>{let i=0;const o=()=>{if(t())return void r();i++;const a=e(i);null!=n&&i>=n?s():setTimeout(o,a)};o()})}function lf(t,e){let n=1,r=-1;for(let i=0;i<t.length;++i)if(t[i]>=0)n*=t[i];else if(-1===t[i]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(t[i]<0)throw Error(`Shapes can not be < 0. Found ${t[i]} at dim ${i}`);if(-1===r){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const s=t.slice();return s[r]=e/n,s}function uf(t,e){const n=e.length;return Kp((t=null==t?e.map((t,e)=>e):[].concat(t)).every(t=>t>=-n&&t<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis `+t),Kp(t.every(t=>ef(t)),()=>"All values in axis param must be integers but got axis "+t),t.map(t=>t<0?n+t:t)}function cf(t,e){const n=[],r=[],s=null!=e&&Array.isArray(e)&&0===e.length,i=null==e||s?null:uf(e,t).sort();let o=0;for(let a=0;a<t.length;++a){if(null!=i){if(i[o]===a&&1!==t[a])throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(null==i[o]||i[o]>a)&&1===t[a]&&(n.push(t[a]),r.push(a)),i[o]<=a&&o++}1!==t[a]&&(n.push(t[a]),r.push(a))}return{newShape:n,keptDims:r}}function hf(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error("Unknown data type "+t);n=new Uint8Array(e)}return n}function df(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error("Unknown data type "+t);n=new Array(e)}return n}function pf(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function ff(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}function mf(t,e){return!("complex64"===e||"float32"===e&&"complex64"!==t||"int32"===e&&"float32"!==t&&"complex64"!==t||"bool"===e&&"bool"===t)}function gf(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function yf(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype "+t)}function bf(t){if(null==t)return 0;let e=0;return t.forEach(t=>e+=t.length),e}function vf(t){return"string"==typeof t||t instanceof String}function xf(t){return"boolean"==typeof t}function wf(t){return"number"==typeof t}function Cf(t){return Array.isArray(t)?Cf(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":wf(t)?"float32":vf(t)?"string":xf(t)?"bool":"float32"}function Sf(t){return!!(t&&t.constructor&&t.call&&t.apply)}function _f(t,e){for(let n=e;n<t;++n)if(t%n==0)return n;return t}function Ef(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function kf(t,e,n){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=Zp(t)),n&&pf(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error("Unknown data type "+e)}function Af(t,e){if(0===t.length)return e[0];const n=t.reduce((t,e)=>t*e);if(0===n)return[];if(n!==e.length)throw new Error(`[${t}] does not match the input size.`);return function t(e,n,r){const s=new Array;if(1===n.length){const t=n[0];for(let n=0;n<t;n++)s[n]=r[e+n]}else{const i=n[0],o=n.slice(1),a=o.reduce((t,e)=>t*e);for(let n=0;n<i;n++)s[n]=t(e+n*a,o,r)}return s}(0,t,e)}function If(t,e){const n=Nf(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function Nf(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error("Unknown data type "+e)}function Tf(){return Np().platform.now()}function Rf(t){t.forEach(e=>{Kp(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function $f(t,e){return Np().platform.fetch(t,e)}function Df(t,e="utf-8"){return e=e||"utf-8",Np().platform.encode(t,e)}function Of(t,e="utf-8"){return e=e||"utf-8",Np().platform.decode(t,e)}function Ff(t,e,n){if(0===e)return 0;if(1===e)return t[0];let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=n[s]*t[s];return r}function Mf(t,e,n){if(0===e)return[];if(1===e)return[t];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(t/n[s]),t-=r[s]*n[s];return r[r.length-1]=t,r}class Lf{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new Pf)}profileKernel(t,e,n){let r;const s=this.backendTimer.time(()=>{r=n()});return r.forEach(n=>{n.data().then(r=>{!function(t,e,n){if("float32"!==e)return!1;for(let r=0;r<t.length;r++){const e=t[r];if(isNaN(e)||!isFinite(e))return console.warn(`Found ${e} in the result of '${n}'`),!0}}(r,n.dtype,t),s.then(s=>{let i="";null!=s.getExtraProfileInfo&&(i=s.getExtraProfileInfo()),this.logger.logKernelProfile(t,n,r,s.kernelMs,e,i)})})}),r}}class Pf{logKernelProfile(t,e,n,r,s,i){const o="number"==typeof r?of(r+"ms",9):r.error,a=of(t,25),l=e.rank,u=e.size,c=of(e.shape.toString(),14);let h="";for(const d in s){const t=s[d].shape||e.shape,n=t.length;h+=`${d}: ${n}D ${n>0?t:""} `}console.log(`%c${a}\t%c${o}\t%c${l}D ${c}\t%c${u}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function zf(t,e,n){let r;return r=Array.isArray(t)?parseFloat(t[0].toFixed(7))+" + "+parseFloat(t[1].toFixed(7))+"j":vf(t)?`'${t}'`:"bool"===n?Bf(t):parseFloat(t.toFixed(7)).toString(),of(r,e)}function Bf(t){return 0===t?"false":"true"}function Vf(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class Uf{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=Jp(t),null!=n){const t=n.length;Kp(t===this.size,()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||df(e,this.size),this.strides=Ef(t)}set(t,...e){0===e.length&&(e=[0]),Kp(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const r of t){if(r<0||r>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=`+this.shape);e++}let n=t[t.length-1];for(let r=0;r<t.length-1;++r)n+=this.strides[r]*t[r];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Wf().makeTensor(this.values,this.shape,this.dtype)}}let Wf=null,jf=null,Hf=null;class qf{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=Jp(t),this.strides=Ef(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}flatten(){return this.throwIfDisposed(),this.as1D()}asScalar(){return this.throwIfDisposed(),Kp(1===this.size,()=>"The array must have only 1 element."),this.reshape([])}as1D(){return this.throwIfDisposed(),this.reshape([this.size])}as2D(t,e){return this.throwIfDisposed(),this.reshape([t,e])}as3D(t,e,n){return this.throwIfDisposed(),this.reshape([t,e,n])}as4D(t,e,n,r){return this.throwIfDisposed(),this.reshape([t,e,n,r])}as5D(t,e,n,r,s){return this.throwIfDisposed(),this.reshape([t,e,n,r,s])}asType(t){return this.throwIfDisposed(),jf.cast(this,t)}get rank(){return this.shape.length}async buffer(){const t=await this.data();return jf.buffer(this.shape,this.dtype,t)}bufferSync(){return jf.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return Af(this.shape,t)}arraySync(){return Af(this.shape,this.dataSync())}async data(){this.throwIfDisposed();const t=Wf().read(this.dataId);if("string"===this.dtype){const n=await t;try{return n.map(t=>Of(t))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataSync(){this.throwIfDisposed();const t=Wf().readSync(this.dataId);if("string"===this.dtype)try{return t.map(t=>Of(t))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Wf().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Wf().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}toFloat(){return this.asType("float32")}toInt(){return this.asType("int32")}toBool(){return this.asType("bool")}print(t=!1){return jf.print(this,t)}reshape(t){return this.throwIfDisposed(),jf.reshape(this,t)}reshapeAs(t){return this.throwIfDisposed(),this.reshape(t.shape)}expandDims(t=0){return jf.expandDims(this,t)}squeeze(t){return this.throwIfDisposed(),jf.squeeze(this,t)}clone(){return this.throwIfDisposed(),jf.clone(this)}toString(t=!1){return function(t,e,n,r){const s=Ef(e),i=function(t,e,n,r){const s=Jp(e),i=r[r.length-1],o=new Array(i).fill(0),a=e.length,l="complex64"===n?Vf(t):t;if(a>1)for(let u=0;u<s/i;u++){const t=u*i;for(let e=0;e<i;e++)o[e]=Math.max(o[e],zf(l[t+e],0,n).length)}return o}(t,e,n,s),o=e.length,a=function t(e,n,r,s,i,o=!0){const a="complex64"===r?2:1,l=n[0],u=n.length;if(0===u)return"complex64"===r?[zf(Vf(e)[0],0,r)]:"bool"===r?[Bf(e[0])]:[e[0].toString()];if(1===u){if(l>20){let t=Array.from(e.slice(0,3*a)),n=Array.from(e.slice((l-3)*a,l*a));return"complex64"===r&&(t=Vf(t),n=Vf(n)),["["+t.map((t,e)=>zf(t,i[e],r)).join(", ")+", ..., "+n.map((t,e)=>zf(t,i[l-3+e],r)).join(", ")+"]"]}return["["+("complex64"===r?Vf(e):Array.from(e)).map((t,e)=>zf(t,i[e],r)).join(", ")+"]"]}const c=n.slice(1),h=s.slice(1),d=s[0]*a,p=[];if(l>20){for(let n=0;n<3;n++){const s=n*d;p.push(...t(e.slice(s,s+d),c,r,h,i,!1))}p.push("...");for(let n=l-3;n<l;n++){const s=n*d;p.push(...t(e.slice(s,s+d),c,r,h,i,n===l-1))}}else for(let g=0;g<l;g++){const n=g*d;p.push(...t(e.slice(n,n+d),c,r,h,i,g===l-1))}const f=2===u?",":"";p[0]="["+p[0]+f;for(let g=1;g<p.length-1;g++)p[g]=" "+p[g]+f;let m=",\n";for(let g=2;g<u;g++)m+="\n";return p[p.length-1]=" "+p[p.length-1]+"]"+(o?"":m),p}(t,e,n,s,i),l=["Tensor"];return r&&(l.push("  dtype: "+n),l.push("  rank: "+o),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(t=>"    "+t).join("\n")),l.join("\n")}(this.dataSync(),this.shape,this.dtype,t)}gather(t,e=0){return this.throwIfDisposed(),jf.gather(this,t,e)}norm(t="euclidean",e=null,n=!1){return this.throwIfDisposed(),jf.norm(this,t,e,n)}slice(t,e){return this.throwIfDisposed(),jf.slice(this,t,e)}reverse(t){return this.throwIfDisposed(),jf.reverse(this,t)}stack(t,e=0){return jf.stack([this,t],e)}unstack(t=0){return jf.unstack(this,t)}all(t=null,e=!1){return this.throwIfDisposed(),jf.all(this,t,e)}any(t=null,e=!1){return this.throwIfDisposed(),jf.any(this,t,e)}logSumExp(t=null,e=!1){return this.throwIfDisposed(),jf.logSumExp(this,t,e)}sum(t=null,e=!1){return this.throwIfDisposed(),jf.sum(this,t,e)}prod(t=null,e=!1){return this.throwIfDisposed(),jf.prod(this,t,e)}mean(t=null,e=!1){return this.throwIfDisposed(),jf.mean(this,t,e)}min(t=null,e=!1){return this.throwIfDisposed(),jf.min(this,t,e)}argMin(t=null){return this.throwIfDisposed(),jf.argMin(this,t)}argMax(t=null){return this.throwIfDisposed(),jf.argMax(this,t)}cast(t){return this.throwIfDisposed(),jf.cast(this,t)}addStrict(t){return this.throwIfDisposed(),jf.addStrict(this,t)}subStrict(t){return this.throwIfDisposed(),jf.subStrict(this,t)}powStrict(t){return this.throwIfDisposed(),jf.powStrict(this,t)}mulStrict(t){return this.throwIfDisposed(),jf.mulStrict(this,t)}divStrict(t){return this.throwIfDisposed(),jf.divStrict(this,t)}minimumStrict(t){return this.throwIfDisposed(),jf.minimumStrict(this,t)}maximumStrict(t){return this.throwIfDisposed(),jf.maximumStrict(this,t)}modStrict(t){return this.throwIfDisposed(),jf.modStrict(this,t)}squaredDifferenceStrict(t){return this.throwIfDisposed(),jf.squaredDifferenceStrict(this,t)}notEqualStrict(t){return this.throwIfDisposed(),jf.notEqualStrict(this,t)}lessStrict(t){return this.throwIfDisposed(),jf.lessStrict(this,t)}equalStrict(t){return this.throwIfDisposed(),jf.equalStrict(this,t)}lessEqualStrict(t){return this.throwIfDisposed(),jf.lessEqualStrict(this,t)}greaterStrict(t){return this.throwIfDisposed(),jf.greaterStrict(this,t)}greaterEqualStrict(t){return this.throwIfDisposed(),jf.greaterEqualStrict(this,t)}logicalAnd(t){return this.throwIfDisposed(),jf.logicalAnd(this,t)}logicalOr(t){return this.throwIfDisposed(),jf.logicalOr(this,t)}logicalNot(){return this.throwIfDisposed(),jf.logicalNot(this)}logicalXor(t){return this.throwIfDisposed(),jf.logicalXor(this,t)}where(t,e){return this.throwIfDisposed(),jf.where(t,this,e)}neg(){return this.throwIfDisposed(),jf.neg(this)}ceil(){return this.throwIfDisposed(),jf.ceil(this)}floor(){return this.throwIfDisposed(),jf.floor(this)}sign(){return this.throwIfDisposed(),jf.sign(this)}isNaN(){return this.throwIfDisposed(),jf.isNaN(this)}isInf(){return this.throwIfDisposed(),jf.isInf(this)}isFinite(){return this.throwIfDisposed(),jf.isFinite(this)}exp(){return this.throwIfDisposed(),jf.exp(this)}expm1(){return this.throwIfDisposed(),jf.expm1(this)}log(){return this.throwIfDisposed(),jf.log(this)}log1p(){return this.throwIfDisposed(),jf.log1p(this)}sqrt(){return this.throwIfDisposed(),jf.sqrt(this)}rsqrt(){return this.throwIfDisposed(),jf.rsqrt(this)}square(){return this.throwIfDisposed(),jf.square(this)}reciprocal(){return this.throwIfDisposed(),jf.reciprocal(this)}abs(){return this.throwIfDisposed(),jf.abs(this)}clipByValue(t,e){return this.throwIfDisposed(),jf.clipByValue(this,t,e)}sigmoid(){return this.throwIfDisposed(),jf.sigmoid(this)}logSigmoid(){return this.throwIfDisposed(),jf.logSigmoid(this)}softplus(){return this.throwIfDisposed(),jf.softplus(this)}zerosLike(){return this.throwIfDisposed(),jf.zerosLike(this)}onesLike(){return this.throwIfDisposed(),jf.onesLike(this)}sin(){return this.throwIfDisposed(),jf.sin(this)}cos(){return this.throwIfDisposed(),jf.cos(this)}tan(){return this.throwIfDisposed(),jf.tan(this)}asin(){return this.throwIfDisposed(),jf.asin(this)}acos(){return this.throwIfDisposed(),jf.acos(this)}atan(){return this.throwIfDisposed(),jf.atan(this)}sinh(){return this.throwIfDisposed(),jf.sinh(this)}cosh(){return this.throwIfDisposed(),jf.cosh(this)}tanh(){return this.throwIfDisposed(),jf.tanh(this)}asinh(){return this.throwIfDisposed(),jf.asinh(this)}acosh(){return this.throwIfDisposed(),jf.acosh(this)}atanh(){return this.throwIfDisposed(),jf.atanh(this)}erf(){return this.throwIfDisposed(),jf.erf(this)}round(){return this.throwIfDisposed(),jf.round(this)}step(t=0){return this.throwIfDisposed(),jf.step(this,t)}softmax(t=-1){return this.throwIfDisposed(),jf.softmax(this,t)}logSoftmax(t=-1){return this.throwIfDisposed(),jf.logSoftmax(this,t)}resizeBilinear(t,e=!1){return this.throwIfDisposed(),jf.image.resizeBilinear(this,t,e)}resizeNearestNeighbor(t,e=!1){return this.throwIfDisposed(),jf.image.resizeNearestNeighbor(this,t,e)}variable(t=!0,e,n){return this.throwIfDisposed(),Wf().makeVariable(this,t,e,n)}unsortedSegmentSum(t,e){return this.throwIfDisposed(),jf.unsortedSegmentSum(this,t,e)}topk(t=1,e=!0){return this.throwIfDisposed(),jf.topk(this,t,e)}stridedSlice(t,e,n,r=0,s=0,i=0,o=0,a=0){return this.throwIfDisposed(),jf.stridedSlice(this,t,e,n,r,s,i,o,a)}fft(){return this.throwIfDisposed(),jf.spectral.fft(this)}ifft(){return this.throwIfDisposed(),jf.spectral.ifft(this)}rfft(){return this.throwIfDisposed(),jf.spectral.rfft(this)}irfft(){return this.throwIfDisposed(),jf.spectral.irfft(this)}}Object.defineProperty(qf,Symbol.hasInstance,{value:t=>!!t&&null!=t.dataId&&null!=t.shape&&null!=t.dtype});class Gf extends qf{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!tf(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Wf().disposeTensor(this),this.dataId=t.dataId,Wf().incRef(this,null)}dispose(){Wf().disposeVariable(this),this.isDisposedInternal=!0}}var Kf,Xf,Yf,Zf,Jf;Object.defineProperty(Gf,Symbol.hasInstance,{value:t=>t instanceof qf&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Kf||(Kf={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(Xf||(Xf={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Yf||(Yf={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(Zf||(Zf={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(Jf||(Jf={}));const Qf={float32:Zf,int32:Xf,bool:Yf,complex64:Jf};function tm(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return Qf[t][e]}function em(t){return tm(t,"int32")}function nm(t,e){if(t.dtype===e.dtype)return[t,e];const n=tm(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function rm(t,e){Kp(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function sm(t,e){return e.some(e=>e.id===t.id)}function im(t){const e=[];return function t(e,n,r){if(null==e)return;if(e instanceof qf)return void n.push(e);if(s=e,!Array.isArray(s)&&"object"!=typeof s)return;var s;const i=e;for(const o in i){const e=i[o];r.has(e)||(r.add(e),t(e,n,r))}}(t,e,new Set),e}class om{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class am{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new om}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void(await this.setBackend(n))}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(console.warn(t+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Lf(this.backendInstance),!0}setupRegisteredKernels(){Pp(this.backendName).forEach(t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){Pp(t).forEach(e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(Promise.resolve(n)===n){const e=++this.pendingBackendInitId,r=n.then(n=>!(e<this.pendingBackendInitId||(this.registry[t]=n,this.pendingBackendInit=null,0))).catch(n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}return this.registry[t]=n,{success:!0,asyncInit:!1}}catch(n){return console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(t+" backend not found in registry");this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,s=this.readSync(e);r.disposeData(e),n.backend=t,t.move(e,s,n.shape,n.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(n),()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(r){throw e(),r}}nextTensorId(){return am.nextTensorId++}nextVariableId(){return am.nextVariableId++}clone(t){const e=this.makeTensorFromDataId(t.dataId,t.shape,t.dtype);return this.addTapeNode(this.state.activeScope.name,{x:t},[e],t=>({x:()=>t.toFloat()}),[],{}),e}runKernel(t,e,n,r,s){return this.runKernelFunc(null,e,null,t,n,r,s)}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let s=0;n.forEach(t=>{s+="complex64"===t.dtype?3:1});const i=r-e-s-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${t}'`)}runKernelFunc(t,e,n,r,s,i,o){let a,l=[];const u=this.isTapeOn();null==r&&(r=null!=this.state.activeScope?this.state.activeScope.name:"");const c=this.state.numBytes,h=this.state.numTensors;let d;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const p=Mp(r,this.backendName);let f;if(null!=p)d=()=>{const t=this.backend.numDataIds();f=p.kernelFunc({inputs:e,attrs:s,backend:this.backend});const n=Array.isArray(f)?f:[f];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,t,n);const a=n.map(({dataId:t,shape:e,dtype:n})=>this.makeTensorFromDataId(t,e,n));if(u){let t=this.getTensorsForGradient(r,e,a);if(null==t){null==o&&(o=[]);const e=a.filter((t,e)=>o[e]);t=(i||[]).slice().concat(e)}l=this.saveTensorsForBackwardMode(t)}return a};else{const e=t=>{u&&(l=t.map(t=>this.keep(this.clone(t))))};d=()=>{const n=this.backend.numDataIds();f=this.tidy(()=>t(this.backend,e));const s=Array.isArray(f)?f:[f];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,n,s),s}}return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{a=this.ENV.getBool("DEBUG")?this.profiler.profileKernel(r,e,()=>d()):d()}),u&&this.addTapeNode(r,e,a,n,l,s),this.state.profiling&&this.state.activeProfile.kernels.push({name:r,bytesAdded:this.state.numBytes-c,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-h,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(e).map(t=>e[t].shape),outputShapes:a.map(t=>t.shape)}),Array.isArray(f)?a:a[0]}saveTensorsForBackwardMode(t){return t.map(t=>this.keep(this.clone(t)))}getTensorsForGradient(t,e,n){const r=Lp(t);if(null!=r){const t=r.inputsToSave||[],s=r.outputsToSave||[];let i;r.saveAllInputs?(Kp(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(e).map(t=>e[t])):i=t.map(t=>e[t]);const o=n.filter((t,e)=>s[e]);return i.concat(o)}return null}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");r=r||this.backend;let s=t;"string"===(n=n||"float32")&&vf(t[0])&&(s=t.map(t=>Df(t)));const i=r.write(s,e,n),o=new qf(e,n,i,this.nextTensorId());if(this.incRef(o,r),"string"===n){const t=this.state.tensorInfo.get(i),e=bf(s);this.state.numBytes+=e-t.bytes,t.bytes=e}return o}makeTensorFromDataId(t,e,n,r){const s=new qf(e,n=n||"float32",t,this.nextTensorId());return this.incRef(s,r),s}makeVariable(t,e=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.asType(r));const s=new Gf(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}incRef(t,e){const n=this.state.tensorInfo.has(t.dataId)?this.state.tensorInfo.get(t.dataId).refCount:0;if(this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++,0===n){this.state.numDataBuffers++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*yf(t.dtype)),this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n,refCount:0}),this.state.numBytes+=n}this.state.tensorInfo.get(t.dataId).refCount++,t instanceof Gf||this.track(t)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;this.state.numTensors--,"string"===t.dtype&&this.state.numStringTensors--;const e=this.state.tensorInfo.get(t.dataId);e.refCount<=1?("complex64"!==t.dtype&&(this.state.numBytes-=e.bytes),this.state.numDataBuffers--,e.backend.disposeData(t.dataId),this.state.tensorInfo.delete(t.dataId)):this.state.tensorInfo.get(t.dataId).refCount--}disposeVariables(){for(const t in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[t])}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;return this.state.activeProfile.kernels=[],this.state.activeProfile.result=t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(t=>t.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n,this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,s,i){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:s},a=Lp(t);null!=a&&(r=a.gradFunc),null!=r&&(o.gradient=t=>(t=t.map((t,e)=>{if(null==t){const t=n[e],r=Nf(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t}),r(t.length>1?t:t[0],s,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=im(t),n=new Set(e.map(t=>t.id));for(let s=0;s<this.state.activeScope.track.length;s++){const t=this.state.activeScope.track[s];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(t=>{t.kept||t.scopeId!==r.id||this.track(t)})}gradients(t,e,n,r=!1){if(Kp(e.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));Kp(s instanceof qf,()=>"The result y returned by f() must be a tensor.");const i=function(t,e,n){const r={},s={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){const n=t[l],i=n.inputs;for(const t in i){const o=i[t];let a=!1;for(let t=0;t<e.length;t++)if(r[o.id]){n.outputs.forEach(t=>r[t.id]=!0),a=!0,s[n.id]=!0;break}if(a)break}}const i={};i[n.id]=!0;const o={};for(let l=t.length-1;l>=0;l--){const e=t[l],n=e.inputs;for(let t=0;t<e.outputs.length;t++)if(i[e.outputs[t].id]){for(const t in n)i[n[t].id]=!0,o[e.id]=!0;break}}const a=[];for(let l=0;l<t.length;l++){const e=t[l];if(s[e.id]&&o[e.id]){const t={};for(const s in e.inputs){const n=e.inputs[s];r[n.id]&&(t[s]=n)}const n=Object.assign({},e);n.inputs=t,n.outputs=e.outputs,a.push(n)}}return a}(this.state.activeTape,e,s);if(!r&&0===i.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const t={};t[s.id]=null==n?function(t){const e=If(Jp(t),"float32");return lm.makeTensor(e,t,"float32")}(s.shape):n,function(t,e,n){for(let r=e.length-1;r>=0;r--){const s=e[r],i=[];if(s.outputs.forEach(e=>{const n=t[e.id];i.push(null!=n?n:null)}),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const o=s.gradient(i);for(const e in s.inputs){if(!(e in o))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(o)}.`);const r=n(()=>o[e]());if("float32"!==r.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${r.dtype}'`);const i=s.inputs[e];if(!tf(r.shape,i.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${e}' has shape '${r.shape}', which does not match the shape of the input '${i.shape}'`);if(null==t[i.id])t[i.id]=r;else{const e=t[i.id];t[i.id]=e.add(r),e.dispose()}}}}(t,i,t=>this.tidy(t));const r=e.map(e=>t[e.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(t=>{for(const e of t.saved)e.dispose()}),this.state.activeTape=null),{value:s,grads:r}})}customGrad(t){return Kp(Sf(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{let n;Kp(e.every(t=>t instanceof qf),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const r={};return e.forEach((t,e)=>{r[e]=t}),this.runKernelFunc((r,s)=>(n=t(...e,s),Kp(n.value instanceof qf,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Kp(Sf(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),r,(t,r)=>{const s=n.gradFunc(t,r),i=Array.isArray(s)?s:[s];Kp(i.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Kp(i.every(t=>t instanceof qf),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const o={};return i.forEach((t,e)=>{o[e]=()=>t}),o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}async time(t){const e=Tf(),n=await this.backend.time(t);return n.wallMs=Tf()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new om;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}am.nextTensorId=0,am.nextVariableId=0;const lm=function(){const t=$p();if(null==t._tfengine){const e=new Ip(t);t._tfengine=new am(e)}return Rp=t._tfengine.ENV,Wf=()=>t._tfengine,t._tfengine}();function um(){if("undefined"!=typeof navigator&&null!=navigator){const t=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function cm(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const hm=Np();function dm(t,e){const n=t.length,r=[];for(let s=0;s<n;s++){const i=n-1-s,o=t[i]||1;(e[e.length-1-s]||1)>1&&1===o&&r.unshift(i)}return r}function pm(t,e){const n=[];for(let r=0;r<e.length;r++){const s=t[t.length-r-1],i=e.length-r-1,o=e[i];(null==s||1===s&&o>1)&&n.unshift(i)}return n}function fm(t,e){const n=[],r=Math.max(t.length,e.length);for(let s=0;s<r;s++){let r=t[t.length-s-1];null==r&&(r=1);let i=e[e.length-s-1];if(null==i&&(i=1),1===r)n.unshift(i);else if(1===i)n.unshift(r);else{if(r!==i)throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`);n.unshift(r)}}return n}hm.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),hm.registerFlag("IS_BROWSER",()=>cm()),hm.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),hm.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),hm.registerFlag("PROD",()=>!1),hm.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>hm.getBool("DEBUG")),hm.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),hm.registerFlag("IS_TEST",()=>!1);const mm={kernelName:"Add",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=fm(n.shape,r.shape);return{a:()=>{let e=t;const r=pm(n.shape,s);return r.length>0&&(e=e.sum(r)),e.reshape(n.shape)},b:()=>{let e=t;const n=pm(r.shape,s);return n.length>0&&(e=e.sum(n)),e.reshape(r.shape)}}}};function gm(t,e){let n=t;if(gf(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||gf(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&Np().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function t(e,n,r){if(r=r||[],!Array.isArray(e)&&!gf(e))return void Kp(0===n.length,()=>`Element arr[${r.join("][")}] is a primitive, but should be an array/TypedArray of ${n[0]} elements`);Kp(n.length>0,()=>`Element arr[${r.join("][")}] should be a primitive, but is an array of ${e.length} elements`),Kp(e.length===n[0],()=>`Element arr[${r.join("][")}] should have ${n[0]} elements, but has ${e.length} elements`);const s=n.slice(1);for(let i=0;i<e.length;++i)t(e[i],s,r.concat(i))}(t,r,[]),r}function ym(t,e,n,r){if(null!=t&&("numeric"!==t&&t!==e||"numeric"===t&&"string"===e))throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}function bm(t,e,n,r="numeric"){if(t instanceof qf)return ym(r,t.dtype,e,n),t;let s=Cf(t);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),ym(r,s,e,n),null==t||!gf(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${null==t?"null":t.constructor.name}'`);const i=gm(t,s);gf(t)||Array.isArray(t)||(t=[t]);const o="string"!==s?kf(t,s,Np().getBool("DEBUG")):Zp(t,[],!0);return lm.makeTensor(o,i,s)}function vm(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((t,r)=>bm(t,`${e}[${r}]`,n),r)}function xm(t){const e=Object.keys(t);if(1!==e.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+e.length+" keys.");let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1));const s=(...t)=>{lm.startScope(n);try{const e=r(...t);return e instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),lm.endScope(e),e}catch(e){throw lm.endScope(null),e}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}const wm=xm({add_:function(t,e){let n=bm(t,"a","add"),r=bm(e,"b","add");return[n,r]=nm(n,r),lm.runKernelFunc((t,e)=>{const s=t.add(n,r);return e([n,r]),s},{a:n,b:r},null,"Add")}});function Cm(t,e){const n=t[0].length;t.forEach((t,e)=>{Kp(t.length===n,()=>`Error in concat${n}D: rank of tensors[${e}] must be the same as the rank of the rest (${n})`)}),Kp(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=t[0];t.forEach((t,s)=>{for(let i=0;i<n;i++)Kp(i===e||t[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${s}] (${t}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function Sm(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}const _m=xm({complex_:function(t,e){const n=bm(t,"real","complex"),r=bm(e,"imag","complex");return Xp(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`),lm.runKernelFunc(t=>t.complex(n,r),{real:n,imag:r},null,"Complex")}}),Em=xm({imag_:function(t){const e=bm(t,"input","imag");return lm.runKernelFunc(t=>t.imag(e),{input:e},null,"Imag")}}),km=xm({real_:function(t){const e=bm(t,"input","real");return lm.runKernelFunc(t=>t.real(e),{input:e},null,"Real")}});function Am(t,e,n){return Im(t,e,gm(t,n),n)}function Im(t,e,n,r){if(null==r&&(r=Cf(t)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!gf(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){Rf(e);const t=Jp(e),r=Jp(n);Kp(t===r,()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${r}`);for(let s=0;s<n.length;++s){const t=n[s],r=s!==n.length-1||t!==Jp(e.slice(s));Kp(n[s]===e[s]||!r,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return gf(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?kf(t,r,Np().getBool("DEBUG")):Zp(t,[],!0),lm.makeTensor(t,e,r)}function Nm(t,e){if((gf(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&gf(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Im(t,[],[],e)}function Tm(t,e){Yp(t);const n=gm(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Im(t,null,n,e)}function Rm(t,e,n){if(Yp(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const r=gm(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Im(t,e,r,n)}function $m(t,e,n){if(Yp(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const r=gm(t,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Im(t,e,r,n)}function Dm(t,e,n){if(Yp(t),null!=e&&4!==e.length)throw new Error("tensor4d() requires shape to have four numbers");const r=gm(t,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Im(t,e,r,n)}function Om(t,e,n){if(Yp(t),null!=e&&5!==e.length)throw new Error("tensor5d() requires shape to have five numbers");const r=gm(t,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Im(t,e,r,n)}function Fm(t,e,n){if(Yp(t),null!=e&&6!==e.length)throw new Error("tensor6d() requires shape to have six numbers");const r=gm(t,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Im(t,e=e||r,r,n)}function Mm(t,e=!0,n,r){return lm.makeVariable(t,e,n,r)}function Lm(t,e="float32"){if("complex64"===e){const e=Lm(t,"float32"),n=Pm(t,"float32");return _m(e,n)}const n=If(Jp(t),e);return lm.makeTensor(n,t,e)}function Pm(t,e="float32"){if("complex64"===e){const e=Pm(t,"float32"),n=Pm(t,"float32");return _m(e,n)}const n=Nf(Jp(t),e);return lm.makeTensor(n,t,e)}function zm(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");return lm.runKernelFunc(r=>r.linspace(t,e,n),{})}function Bm(t,e,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");if(t===e||t<e&&n<0||e<t&&n>1)return Pm([0],r);const s=Nf(Math.abs(Math.ceil((e-t)/n)),r);e<t&&1===n&&(n=-1),s[0]=t;for(let i=1;i<s.length;i++)s[i]=s[i-1]+n;return Tm(s,r)}const Vm=xm({onesLike_:function(t){const e=bm(t,"x","onesLike");if("complex64"===e.dtype){const t=Vm(km(e)),n=Um(Em(e));return _m(t,n)}return lm.runKernelFunc(t=>t.onesLike(e),{x:e},(t,e)=>({x:()=>Um(t)}),"OnesLike")}}),Um=xm({zerosLike_:function(t){const e=bm(t,"x","zerosLike");return lm.runKernelFunc(t=>t.zerosLike(e),{x:e},(t,e)=>({x:()=>Um(t)}),"ZerosLike")}}),Wm=xm({concat_:function(t,e=0){Kp(t.length>=1,()=>"Pass at least one tensor to concat");let n=vm(t,"tensors","concat");"complex64"===n[0].dtype&&n.forEach(t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)});const r=uf(e,n[0].shape)[0],s=Sm(n.map(t=>t.shape),r);return 0===Jp(s)?Am([],s):(n=n.filter(t=>t.size>0),1===n.length?n[0]:(Cm(n.map(t=>t.shape),r),lm.runKernelFunc((t,e)=>{const s=t.concat(n,r);return e(n),s},n,null,"Concat",{axis:e})))}});function jm(t,e="float32",n){return e=e||"float32",Rf(t),new Uf(t,e,n)}function Hm(t,e=!1){console.log(t.toString(e))}const qm=xm({cast_:function(t,e){const n=bm(t,"x","cast");if(!ff(e))throw new Error("Failed to cast to unknown dtype "+e);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");return lm.runKernelFunc(t=>t.cast(n,e),{x:n},t=>({x:()=>t.clone()}),"Cast",{dtype:e})}}),Gm=xm({expandDims_:function(t,e=0){const n=bm(t,"x","expandDims",null);Kp(e<=n.rank,()=>"Axis must be <= rank of the tensor");const r=n.shape.slice();return e<0&&(Kp(-(n.rank+1)<=e,()=>`Axis must be in the interval [${-(n.rank+1)}, ${n.rank}]`),e=n.rank+e+1),r.splice(e,0,1),Km(n,r)}}),Km=xm({reshape_:function(t,e){const n=bm(t,"x","reshape",null);return e=lf(e,n.size),Kp(n.size===Jp(e),()=>"new shape and old shape must have the same number of elements."),lm.runKernelFunc(t=>t.reshape(n,e),{x:n},t=>({x:()=>t.reshape(n.shape)}),"Reshape",{shape:e})}}),Xm=xm({squeeze_:function(t,e){const n=bm(t,"x","squeeze");return Km(n,cf(n.shape,e).newShape)}}),Ym=xm({stack_:function(t,e=0){const n=vm(t,"tensors","stack");if(Kp(n.length>=1,()=>"Pass at least one tensor to tf.stack"),1===n.length)return n[0].expandDims(e);const r=n[0].shape,s=n[0].dtype;Kp(e<=n[0].rank,()=>"Axis must be <= rank of the tensor"),n.forEach(t=>{Xp(r,t.shape,"All tensors passed to stack must have matching shapes")}),n.forEach(t=>{Kp(s===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=n.map(t=>t.expandDims(e));return Wm(i,e)}}),Zm=xm({unstack_:function(t,e=0){e=e||0;const n=bm(t,"x","unstack");return Kp(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`),e<0&&(e+=n.shape.length),lm.runKernelFunc(t=>t.unstack(n,e),{x:n},t=>({x:()=>Ym(t,e)}),"Unpack",{axis:e})}}),Jm=async function(t,e){const n=bm(t,"x","setdiff1d"),r=bm(e,"y","setdiff1d");Kp(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),Kp(1===n.rank,()=>`x should be 1D tensor, but got x (${n.shape}).`),Kp(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await n.data(),i=await r.data(),o=new Set(i);let a=0;for(let c=0;c<s.length;c++)o.has(s[c])||a++;const l=new Uf([a],n.dtype),u=new Uf([a],"int32");for(let c=0,h=0;c<s.length;c++)o.has(s[c])||(l.values[h]=s[c],u.values[h]=c,h++);return[l.toTensor(),u.toTensor()]},Qm=xm({floorDiv_:function(t,e){let n=bm(t,"a","floorDiv"),r=bm(e,"b","floorDiv");return[n,r]=nm(n,r),lm.runKernelFunc((t,e)=>{const s=t.floorDiv(n,r);return e([n,r]),s},{a:n,b:r},null,"FloorDiv")}}),tg=xm({div_:function(t,e){let n=bm(t,"a","div"),r=bm(e,"b","div");return[n,r]=nm(n,r),"int32"===n.dtype&&"int32"===r.dtype?Qm(n,r):lm.runKernelFunc((t,e)=>{const s=t.realDivide(n,r);return e([n,r]),s},{a:n,b:r},null,"Div",{})}}),eg=xm({mul_:function(t,e){let n=bm(t,"a","mul"),r=bm(e,"b","mul");return[n,r]=nm(n,r),lm.runKernelFunc((t,e)=>{const s=t.multiply(n,r);return e([n,r]),s},{a:n,b:r},null,"Multiply")}});function ng(t){return lm.customGrad(t)}function rg(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function sg(t,e,n){const r=t.length+e.length,s=[];let i=0,o=0;for(let a=0;a<r;a++)-1===n.indexOf(a)?s.push(t[i++]):s.push(e[o++]);return s}function ig(t,e){const n=[],r=t.length;for(let s=0;s<r;s++)-1===e.indexOf(s)&&n.push(t[s]);return[n,e.map(e=>t[e])]}function og(t,e){return sg(t,e.map(t=>1),e)}function ag(t,e,n){Kp(rg(e,n),()=>t+" supports only inner-most axes for now. "+`Got axes ${e} and rank-${n} input.`)}function lg(t,e){if(rg(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach(t=>n.push(t)),n}function ug(t){return t.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function cg(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}function hg(t,e,n,r,s){return e.rank<n.rank&&(e=e.reshape(og(e.shape,r))),t.rank<n.rank&&(t=t.reshape(og(t.shape,r))),{x:()=>{const r=t.mul(n.equal(e).cast(t.dtype));return null==s?r:r.transpose(s)}}}const dg=xm({all_:function(t,e=null,n=!1){let r=bm(t,"x","all","bool");const s=uf(e,r.shape);let i=s;const o=lg(i,r.rank);null!=o&&(r=r.transpose(o),i=cg(i.length,r.rank));const a=lm.runKernelFunc(t=>t.all(r,i),{$x:r});if(n){const t=og(a.shape,s);return a.reshape(t)}return a}}),pg=xm({any_:function(t,e=null,n=!1){let r=bm(t,"x","any","bool");const s=uf(e,r.shape);let i=s;const o=lg(i,r.rank);null!=o&&(r=r.transpose(o),i=cg(i.length,r.rank));const a=lm.runKernelFunc(t=>t.any(r,i),{$x:r});if(n){const t=og(a.shape,s);return a.reshape(t)}return a}}),fg=xm({argMax_:function(t,e=0){let n=bm(t,"x","argMax");null==e&&(e=0);let r=uf(e,n.shape);const s=lg(r,n.rank);return null!=s&&(n=n.transpose(s),r=cg(r.length,n.rank)),lm.runKernelFunc((t,e)=>{const s=t.argMax(n,r[0]);return e([n]),s},{x:n},(t,e)=>{const[n]=e;return{x:()=>Um(n)}},"ArgMax",{axis:r[0]},[n])}}),mg=xm({argMin_:function(t,e=0){let n=bm(t,"x","argMin");null==e&&(e=0);let r=uf(e,n.shape);const s=lg(r,n.rank);return null!=s&&(n=n.transpose(s),r=cg(r.length,n.rank)),lm.runKernelFunc((t,e)=>{const s=t.argMin(n,r[0]);return e([n]),s},{$x:n},(t,e)=>{const[n]=e;return{$x:()=>Um(n)}})}}),gg=xm({logSumExp_:function(t,e=null,n=!1){const r=bm(t,"x","logSumExp"),s=uf(e,r.shape),i=r.max(s,!0),o=r.sub(i).exp().sum(s).log(),a=i.reshape(o.shape).add(o);if(n){const t=og(a.shape,s);return a.reshape(t)}return a}}),yg=xm({mean_:function(t,e=null,n=!1){const r=bm(t,"x","mean"),s=uf(e,r.shape),i=Jp(ig(r.shape,s)[1]);return ng(t=>{const r=Nm(i);return{value:(r.dtype===t.dtype?t:t.cast(r.dtype)).div(r).sum(e,n),gradFunc:e=>{const n=t.shape.slice();return s.forEach(t=>{n[t]=1}),e.reshape(n).mul(Lm(t.shape,"float32")).div(i)}}})(r)}}),bg=xm({min_:function(t,e=null,n=!1){let r=bm(t,"x","min");const s=r,i=uf(e,r.shape);let o=i;const a=lg(o,r.rank);null!=a&&(r=r.transpose(a),o=cg(o.length,r.rank));let l=lm.runKernelFunc((t,e)=>{const n=t.min(r,o);return e([s,n]),n},{x:r},(t,e)=>hg(t,e[1],e[0],i,a),"Min",{axes:o},[r],[!0]);if(n){const t=og(l.shape,i);l=l.reshape(t)}return l}}),vg=xm({moments_:function(t,e=null,n=!1){const r=uf(e,(t=bm(t,"x","moments")).shape),s=t.mean(r,n);let i=s.shape;n||(i=og(s.shape,r));const o=t.toFloat().sub(s.reshape(i)).square();return{mean:s,variance:o.mean(r,n)}}}),xg=xm({sum_:function(t,e=null,n=!1){let r=bm(t,"x","sum");"bool"===r.dtype&&(r=r.toInt());const s=uf(e,r.shape);return ng(t=>{const e=lg(s,t.rank);let r=s,i=t;null!=e&&(i=t.transpose(e),r=cg(r.length,t.rank));const o=e=>{const n=t.shape.slice();return s.forEach(t=>{n[t]=1}),e.reshape(n).mul(Lm(t.shape,"float32"))};let a=lm.runKernelFunc(t=>t.sum(i,r),{x:i},t=>({x:()=>o(t)}),"Sum",{axes:r});if(n){const t=og(a.shape,s);a=a.reshape(t)}return{value:a,gradFunc:o}})(r)}}),wg=xm({prod_:function(t,e=null,n=!1){let r=bm(t,"x","prod");"bool"===r.dtype&&(r=r.toInt());const s=uf(e,r.shape),i=lg(s,r.rank);let o=s,a=r;null!=i&&(a=r.transpose(i),o=cg(o.length,r.rank));let l=lm.runKernelFunc(t=>t.prod(a,o),{permutedX:a});if(n){const t=og(l.shape,s);l=l.reshape(t)}return l}}),Cg=xm({square_:function(t){const e=bm(t,"x","square");return lm.runKernelFunc((t,n)=>(n([e]),t.square(e)),{x:e},null,"Square",{},[e],[])}}),Sg=xm({abs_:function(t){const e=bm(t,"x","abs");return"complex64"===e.dtype?lm.runKernelFunc(t=>t.complexAbs(e),{$x:e}):lm.runKernelFunc((t,n)=>{const r=t.abs(e);return n([e]),r},{x:e},(t,e)=>{const[n]=e;return{x:()=>t.mul(n.toFloat().step(-1))}},"Abs")}}),_g=xm({acos_:function(t){const e=bm(t,"x","acos");return lm.runKernelFunc((t,n)=>{const r=t.acos(e);return n([e]),r},{$x:e},(t,e)=>{const[n]=e;return{$x:()=>{const e=n.toFloat().square(),r=Nm(1).sub(e).sqrt();return t.div(r).neg()}}})}}),Eg=xm({acosh_:function(t){const e=bm(t,"x","acosh");return lm.runKernelFunc((t,n)=>{const r=t.acosh(e);return n([e]),r},{$x:e},(t,e)=>{const[n]=e;return{$x:()=>{const e=n.toFloat().square().sub(1).sqrt();return t.div(e)}}})}}),kg=xm({asin_:function(t){const e=bm(t,"x","asin");return lm.runKernelFunc((t,n)=>{const r=t.asin(e);return n([e]),r},{$x:e},(t,e)=>{const[n]=e;return{$x:()=>t.div(Nm(1).sub(n.toFloat().square()).sqrt())}})}}),Ag=xm({asinh_:function(t){const e=bm(t,"x","asinh");return lm.runKernelFunc((t,n)=>{const r=t.asinh(e);return n([e]),r},{$x:e},(t,e)=>{const[n]=e;return{$x:()=>{const e=Nm(1).add(n.toFloat().square()).sqrt();return t.div(e)}}})}}),Ig=xm({atan_:function(t){const e=bm(t,"x","atan");return lm.runKernelFunc((t,n)=>{const r=t.atan(e);return n([e]),r},{$x:e},(t,e)=>{const[n]=e;return{$x:()=>t.div(n.toFloat().square().add(1))}})}}),Ng=xm({atanh_:function(t){const e=bm(t,"x","atanh");return lm.runKernelFunc((t,n)=>{const r=t.atanh(e);return n([e]),r},{$x:e},(t,e)=>{const[n]=e;return{$x:()=>t.div(Nm(1).sub(n.toFloat().square()))}})}}),Tg=xm({ceil_:function(t){const e=bm(t,"x","ceil");return lm.runKernelFunc(t=>t.ceil(e),{$x:e},t=>({$x:()=>Um(t)}))}}),Rg=xm({clipByValue_:function(t,e,n){const r=bm(t,"x","clipByValue");return Kp(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),lm.runKernelFunc((t,s)=>{const i=t.clip(r,e,n);return s([r]),i},{x:r},(t,r)=>{const[s]=r;return{x:()=>t.where(s.greaterEqual(e).logicalAnd(s.lessEqual(n)),Um(t))}},"ClipByValue",{min:e,max:n},[r])}}),$g=xm({cos_:function(t){const e=bm(t,"x","cos");return lm.runKernelFunc((t,n)=>{const r=t.cos(e);return n([e]),r},{x:e},(t,e)=>{const[n]=e;return{x:()=>n.toFloat().sin().neg().mul(t)}},"Cos",{},[e])}}),Dg=xm({cosh_:function(t){const e=bm(t,"x","cosh");return lm.runKernelFunc((t,n)=>{const r=t.cosh(e);return n([e]),r},{$x:e},(t,e)=>{const[n]=e;return{$x:()=>n.toFloat().sinh().mul(t)}})}}),Og=xm({erf_:function(t){let e=bm(t,"x","erf");return Kp("int32"===e.dtype||"float32"===e.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===e.dtype&&(e=e.toFloat()),lm.runKernelFunc((t,n)=>{const r=t.erf(e);return n([e]),r},{$x:e},(t,e)=>{const[n]=e;return{$x:()=>t.mul(n.square().neg().exp().mul(2/Math.sqrt(Math.PI)))}})}}),Fg=xm({exp_:function(t){const e=bm(t,"x","exp");return lm.runKernelFunc((t,n)=>{const r=t.exp(e);return n([r]),r},{x:e},(t,e)=>({x:()=>t.mul(e[0])}),"Exp",{},[],[!0])}}),Mg=xm({expm1_:function(t){const e=bm(t,"x","expm1");return lm.runKernelFunc((t,n)=>{const r=t.expm1(e);return n([e]),r},{$x:e},(t,e)=>{const[n]=e;return{$x:()=>t.mul(n.exp())}})}}),Lg=xm({floor_:function(t){const e=bm(t,"x","floor");return lm.runKernelFunc(t=>t.floor(e),{$x:e},t=>({$x:()=>Um(t)}))}}),Pg=xm({log_:function(t){const e=bm(t,"x","log");return lm.runKernelFunc((t,n)=>{const r=t.log(e);return n([e]),r},{x:e},(t,e)=>{const[n]=e;return{x:()=>t.div(n.toFloat())}},"Log",{},[e])}}),zg=xm({log1p_:function(t){const e=bm(t,"x","log1p");return lm.runKernelFunc((t,n)=>{const r=t.log1p(e);return n([e]),r},{$x:e},(t,e)=>{const[n]=e;return{$x:()=>t.div(n.add(1))}})}}),Bg=xm({logSigmoid_:function(t){const e=bm(t,"x","logSigmoid");return lm.runKernelFunc((t,n)=>{const r=t.softplus(e.neg()).neg();return n([e]),r},{$x:e},(t,e)=>{const[n]=e;return{$x:()=>t.mul(n.neg().sigmoid())}})}}),Vg=xm({neg_:function(t){const e=bm(t,"x","neg");return lm.runKernelFunc(t=>t.neg(e),{x:e},t=>({x:()=>t.neg()}),"Neg",{},[e])}}),Ug=xm({reciprocal_:function(t){const e=bm(t,"x","reciprocal");return lm.runKernelFunc((t,n)=>{const r=t.reciprocal(e);return n([e]),r},{$x:e},(t,e)=>{const[n]=e;return{$x:()=>t.div(n.square().neg())}})}}),Wg=xm({round_:function(t){const e=bm(t,"x","round");return lm.runKernelFunc(t=>t.round(e),{$x:e},t=>({$x:()=>Um(t)}))}}),jg=xm({rsqrt_:function(t){const e=bm(t,"x","rsqrt");return lm.runKernelFunc((t,n)=>{const r=t.rsqrt(e);return n([e]),r},{x:e},(t,e)=>{const[n]=e;return{x:()=>t.div(n.pow(1.5).mul(2)).neg()}},"Rsqrt",{},[e])}}),Hg=xm({sigmoid_:function(t){const e=bm(t,"x","sigmoid");return lm.runKernelFunc((t,n)=>{const r=t.sigmoid(e);return n([r]),r},{x:e},(t,e)=>{const[n]=e;return{x:()=>t.mul(n.mul(Nm(1).sub(n)))}},"Sigmoid")}}),qg=xm({sign_:function(t){const e=bm(t,"x","sign");return lm.runKernelFunc(t=>t.sign(e),{$x:e},t=>({$x:()=>Um(t)}))}}),Gg=xm({isNaN_:function(t){const e=bm(t,"x","isNaN");return lm.runKernelFunc(t=>t.isNaN(e),{$x:e},t=>({$x:()=>Um(t)}))}}),Kg=xm({isInf_:function(t){const e=bm(t,"x","isInf");return lm.runKernelFunc(t=>t.isInf(e),{$x:e},t=>({$x:()=>Um(t)}))}}),Xg=xm({isFinite_:function(t){const e=bm(t,"x","isFinite");return lm.runKernelFunc(t=>t.isFinite(e),{$x:e},t=>({$x:()=>Um(t)}))}}),Yg=xm({sin_:function(t){const e=bm(t,"x","sin");return lm.runKernelFunc((t,n)=>{const r=t.sin(e);return n([e]),r},{x:e},(t,e)=>{const[n]=e;return{x:()=>n.toFloat().cos().mul(t)}},"Sin",{},[e])}}),Zg=xm({sinh_:function(t){const e=bm(t,"x","sinh");return lm.runKernelFunc((t,n)=>{const r=t.sinh(e);return n([e]),r},{$x:e},(t,e)=>{const[n]=e;return{$x:()=>n.toFloat().cosh().mul(t)}})}}),Jg=xm({softplus_:function(t){const e=bm(t,"x","softplus");return lm.runKernelFunc((t,n)=>{const r=t.softplus(e);return n([e]),r},{$x:e},(t,e)=>{const[n]=e;return{$x:()=>t.mul(n.sigmoid())}})}}),Qg=xm({sqrt_:function(t){const e=bm(t,"x","sqrt");return lm.runKernelFunc((t,n)=>{const r=t.sqrt(e);return n([e]),r},{x:e},(t,e)=>{const[n]=e;return{x:()=>t.div(n.toFloat().sqrt().mul(2))}},"Sqrt",{})}}),ty=xm({step_:function(t,e=0){const n=bm(t,"x","step");return lm.runKernelFunc(t=>t.step(n,e),{$x:n},t=>({$x:()=>Um(t)}))}}),ey=xm({tan_:function(t){const e=bm(t,"x","tan");return lm.runKernelFunc((t,n)=>{const r=t.tan(e);return n([e]),r},{$x:e},(t,e)=>{const[n]=e;return{$x:()=>t.div(n.cos().square())}})}}),ny=xm({tanh_:function(t){const e=bm(t,"x","tanh");return lm.runKernelFunc((t,n)=>{const r=t.tanh(e);return n([r]),r},{x:e},(t,e)=>{const[n]=e;return{x:()=>Nm(1).sub(n.square()).mul(t)}},"Tanh",{},null,[!0])}}),ry={kernelName:"Atan2",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=fm(n.shape,r.shape);return{a:()=>{const e=wm(Cg(n),Cg(r));let i=eg(t,tg(r,e));const o=pm(n.shape,s);return o.length>0&&(i=xg(i,o)),Km(i,n.shape)},b:()=>{const e=wm(Cg(n),Cg(r));let i=Vg(eg(t,tg(n,e)));const o=pm(r.shape,s);return o.length>0&&(i=xg(i,o)),Km(i,r.shape)}}}};function sy(t,e,n,r,s,i,o="channelsLast"){const[a,l]=uy(e);let u;if("channelsLast"===o)u=[a,l,t[3],t[3]];else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat "+o);u=[a,l,t[1],t[1]]}return oy(t,u,n,r,s,i,!1,o)}function iy(t,e,n,r,s,i,o="NDHWC"){const[a,l,u]=cy(e);let c,h;if("NDHWC"===o)h="channelsLast",c=[a,l,u,t[4],t[4]];else{if("NCDHW"!==o)throw new Error("Unknown dataFormat "+o);h="channelsFirst",c=[a,l,u,t[1],t[1]]}return ay(t,c,n,r,s,!1,h,i)}function oy(t,e,n,r,s,i,o=!1,a="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,h]=t;else{if("channelsFirst"!==a)throw new Error("Unknown dataFormat "+a);[l,h,u,c]=t}const[d,p,,f]=e,[m,g]=uy(n),[y,b]=uy(r),v=hy(d,y),x=hy(p,b),{padInfo:w,outHeight:C,outWidth:S}=function(t,e,n,r,s,i,o,a,l){let u,c,h;if("number"==typeof t){u={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const s=function(t,e,n,r,s){null==r&&(r=ly(t,e,n));const i=t[1],o=dy((t[0]-e+2*r)/n+1,s);Kp(ef(o),()=>`The output # of rows (${o}) must be an integer. Change the stride and/or zero pad parameters`);const a=dy((i-e+2*r)/n+1,s);return Kp(ef(a),()=>`The output # of columns (${a}) must be an integer. Change the stride and/or zero pad parameters`),[o,a]}([e,n],i,r,t,a);c=s[0],h=s[1]}else if("same"===t){c=Math.ceil(e/r),h=Math.ceil(n/s);const t=Math.max(0,(c-1)*r+i-e),a=Math.max(0,(h-1)*s+o-n),l=Math.floor(t/2),d=t-l,p=Math.floor(a/2);u={top:l,bottom:d,left:p,right:a-p,type:"SAME"}}else if("valid"===t)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-i+1)/r),h=Math.ceil((n-o+1)/s);else{if("object"!=typeof t)throw Error("Unknown padding parameter: "+t);{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],m="channelsLast"===l?t[2][1]:t[3][1];u={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=dy((e-i+d+p)/r+1,a),h=dy((n-o+f+m)/s+1,a)}}return{padInfo:u,outHeight:c,outWidth:h}}(s,u,c,m,g,v,x,i,a),_=o?f*h:f;let E;return"channelsFirst"===a?E=[l,_,C,S]:"channelsLast"===a&&(E=[l,C,S,_]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:h,outHeight:C,outWidth:S,outChannels:_,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:b,inShape:t,outShape:E,filterShape:e}}function ay(t,e,n,r,s,i=!1,o="channelsLast",a){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,h,d]=t;else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat "+o);[l,d,u,c,h]=t}const[p,f,m,,g]=e,[y,b,v]=cy(n),[x,w,C]=cy(r),S=hy(p,x),_=hy(f,w),E=hy(m,C),{padInfo:k,outDepth:A,outHeight:I,outWidth:N}=function(t,e,n,r,s,i,o,a,l,u,c){let h,d,p,f;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const i=function(t,e,n,r,s,i){null==s&&(s=ly(t,e,r));const o=t[1],a=t[2],l=dy((t[0]-e+2*s)/r+1,i);Kp(ef(l),()=>`The output # of depths (${l}) must be an integer. Change the stride and/or zero pad parameters`);const u=dy((o-e+2*s)/r+1,i);Kp(ef(u),()=>`The output # of rows (${u}) must be an integer. Change the stride and/or zero pad parameters`);const c=dy((a-e+2*s)/r+1,i);return Kp(ef(c),()=>`The output # of columns (${c}) must be an integer. Change the stride and/or zero pad parameters`),[l,u,c,1]}([e,n,r,1],a,0,s,t,c);d=i[0],p=i[1],f=i[2]}else if("same"===t){d=Math.ceil(e/s),p=Math.ceil(n/i),f=Math.ceil(r/o);const t=(d-1)*s+a-e,c=(p-1)*i+l-n,m=(f-1)*o+u-r,g=Math.floor(t/2),y=t-g,b=Math.floor(c/2),v=c-b,x=Math.floor(m/2);h={top:b,bottom:v,left:x,right:m-x,front:g,back:y,type:"SAME"}}else{if("valid"!==t)throw Error("Unknown padding parameter: "+t);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-a+1)/s),p=Math.ceil((n-l+1)/i),f=Math.ceil((r-u+1)/o)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(s,u,c,h,y,b,v,S,_,E,a),T=i?g*d:g;let R;return"channelsFirst"===o?R=[l,T,A,I,N]:"channelsLast"===o&&(R=[l,A,I,N,T]),{batchSize:l,dataFormat:o,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:A,outHeight:I,outWidth:N,outChannels:T,padInfo:k,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:_,effectiveFilterWidth:E,dilationDepth:x,dilationHeight:w,dilationWidth:C,inShape:t,outShape:R,filterShape:e}}function ly(t,e,n,r=1){const s=hy(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)}function uy(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function cy(t){return"number"==typeof t?[t,t,t]:t}function hy(t,e){return e<=1?t:t+(t-1)*(e-1)}function dy(t,e){if(!e)return t;switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error("Unknown roundingMode "+e)}}function py(t){const[e,n,r]=uy(t);return 1===e&&1===n&&1===r}function fy(t,e){return py(t)||py(e)}function my(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error("Unknown dataFormat "+t)}const gy=xm({avgPool3dBackprop_:function(t,e,n,r,s=[1,1,1],i,o){const a=bm(t,"dy","avgPool3dBackprop"),l=bm(e,"input","avgPool3dBackprop");let u=a,c=l,h=!1;4===l.rank&&(h=!0,u=Km(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),c=Km(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),Kp(5===u.rank,()=>"Error in avgPool3dBackprop: dy must be rank 5 but got rank "+u.rank+"."),Kp(5===c.rank,()=>"Error in avgPool3dBackprop: input must be rank 5 but got rank "+c.rank+"."),Kp(fy(r,s),()=>`Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides ${r} and dilations '${s}'`),null!=o&&Kp(ef(i),()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${o} but got pad ${i}.`);const d=lm.runKernelFunc(t=>{const e=iy(c.shape,n,r,s,i,o);return t.avgPool3dBackprop(u,c,e)},{dy:u,input:c},null,"AvgPool3DBackprop",{filterSize:n,strides:r,dilations:s,pad:i,dimRoundingMode:o});return h?Km(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),yy={kernelName:"AvgPool3D",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:s,strides:i,dilations:o,pad:a,dimRoundingMode:l}=n,u=null==o?[1,1,1]:o;return{x:()=>gy(t,r,s,i,u,a,l)}}},by=xm({avgPoolBackprop_:function(t,e,n,r,s){const i=bm(t,"dy","avgPoolBackprop"),o=bm(e,"input","avgPoolBackprop");Kp(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,u=!1;3===o.rank&&(u=!0,a=Km(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=Km(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Kp(4===l.rank,()=>"Error in avgPoolBackprop: dy must be rank 4 but got rank "+l.rank+"."),Kp(4===a.rank,()=>"Error in avgPoolBackprop: input must be rank 4 but got rank "+a.rank+".");const c=lm.runKernelFunc(t=>{const e=sy(a.shape,n,r,1,s);return t.avgPoolBackprop(l,a,e)},{dy:l,input:a},null,"AvgPoolBackprop",{filterSize:n,strides:r,pad:s});return u?Km(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),vy={kernelName:"AvgPool",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:s,strides:i,pad:o}=n;return{x:()=>by(t,r,s,i,o)}}},xy=xm({matMul_:function(t,e,n=!1,r=!1){let s=bm(t,"a","matMul"),i=bm(e,"b","matMul");[s,i]=nm(s,i),Kp(s.rank>=2&&i.rank>=2&&s.rank===i.rank,()=>`Error in matMul: inputs must have the same rank of at least 2, got ranks ${s.rank} and ${i.rank}.`);const o=n?s.shape[s.rank-2]:s.shape[s.rank-1],a=r?i.shape[i.rank-1]:i.shape[i.rank-2],l=n?s.shape[s.rank-1]:s.shape[s.rank-2],u=r?i.shape[i.rank-2]:i.shape[i.rank-1],c=s.shape.slice(0,-2),h=i.shape.slice(0,-2),d=Jp(c),p=Jp(h);Kp(tf(c,h),()=>`Error in matMul: outer dimensions (${c}) and (${h}) of Tensors with shapes ${s.shape} and `+i.shape+" must match."),Kp(o===a,()=>`Error in matMul: inner shapes (${o}) and (${a}) of Tensors with shapes ${s.shape} and ${i.shape} and transposeA=${n} and transposeB=${r} must match.`);const f=s.shape.slice(0,-2).concat([l,u]),m=Km(s,n?[d,o,l]:[d,l,o]),g=Km(i,r?[p,u,a]:[p,a,u]),y=lm.runKernelFunc((t,e)=>(e([m,g]),t.batchMatMul(m,g,n,r)),{a:m,b:g},null,"BatchMatMul",{transposeA:n,transposeB:r});return Km(y,f)}}),wy={kernelName:"BatchMatMul",inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[r,s]=e,{transposeA:i,transposeB:o}=n;return i||o?!i&&o?{a:()=>xy(t,s,!1,!1),b:()=>xy(t,r,!0,!1)}:i&&!o?{a:()=>xy(s,t,!1,!0),b:()=>xy(r,t,!1,!1)}:{a:()=>xy(s,t,!0,!0),b:()=>xy(t,r,!0,!0)}:{a:()=>xy(t,s,!1,!0),b:()=>xy(r,t,!0,!1)}}},Cy=xm({spaceToBatchND_:function(t,e,n){const r=bm(t,"x","spaceToBatchND");return Kp(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),Kp(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),Kp(r.shape.reduce((t,r,s)=>s>0&&s<=e.length?t&&(r+n[s-1][0]+n[s-1][1])%e[s-1]==0:t,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`),lm.runKernelFunc(t=>t.spaceToBatchND(r,e,n),{x:r},null,"SpaceToBatchND",{blockShape:e,paddings:n})}}),Sy={kernelName:"BatchToSpaceND",gradFunc:(t,e,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>Cy(t,r,s)}}},_y={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const r=n.inputShape,s=n.shape,i=Array.from(s);for(let a=r.length-1;a>=0;a--)if(r[a]===s[a])i[a]=1;else if(1!==r[a])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${s}].`);const o=[];for(let a=0;a<i.length;a++)i[a]>1&&o.push(a);return{x:()=>xg(t,o,!0)}}},Ey=xm({split_:function(t,e,n=0){const r=bm(t,"x","split"),s=uf(n,r.shape)[0];let i;return"number"==typeof e?(Kp(r.shape[s]%e==0,()=>"Number of splits must evenly divide the axis."),i=new Array(e).fill(r.shape[s]/e)):(Kp(r.shape[s]===e.reduce((t,e)=>t+e),()=>"The sum of sizes must match the size of the axis dimension."),i=e),lm.runKernelFunc((t,e)=>t.split(r,i,s),{x:r},null,"SplitV",{numOrSizeSplits:e,axis:n})}}),ky={kernelName:"Concat",saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map(t=>t.shape),{axis:s}=n,i=uf(s,e[0].shape)[0],o=r.map(t=>t[i]);return Ey(t,o,i).map(t=>()=>t)}},Ay=xm({conv2DBackpropFilter_:function(t,e,n,r,s,i="NHWC",o){let a=t;3===t.rank&&(a=Km(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=Km(e,[1,e.shape[0],e.shape[1],e.shape[2]])),Kp(4===a.rank,()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+a.shape+"."),Kp(4===l.rank,()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+l.shape+"."),Kp(4===n.length,()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+n+".");const u="NHWC"===i?a.shape[3]:a.shape[1],c="NHWC"===i?l.shape[3]:l.shape[1];return Kp(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),Kp(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),null!=o&&Kp(ef(s),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`),lm.runKernelFunc(t=>{const e=my(i),u=oy(a.shape,n,r,1,s,o,!1,e);return t.conv2dDerFilter(a,l,u)},{x:a,dy:l},null,"Conv2DBackpropFilter",{strides:r,pad:s,dataFormat:i,dimRoundingMode:o})}}),Iy=xm({conv2DBackpropInput_:function(t,e,n,r,s,i="NHWC",o){Kp(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,l=e,u=!1;3===e.rank&&(u=!0,l=Km(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,t[0],t[1],t[2]]),Kp(4===a.length,()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+a.length+"."),Kp(4===l.rank,()=>"Error in conv2dDerInput: dy must be rank 4, but got rank "+l.rank),Kp(4===n.rank,()=>"Error in conv2dDerInput: filter must be rank 4, but got rank "+n.rank);const c="NHWC"===i?a[3]:a[1],h="NHWC"===i?l.shape[3]:l.shape[1];Kp(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),Kp(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),null!=o&&Kp(ef(s),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const d=lm.runKernelFunc((t,e)=>{const u=my(i),c=oy(a,n.shape,r,1,s,o,!1,u),h=t.conv2dDerInput(l,n,c);return e([l,n]),h},{dy:l,filter:n},null,"Conv2DBackpropInput",{strides:r,pad:s,dataFormat:i,dimRoundingMode:o});return u?Km(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Ny={kernelName:"Conv2D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,s]=e,{dilations:i,strides:o,pad:a,dataFormat:l}=n;return Kp(py(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>Iy(r.shape,t,s,o,a,l),filter:()=>Ay(r,t,s.shape,o,a,l)}}},Ty=xm({conv2d_:function(t,e,n,r,s="NHWC",i=[1,1],o){const a=bm(t,"x","conv2d"),l=bm(e,"filter","conv2d");let u=a,c=!1;3===a.rank&&(c=!0,u=Km(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Kp(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),Kp(4===l.rank,()=>"Error in conv2d: filter must be rank 4, but got rank "+l.rank+"."),null!=o&&Kp(ef(r),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`);const h="NHWC"===s?u.shape[3]:u.shape[1];Kp(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),Kp(fy(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);const d=lm.runKernelFunc((t,e)=>{const a=my(s),c=oy(u.shape,l.shape,n,i,r,o,!1,a),h=t.conv2d(u,l,c);return e([u,l]),h},{x:u,filter:l},null,"Conv2D",{strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o});return c?Km(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Ry={kernelName:"Conv2DBackpropInput",inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,s]=e,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=n;return{dy:()=>Ty(t,s,i,o,a,1,l),filter:()=>Ay(t,r,s.shape,i,o,a,l)}}},$y=xm({conv3DBackpropFilter_:function(t,e,n,r,s){let i=t;4===t.rank&&(i=Km(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let o=e;return 4===o.rank&&(o=Km(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),Kp(5===i.rank,()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+i.shape+"."),Kp(5===o.rank,()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+o.shape+"."),Kp(5===n.length,()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+n+"."),Kp(i.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`),Kp(o.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`),lm.runKernelFunc(t=>{const e=ay(i.shape,n,r,1,s);return t.conv3dDerFilter(i,o,e)},{x:i,y:o},null,"Conv3DBackpropFilterV2",{strides:r,pad:s})}}),Dy=xm({conv3DBackpropInput_:function(t,e,n,r,s){Kp(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let i=t,o=e,a=!1;4===e.rank&&(a=!0,o=Km(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,t[0],t[1],t[2],t[3]]);const l=i[4],u=o.shape[4];Kp(5===i.length,()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+i.length+"."),Kp(5===o.rank,()=>"Error in conv3dDerInput: dy must be rank 5, but got rank "+o.rank),Kp(5===n.rank,()=>"Error in conv3dDerInput: filter must be rank 5, but got rank "+n.rank),Kp(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),Kp(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const c=lm.runKernelFunc(t=>{const e=ay(i,n.shape,r,1,s);return t.conv3dDerInput(o,n,e)},{dy:o},null,"Conv3DBackpropInputV2",{pad:s});return a?Km(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),Oy={kernelName:"Conv3D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:s,pad:i}=n;Kp(py(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[o,a]=e;return{x:()=>Dy(o.shape,t,a,s,i),filter:()=>$y(o,t,a.shape,s,i)}}},Fy=xm({transpose_:function(t,e){const n=bm(t,"x","transpose");return null==e&&(e=n.shape.map((t,e)=>e).reverse()),Kp(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(t=>{Kp(t>=0&&t<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+" but got "+e)}),n.rank<=1?n.clone():lm.runKernelFunc(t=>t.transpose(n,e),{x:n},null,"Transpose",{perm:e})}}),My=xm({cumsum_:function(t,e=0,n=!1,r=!1){const s=bm(t,"x","cumsum");return lm.runKernelFunc((t,i)=>{const o=lg([e],s.rank);let a=s;null!=o&&(a=Fy(s,o));const l=cg(1,s.rank)[0];let u=t.cumsum(a,l,n,r);return i([s]),null!=o&&(u=Fy(u,o)),u},{x:s},null,"Cumsum",{axis:e,exclusive:n,reverse:r})}}),Ly={kernelName:"Cumsum",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:s,exclusive:i,reverse:o}=n;return{x:()=>{const e=lg([s],r.rank);let n=My(t,s,i,!o);return null!=e&&(n=Fy(n,e)),n}}}},Py=xm({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,r){let s=t;3===t.rank&&(s=Km(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let i=e;return 3===i.rank&&(i=Km(e,[1,e.shape[0],e.shape[1],e.shape[2]])),lm.runKernelFunc(t=>t.depthwiseConv2DDerFilter(s,i,r),{x:s,dy:i},null,"DepthwiseConv2dNativeBackpropFilter")}}),zy=xm({depthwiseConv2dNativeBackpropInput_:function(t,e,n,r){let s=e,i=!1;3===e.rank&&(i=!0,s=Km(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const o=lm.runKernelFunc(t=>t.depthwiseConv2DDerInput(s,n,r),{dy:s},null,"DepthwiseConv2dNativeBackpropInput");return i?Km(o,[o.shape[1],o.shape[2],o.shape[3]]):o}}),By={kernelName:"DepthwiseConv2dNative",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:s,pad:i,dimRoundingMode:o}=n,a=null==r?[1,1]:r;Kp(py(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=e;Kp(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),Kp(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),Kp(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),Kp(fy(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),null!=o&&Kp(ef(i),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${i}.`);const c=oy(l.shape,u.shape,s,a,i,o,!0);return{x:()=>zy(l.shape,t,u,c),filter:()=>Py(l,t,u.shape,c)}}},Vy={kernelName:"Div",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=fm(n.shape,r.shape);return{a:()=>{const e=tg(t,r.toFloat()),i=pm(n.shape,s);return i.length>0?xg(e,i).reshape(n.shape):e},b:()=>{let e=eg(t,n.toFloat());const i=pm(r.shape,s);i.length>0&&(e=Km(xg(e,i),r.shape));const o=Cg(r);return Vg(tg(e,o.toFloat()))}}}},Uy={kernelName:"Elu",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r=e=>e.eluDer(t,n),s={dy:t,y:n};return{x:()=>lm.runKernelFunc(r,s,null,"EluGrad")}}},Wy={kernelName:"FloorDiv",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=fm(n.shape,r.shape);return{a:()=>{const e=t.div(r.toFloat()),i=pm(n.shape,s);return i.length>0?e.sum(i).reshape(n.shape):e},b:()=>{let e=t.mul(n.toFloat());const i=pm(r.shape,s);i.length>0&&(e=e.sum(i).reshape(r.shape));const o=r.square();return e.div(o.toFloat()).neg()}}}},jy=xm({sub_:function(t,e){let n=bm(t,"a","sub"),r=bm(e,"b","sub");return[n,r]=nm(n,r),lm.runKernelFunc((t,e)=>{const s=t.subtract(n,r);return e([n,r]),s},{a:n,b:r},null,"Sub")}}),Hy=xm({tile_:function(t,e){const n=bm(t,"x","tile",null);return Kp(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`),lm.runKernelFunc((t,r)=>{const s=t.tile(n,e);return r([n]),s},{x:n},null,"Tile",{reps:e},[n])}}),qy={kernelName:"FusedBatchNorm",inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[s,i,o,a]=e,l=null==a?Nm(1):a,u=pm(i.shape,s.shape),c=[];if(1===i.rank){for(let t=0;t<s.shape.length-1;++t)c.push(s.shape[t]);c.push(1)}const h=jy(s,i),d=eg(t,l),p=jg(wm(o,Nm(r))),f=eg(eg(eg(p,p),p),Nm(-.5));return{x:()=>Km(eg(eg(t,1===i.rank?Hy(p.as4D(1,1,1,i.shape[0]),c):p),l),s.shape),mean:()=>{let t=eg(eg(p,Nm(-1)),d);return 1===i.rank&&(t=xg(t,u)),Km(t,i.shape)},variance:()=>{let t=eg(eg(f,h),d);return 1===i.rank&&(t=xg(t,u)),Km(t,i.shape)},scale:()=>{const e=eg(h,p);let n=eg(t,e);return 1===i.rank&&(n=xg(n,u)),Km(n,i.shape)},offset:()=>{let e=t;return 1===i.rank&&(e=xg(e,u)),Km(e,i.shape)}}}},Gy={kernelName:"GreaterEqual",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>Um(n),b:()=>Um(r)}}},Ky=xm({localResponseNormalizationBackprop_:function(t,e,n,r=5,s=1,i=1,o=.5){return lm.runKernelFunc(a=>a.LRNGrad(n,t,e,r,s,i,o),{x:t,y:e,dy:n},null,"LRNBackprop",{depthRadius:r,bias:s,alpha:i,beta:o})}}),Xy={kernelName:"LRN",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,s]=e,{depthRadius:i,bias:o,alpha:a,beta:l}=n;return{x:()=>Ky(r,s,t,i,o,a,l)}}},Yy={kernelName:"Max",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:s}=r,[i,o]=e,a=uf(s,i.shape),l=lg(a,i.rank),u=hg(t,o,i,a,l);return{x:()=>{let t=u.x();return null!=l&&(t=Fy(t)),t}}}},Zy=xm({greaterEqual_:function(t,e){let n=bm(t,"a","greaterEqual"),r=bm(e,"b","greaterEqual");return[n,r]=nm(n,r),fm(n.shape,r.shape),lm.runKernelFunc((t,e)=>{const s=t.greaterEqual(n,r);return e([n,r]),s},{a:n,b:r},null,"GreaterEqual")}}),Jy=xm({less_:function(t,e){let n=bm(t,"a","less"),r=bm(e,"b","less");return[n,r]=nm(n,r),fm(n.shape,r.shape),lm.runKernelFunc(t=>t.less(n,r),{a:n,b:r},null,"Less")}}),Qy={kernelName:"Maximum",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>eg(t,qm(Zy(n,r),"float32")),b:()=>eg(t,qm(Jy(n,r),"float32"))}}},tb=xm({maxPool3dBackprop_:function(t,e,n,r,s,i=[1,1,1],o,a){const l=bm(t,"dy","maxPool3dBackprop"),u=bm(e,"input","maxPool3dBackprop"),c=bm(n,"output","maxPool3dBackprop");let h=l,d=u,p=c,f=!1;4===u.rank&&(f=!0,h=Km(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=Km(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),p=Km(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),Kp(5===h.rank,()=>"Error in maxPool3dBackprop: dy must be rank 5 but got rank "+h.rank+"."),Kp(5===d.rank,()=>"Error in maxPool3dBackprop: input must be rank 5 but got rank "+d.rank+"."),Kp(5===p.rank,()=>"Error in maxPool3dBackprop: output must be rank 5 but got rank "+p.rank+"."),Kp(fy(s,i),()=>`Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides ${s} and dilations '${i}'`),null!=a&&Kp(ef(o),()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`);const m=lm.runKernelFunc(t=>{const e=iy(d.shape,r,s,i,o,a);return t.maxPool3dBackprop(h,d,p,e)},{dy:h,input:d,output:p},null,"MaxPool3DBackprop",{filterSize:r,strides:s,dilations:i,pad:o,dimRoundingMode:a});return f?Km(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),eb={kernelName:"MaxPool3D",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,s]=e,{filterSize:i,strides:o,dilations:a,pad:l,dimRoundingMode:u}=n,c=null==a?[1,1,1]:a;return{x:()=>tb(t,r,s,i,o,c,l,u)}}},nb=xm({maxPoolBackprop_:function(t,e,n,r,s,i,o){const a=bm(t,"dy","maxPoolBackprop"),l=bm(e,"input","maxPoolBackprop"),u=bm(n,"output","maxPoolBackprop");return Kp(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),Kp(4===a.rank,()=>"Error in maxPoolBackprop: dy must be rank 4 but got rank "+a.rank+"."),Kp(4===l.rank,()=>"Error in maxPoolBackprop: input must be rank 4 but got rank "+l.rank+"."),null!=o&&Kp(ef(i),()=>`Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode ${o} but got pad ${i}.`),lm.runKernelFunc(t=>{const e=sy(l.shape,r,s,1,i,o);return t.maxPoolBackprop(a,l,u,e)},{dy:a,input:l,output:u},null,"MaxPoolBackprop",{filterSize:r,strides:s,pad:i,dimRoundingMode:o})}}),rb={kernelName:"MaxPool",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,s]=e,{filterSize:i,strides:o,pad:a}=n;return{x:()=>nb(t,r,s,i,o,a)}}},sb=xm({greater_:function(t,e){let n=bm(t,"a","greater"),r=bm(e,"b","greater");return[n,r]=nm(n,r),fm(n.shape,r.shape),lm.runKernelFunc(t=>t.greater(n,r),{a:n,b:r},null,"Greater")}}),ib=xm({lessEqual_:function(t,e){let n=bm(t,"a","lessEqual"),r=bm(e,"b","lessEqual");return[n,r]=nm(n,r),fm(n.shape,r.shape),lm.runKernelFunc((t,e)=>{const s=t.lessEqual(n,r);return e([n,r]),s},{a:n,b:r},null,"LessEqual")}}),ob={kernelName:"Minimum",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>eg(t,qm(ib(n,r),"float32")),b:()=>eg(t,qm(sb(n,r),"float32"))}}},ab={kernelName:"Mod",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=fm(n.shape,r.shape);return{a:()=>{const e=pm(n.shape,s);return e.length>0?Km(xg(t,e),n.shape):t},b:()=>{const e=eg(t,Vg(Lg(tg(n,r)))),i=pm(r.shape,s);return i.length>0?Km(xg(e,i),r.shape):e}}}},lb={kernelName:"Multiply",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=fm(n.shape,r.shape);return{a:()=>{const e=eg(t,qm(r,"float32")),i=pm(n.shape,s);return i.length>0?Km(xg(e,i),n.shape):e},b:()=>{const e=eg(t,qm(n,"float32")),i=pm(r.shape,s);return i.length>0?Km(xg(e,i),r.shape):e}}}},ub={kernelName:"OneHot",inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>Pm(n.shape,"float32")}}},cb={kernelName:"PadV2",inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:s}=n,i=s.map(t=>t[0]);return{x:()=>t.slice(i,r.shape)}}};function hb(t,e){const n=[];for(let i=0;i<e.length;i++)e[i]&&n.push(i);const r=jm(t,"int32"),s=jm([n.length,t.length],"int32");for(let i=0;i<n.length;i++){const e=r.indexToLoc(n[i]);s.values.set(e,i*t.length)}return s.toTensor()}const db=xm({logicalAnd_:function(t,e){const n=bm(t,"a","logicalAnd","bool"),r=bm(e,"b","logicalAnd","bool");return fm(n.shape,r.shape),lm.runKernelFunc(t=>t.logicalAnd(n,r),{a:n,b:r},null,"LogicalAnd")}}),pb=xm({logicalNot_:function(t){const e=bm(t,"x","logicalNot","bool");return lm.runKernelFunc(t=>t.logicalNot(e),{$x:e})}}),fb=xm({logicalOr_:function(t,e){const n=bm(t,"a","logicalOr","bool"),r=bm(e,"b","logicalOr","bool");return fm(n.shape,r.shape),lm.runKernelFunc(t=>t.logicalOr(n,r),{$a:n,$b:r})}}),mb=xm({logicalXor_:function(t,e){const n=bm(t,"a","logicalXor","bool"),r=bm(e,"b","logicalXor","bool");return fm(n.shape,r.shape),fb(t,e).logicalAnd(db(t,e).logicalNot())}}),gb=xm({where_:function(t,e,n){const r=bm(e,"a","where"),s=bm(n,"b","where"),i=bm(t,"condition","where","bool");return Xp(r.shape,s.shape,"Error in where: "),1===i.rank?Kp(i.shape[0]===r.shape[0],()=>"The first dimension of `a` must match the size of `condition`."):Xp(i.shape,s.shape,"Error in where: "),lm.runKernelFunc((t,e)=>{const n=t.select(i,r,s);return e([i]),n},{condition:i,t:r,e:s},(t,e)=>{const[n]=e;return{condition:()=>Um(n).toFloat(),t:()=>t.mul(n.cast(t.dtype)),e:()=>t.mul(n.logicalNot().cast(t.dtype))}},"SelectV2")}}),yb=async function(t){const e=bm(t,"condition","whereAsync","bool"),n=await e.data(),r=hb(e.shape,n);return t!==e&&e.dispose(),r},bb=xm({pow_:function(t,e){let n=bm(t,"base","pow"),r=bm(e,"exp","pow");return[n,r]=nm(n,r),lm.runKernelFunc((t,e)=>{const s=t.pow(n,r);return e([n,r,s]),s},{a:n,b:r},null,"Pow")}}),vb={kernelName:"Pow",inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,s]=e,i=n,o=r,a=fm(i.shape,o.shape);return{a:()=>{const e=qm(o,"float32");let n=eg(t,eg(e,bb(i,jy(e,Nm(1)))));const r=pm(i.shape,a);return r.length>0&&(n=xg(n,r)),Km(n,i.shape)},b:()=>{const e=sb(i,0),n=gb(e,Pg(i),Um(i));let r=eg(t,eg(s,n));const l=pm(o.shape,a);return l.length>0&&(r=xg(r,l)),Km(r,o.shape)}}}},xb={kernelName:"Prelu",inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,s=sb(n,0);return{x:()=>gb(s,t,eg(t,r)),alpha:()=>{let e=gb(s,Um(t),eg(t,n));const i=pm(r.shape,t.shape);return i.length>0&&(e=xg(e,i)),Km(e,r.shape)}}}},wb={kernelName:"Relu6",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=eg(ib(n,6),ty(n));return{x:()=>eg(t,qm(r,"float32"))}}},Cb={kernelName:"Relu",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>eg(t,qm(ty(n),"float32"))}}},Sb=1.7580993408473768,_b=1.0507009873554805,Eb={kernelName:"Selu",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=sb(n,Nm(0)),r=Nm(Sb),s=Nm(_b),i=eg(t,s),o=eg(eg(t,r),Fg(qm(n,"float32")));return gb(e,i,o)}}}},kb=xm({batchToSpaceND_:function(t,e,n){const r=bm(t,"x","batchToSpaceND"),s=e.reduce((t,e)=>t*e);return Kp(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),Kp(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),Kp(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`),lm.runKernelFunc(t=>t.batchToSpaceND(r,e,n),{x:r},null,"BatchToSpaceND",{blockShape:e,crops:n})}}),Ab={kernelName:"SpaceToBatchND",gradFunc:(t,e,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>kb(t,r,s)}}},Ib={kernelName:"SplitV",gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>Wm(t,r)}}},Nb={kernelName:"Square",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>eg(t,eg(n.toFloat(),2))}}},Tb={kernelName:"SquaredDifference",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Nm(2);return{a:()=>eg(t,eg(s,jy(n,r))),b:()=>eg(t,eg(s,jy(r,n)))}}},Rb={kernelName:"Sub",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=fm(n.shape,r.shape);return{a:()=>{let e=t;const r=pm(n.shape,s);return r.length>0&&(e=xg(e,r)),Km(e,n.shape)},b:()=>{let e=t;const n=pm(r.shape,s);return n.length>0&&(e=xg(e,n)),Km(Vg(e),r.shape)}}}},$b=xm({pad_:function(t,e,n=0){const r=bm(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return lm.runKernelFunc((t,s)=>(s([r]),t.pad(r,e,n)),{x:r},null,"PadV2",{paddings:e,constantValue:n})}});function Db(t,e,n){Kp(t.rank===e.length,()=>`Error in slice${t.rank}D: Length of begin ${e} must match the rank of the array (${t.rank}).`),Kp(t.rank===n.length,()=>`Error in slice${t.rank}D: Length of size ${n} must match the rank of the array (${t.rank}).`);for(let r=0;r<t.rank;++r)Kp(e[r]+n[r]<=t.shape[r],()=>`Error in slice${t.rank}D: begin[${r}] + size[${r}] (${e[r]+n[r]}) would overflow input.shape[${r}] (${t.shape[r]})`)}function Ob(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function Fb(t,e,n){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((e[s]-t[s])/n[s]);return r}function Mb(t,e,n){const r=[...t];for(let s=0;s<n;s++)0===s?r[e]=1:(r.splice(e,0,1),r.pop());return r}function Lb(t,e,n){const r=[...t];for(let s=0;s<n;s++)0===s?r[e]=0:(r.splice(e,0,0),r.pop());return r}function Pb(t,e,n,r){const s=[...t];for(let i=0;i<n;i++)0===i?s[e]=Number.MAX_SAFE_INTEGER:(s.splice(e,0,Number.MAX_SAFE_INTEGER),s.pop());for(let i=0;i<s.length;i++)s[i]=Wp(0,s[i],r[i]);return s}function zb(t,e,n){let r=t[e];return(n&1<<e||null==r)&&(r=1),r}function Bb(t,e,n,r,s,i){let o=e[s];(t&1<<s||i&1<<s||null==o)&&(o=(n[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const a=r[s];return o<0&&(o+=a),o=Wp(0,o,a-1),o}function Vb(t,e,n,r,s,i){let o=e[s];const a=n[s]||1;(t&1<<s||i&1<<s||null==o)&&(o=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),o=a>0?Wp(0,o,l):Wp(-1,o,l-1),o}function Ub(t,e,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(e[s]>0||n[s]!==t[s])return!1;return!0}function Wb(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}const jb=xm({slice_:function(t,e,n){const r=bm(t,"x","slice");if(0===r.rank)throw new Error("Slicing scalar is not possible");let s,i;s="number"==typeof e?[e,...new Array(r.rank-1).fill(0)]:e.length<r.rank?e.concat(new Array(r.rank-e.length).fill(0)):e.slice(),s.forEach(t=>{Kp(-1!==t,()=>"slice() does not support negative begin indexing.")}),i=null==n?new Array(r.rank).fill(-1):"number"==typeof n?[n,...new Array(r.rank-1).fill(-1)]:n.length<r.rank?n.concat(new Array(r.rank-n.length).fill(-1)):n,i=i.map((t,e)=>t>=0?t:(Kp(-1===t,()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${e}.`),r.shape[e]-s[e])),Db(r,s,i);const o=r.shape;return lm.runKernelFunc(t=>t.slice(r,s,i),{x:r},t=>{const e=[];for(let n=0;n<t.rank;n++)e.push([s[n],o[n]-s[n]-i[n]]);return{x:()=>$b(t,e)}},"Slice",{begin:s,size:i})}}),Hb=xm({slice1d_:function(t,e,n){const r=bm(t,"x","slice1d");return Kp(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),jb(r,[e],[n])}}),qb=xm({slice2d_:function(t,e,n){const r=bm(t,"x","slice2d");return Kp(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),jb(r,e,n)}}),Gb=xm({slice3d_:function(t,e,n){const r=bm(t,"x","slice3d");return Kp(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),jb(r,e,n)}}),Kb=xm({slice4d_:function(t,e,n){const r=bm(t,"x","slice4d");return Kp(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),jb(r,e,n)}}),Xb=[mm,{kernelName:"AddN",saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach((e,r)=>{n[r]=()=>t.clone()}),n}},ry,vy,yy,wy,Sy,_y,ky,Ny,Ry,Oy,Ly,By,Vy,Uy,Wy,qy,Gy,{kernelName:"Identity",gradFunc:t=>({x:()=>t.toFloat()})},Xy,ub,cb,Ib,Yy,Ab,Yy,Qy,rb,eb,ob,ab,lb,ub,cb,vb,xb,Cb,wb,Eb,Ab,Ib,Nb,Tb,{kernelName:"Tile",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:s}=n;return{x:()=>{let e=Um(r);if(1===r.rank)for(let n=0;n<s[0];++n)e=wm(e,jb(t,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<s[0];++n)for(let i=0;i<s[1];++i)e=wm(e,jb(t,[n*r.shape[0],i*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<s[0];++n)for(let i=0;i<s[1];++i)for(let o=0;o<s[2];++o)e=wm(e,jb(t,[n*r.shape[0],i*r.shape[1],o*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+r.rank+" tensors yet.");for(let n=0;n<s[0];++n)for(let i=0;i<s[1];++i)for(let o=0;o<s[2];++o)for(let a=0;a<s[3];++a)e=wm(e,jb(t,[n*r.shape[0],i*r.shape[1],o*r.shape[2],a*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return e}}}},{kernelName:"Transpose",gradFunc:(t,e,n)=>{const r=n,{perm:s}=r,i=ug(s);return{x:()=>Fy(t,i)}}},Rb];for(const CF of Xb)Bp(CF);let Yb;Np().get("IS_BROWSER")&&Np().setPlatform("browser",new class{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Browser's encoder only supports utf-8, but got "+e);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}),Np().get("IS_NODE")&&Np().setPlatform("node",new class{constructor(){this.util=n(2),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Np().global.fetch?Np().global.fetch(t,e):(null==Yb&&(Yb=n(1)),Yb(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Node built-in encoder only supports utf-8, but got "+e);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});const Zb={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};async function Jb(t,e){const n=[],r=[],s=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);for(let i=0;i<s.length;++i){const o=s[i],a=Array.isArray(t)?t[i].tensor:t[o];if("float32"!==a.dtype&&"int32"!==a.dtype&&"bool"!==a.dtype&&"string"!==a.dtype&&"complex64"!==a.dtype)throw new Error(`Unsupported dtype in weight '${o}': ${a.dtype}`);const l={name:o,shape:a.shape,dtype:a.dtype};if("string"===a.dtype){const t=new Promise(async t=>{const e=await a.bytes(),n=e.reduce((t,e)=>t+e.length,0)+4*e.length,r=new Uint8Array(n);let s=0;for(let i=0;i<e.length;i++){const t=e[i],n=new Uint8Array(new Uint32Array([t.length]).buffer);r.set(n,s),s+=4,r.set(t,s),s+=t.length}t(r)});r.push(t)}else r.push(a.data());null!=e&&(l.group=e),n.push(l)}return{data:tv(await Promise.all(r)),specs:n}}function Qb(t,e){const n={};let r,s=0;for(const i of e){const e=i.name,o=i.dtype,a=i.shape,l=Jp(a);let u;if("quantization"in i){const n=i.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${i.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${i.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==o)throw new Error(`Weight ${i.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${o}.`)}const a=Zb[n.dtype],c=t.slice(s,s+l*a),h="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===o)if("uint8"===n.dtype||"uint16"===n.dtype){u=new Float32Array(h.length);for(let t=0;t<h.length;t++)u[t]=h[t]*n.scale+n.min}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===r&&(r=ov()),u=r(h)}else{if("int32"!==o)throw new Error(`Unsupported dtype in weight '${e}': ${o}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);u=new Int32Array(h.length);for(let t=0;t<h.length;t++)u[t]=Math.round(h[t]*n.scale+n.min)}s+=l*a}else if("string"===o){const e=Jp(i.shape);u=[];for(let n=0;n<e;n++){const e=new Uint32Array(t.slice(s,s+4))[0];s+=4;const n=new Uint8Array(t.slice(s,s+e));u.push(n),s+=e}}else{const r=Zb[o],i=t.slice(s,s+l*r);if("float32"===o)u=new Float32Array(i);else if("int32"===o)u=new Int32Array(i);else if("bool"===o)u=new Uint8Array(i);else{if("complex64"!==o)throw new Error(`Unsupported dtype in weight '${e}': ${o}`);{u=new Float32Array(i);const t=new Float32Array(u.length/2),r=new Float32Array(u.length/2);for(let e=0;e<t.length;e++)t[e]=u[2*e],r[e]=u[2*e+1];const s=Am(t,a,"float32"),o=Am(r,a,"float32");n[e]=_m(s,o)}}s+=l*r}"complex64"!==o&&(n[e]=Am(u,a,o))}return n}function tv(t){if(null===t)throw new Error("Invalid input value: "+JSON.stringify(t));let e=0;const n=[];t.forEach(t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+t.constructor.name)});const r=new Uint8Array(e);let s=0;return n.forEach(t=>{r.set(new Uint8Array(t.buffer),s),s+=t.byteLength}),r.buffer}const ev="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function nv(t){return ev?Buffer.byteLength(t):new Blob([t]).size}function rv(t){if(1===t.length)return t[0];let e=0;t.forEach(t=>{e+=t.byteLength});const n=new Uint8Array(e);let r=0;return t.forEach(t=>{n.set(new Uint8Array(t),r),r+=t.byteLength}),n.buffer}function sv(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);const e=t.split("/");return e[e.length-1]}function iv(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:nv(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:nv(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function ov(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;0==(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return r=>{const s=new ArrayBuffer(4*r.length),i=new Uint32Array(s);for(let o=0;o<r.length;o++){const s=r[o];i[o]=t[n[s>>10]+(1023&s)]+e[s>>10]}return new Float32Array(s)}}class av{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==av.instance&&(av.instance=new av),av.instance}static registerSaveRouter(t){av.getInstance().saveRouters.push(t)}static registerLoadRouter(t){av.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return av.getHandlers(t,"save")}static getLoadHandlers(t,e){return av.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?av.getInstance().loadRouters:av.getInstance().saveRouters).forEach(e=>{const s=e(t,n);null!==s&&r.push(s)}),r}}const lv=t=>av.registerSaveRouter(t),uv=t=>av.registerLoadRouter(t),cv=t=>av.getSaveHandlers(t),hv=(t,e)=>av.getLoadHandlers(t,e);class dv{constructor(){this.managers={}}static getInstance(){return null==dv.instance&&(dv.instance=new dv),dv.instance}static registerManager(t,e){Kp(null!=t,()=>"scheme must not be undefined or null."),t.endsWith("://")&&(t=t.slice(0,t.indexOf("://"))),Kp(t.length>0,()=>"scheme must not be an empty string.");const n=dv.getInstance();Kp(null==n.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=e}static getManager(t){const e=this.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}function pv(t){if(-1===t.indexOf("://"))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+dv.getSchemes().join(","));return{scheme:t.split("://")[0],path:t.split("://")[1]}}async function fv(t,e,n=!1){Kp(t!==e,()=>`Old path and new path are the same: '${t}'`);const r=av.getLoadHandlers(t);Kp(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),Kp(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);const s=r[0],i=av.getSaveHandlers(e);Kp(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),Kp(i.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const o=i[0],a=pv(t).scheme,l=pv(t).path,u=a===pv(t).scheme,c=await s.load();n&&u&&await dv.getManager(a).removeModel(l);const h=await o.save(c);return n&&!u&&await dv.getManager(a).removeModel(l),h.modelArtifactsInfo}async function mv(){const t=dv.getSchemes(),e={};for(const n of t){const t=await dv.getManager(n).listModels();for(const r in t)e[n+"://"+r]=t[r]}return e}async function gv(t){const e=pv(t);return dv.getManager(e.scheme).removeModel(e.path)}async function yv(t,e){return fv(t,e,!1)}async function bv(t,e){return fv(t,e,!0)}function vv(){if(!Np().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function xv(t){const e=t.result;e.createObjectStore("models_store",{keyPath:"modelPath"}),e.createObjectStore("model_info_store",{keyPath:"modelPath"})}class wv{constructor(t){if(this.indexedDB=vv(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((t,n)=>{const r=this.indexedDB.open("tensorflowjs",1);r.onupgradeneeded=()=>xv(r),r.onsuccess=()=>{const s=r.result;if(null==e){const e=s.transaction("models_store","readonly"),r=e.objectStore("models_store").get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(r.result.modelArtifacts)},r.onerror=t=>(s.close(),n(r.error)),e.oncomplete=()=>s.close()}else{const r=iv(e),i=s.transaction("model_info_store","readwrite");let o=i.objectStore("model_info_store");const a=o.put({modelPath:this.modelPath,modelArtifactsInfo:r});let l;a.onsuccess=()=>{l=s.transaction("models_store","readwrite");const a=l.objectStore("models_store").put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r});a.onsuccess=()=>t({modelArtifactsInfo:r}),a.onerror=t=>{o=i.objectStore("model_info_store");const e=o.delete(this.modelPath);e.onsuccess=()=>(s.close(),n(a.error)),e.onerror=t=>(s.close(),n(a.error))}},a.onerror=t=>(s.close(),n(a.error)),i.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}}},r.onerror=t=>n(r.error)})}}wv.URL_SCHEME="indexeddb://";const Cv=t=>{return Np().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(wv.URL_SCHEME)?(e=t.slice(wv.URL_SCHEME.length),new wv(e)):null;var e};av.registerSaveRouter(Cv),av.registerLoadRouter(Cv);class Sv{constructor(){this.indexedDB=vv()}async listModels(){return new Promise((t,e)=>{const n=this.indexedDB.open("tensorflowjs",1);n.onupgradeneeded=()=>xv(n),n.onsuccess=()=>{const r=n.result,s=r.transaction("model_info_store","readonly"),i=s.objectStore("model_info_store").getAll();i.onsuccess=()=>{const e={};for(const t of i.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},i.onerror=t=>(r.close(),e(i.error)),s.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)})}async removeModel(t){var e;return t=(e=t).startsWith(wv.URL_SCHEME)?e.slice(wv.URL_SCHEME.length):e,new Promise((e,n)=>{const r=this.indexedDB.open("tensorflowjs",1);r.onupgradeneeded=()=>xv(r),r.onsuccess=()=>{const s=r.result,i=s.transaction("model_info_store","readwrite"),o=i.objectStore("model_info_store"),a=o.get(t);let l;a.onsuccess=()=>{if(null==a.result)return s.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const r=o.delete(t),i=()=>{l=s.transaction("models_store","readwrite");const r=l.objectStore("models_store").delete(t);r.onsuccess=()=>e(a.result.modelArtifactsInfo),r.onerror=t=>n(a.error)};r.onsuccess=i,r.onerror=t=>(i(),s.close(),n(a.error))}},a.onerror=t=>(s.close(),n(a.error)),i.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}},r.onerror=t=>n(r.error)})}}if(Np().getBool("IS_BROWSER"))try{dv.registerManager(wv.URL_SCHEME,new Sv)}catch(wF){}const _v="tensorflowjs_models",Ev="info",kv="model_topology",Av="weight_specs",Iv="weight_data",Nv="model_metadata";function Tv(t){return{info:[_v,t,Ev].join("/"),topology:[_v,t,kv].join("/"),weightSpecs:[_v,t,Av].join("/"),weightData:[_v,t,Iv].join("/"),modelMetadata:[_v,t,Nv].join("/")}}function Rv(t){const e=t.split("/");if(e.length<3)throw new Error("Invalid key format: "+t);return e.slice(1,e.length-1).join("/")}class $v{constructor(t){if(!Np().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=Tv(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=iv(t);try{return this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(t){if(ev)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,s=e.length;r<s;r++)n+=String.fromCharCode(e[r]);return btoa(n)}(t.weightData)),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata})),{modelArtifactsInfo:r}}catch(wF){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const t=JSON.parse(s);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,e.userDefinedMetadata=t.userDefinedMetadata}const i=this.LS.getItem(this.keys.weightData);if(null==i)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=function(t){if(ev){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}(i),e}}$v.URL_SCHEME="localstorage://";const Dv=t=>{return Np().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith($v.URL_SCHEME)?(e=t.slice($v.URL_SCHEME.length),new $v(e)):null;var e};av.registerSaveRouter(Dv),av.registerLoadRouter(Dv);class Ov{constructor(){Kp(Np().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Kp("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=_v+"/",n="/"+Ev;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);s.startsWith(e)&&s.endsWith(n)&&(t[Rv(s)]=JSON.parse(this.LS.getItem(s)))}return t}async removeModel(t){var e;const n=Tv(t=(e=t).startsWith($v.URL_SCHEME)?e.slice($v.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(this.LS.getItem(n.info));return this.LS.removeItem(n.info),this.LS.removeItem(n.topology),this.LS.removeItem(n.weightSpecs),this.LS.removeItem(n.weightData),r}}if(Np().getBool("IS_BROWSER"))try{dv.registerManager($v.URL_SCHEME,new Ov)}catch(wF){}function Fv(t){return new Promise(t=>setTimeout(t)).then(t)}class Mv{constructor(t){if(!Np().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Mv.URL_SCHEME)&&(t=t.slice(Mv.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelTopologyFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=window.URL.createObjectURL(new Blob([JSON.stringify({modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]})],{type:"application/json"})),r=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor;if(r.download=this.modelTopologyFileName,r.href=n,await Fv(()=>r.dispatchEvent(new MouseEvent("click"))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=e,await Fv(()=>t.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:iv(t)}}}}Mv.URL_SCHEME="downloads://";class Lv{constructor(t){if(null==t||t.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received "+t);this.files=t}async load(){const t=this.files[0],e=this.files.slice(1);return new Promise((n,r)=>{const s=new FileReader;s.onload=s=>{const i=JSON.parse(s.target.result),o=i.modelTopology;if(null==o)return void r(new Error("modelTopology field is missing from file "+t.name));0===e.length&&n({modelTopology:o});const a=i.weightsManifest;if(null==a)return void r(new Error("weightManifest field is missing from file "+t.name));let l;try{l=this.checkManifestAndWeightFiles(a,e)}catch(wF){return void r(wF)}const u=[],c=[],h=[];a.forEach(t=>{t.paths.forEach(t=>{c.push(t),h.push(null)}),u.push(...t.weights)}),a.forEach(t=>{t.paths.forEach(t=>{const e=new FileReader;e.onload=e=>{const r=e.target.result,s=c.indexOf(t);h[s]=r,-1===h.indexOf(null)&&n({modelTopology:o,weightSpecs:u,weightData:rv(h),format:i.format,generatedBy:i.generatedBy,convertedBy:i.convertedBy,userDefinedMetadata:i.userDefinedMetadata})},e.onerror=e=>r(`Failed to weights data from file of path '${t}'.`),e.readAsArrayBuffer(l[t])})})},s.onerror=e=>r(`Failed to read model topology and weights manifest JSON from file '${t.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(t)})}checkManifestAndWeightFiles(t,e){const n=[],r=e.map(t=>sv(t.name)),s={};for(const i of t)i.paths.forEach(t=>{const i=sv(t);if(-1!==n.indexOf(i))throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(n.push(i),-1===r.indexOf(i))throw new Error(`Weight file with basename '${i}' is not provided.`);s[t]=e[r.indexOf(i)]});if(n.length!==e.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${e.length}).`);return s}}function Pv(t){return new Lv(t)}function zv(t,e,n,r){!function(t){Kp(null!=t&&Array.isArray(t)&&t.length>0,()=>"promises must be a none empty array")}(t),function(t,e){Kp(t>=0&&t<=1,()=>"Progress fraction must be in range [0, 1], but got startFraction "+t),Kp(e>=0&&e<=1,()=>"Progress fraction must be in range [0, 1], but got endFraction "+e),Kp(e>=t,()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction `+e)}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(t.map(i=>(i.then(i=>{const o=n+ ++s/t.length*(r-n);return e(o),i}),i)))}async function Bv(t,e){null==e&&(e={});const n=null==e.fetchFunc?Np().platform.fetch:e.fetchFunc,r=t.map(t=>n(t,e.requestInit,{isBinary:!0})),s=(null==e.onProgress?await Promise.all(r):await zv(r,e.onProgress,0,.5)).map(t=>t.arrayBuffer());return null==e.onProgress?await Promise.all(s):await zv(s,e.onProgress,.5,1)}async function Vv(t,e="",n,r){return Uv(t=>Bv(t,{requestInit:r}))(t,e,n)}function Uv(t){return async(e,n="",r)=>{const s=e.map(()=>!1),i={},o=null!=r?r.map(()=>!1):[],a=[];if(e.forEach((t,e)=>{let n=0;t.weights.forEach(t=>{const l=Zb["quantization"in t?t.quantization.dtype:t.dtype]*Jp(t.shape),u=()=>{s[e]=!0,null==i[e]&&(i[e]=[]),i[e].push({manifestEntry:t,groupOffset:n,sizeBytes:l})};null!=r?r.forEach((e,n)=>{e===t.name&&(u(),o[n]=!0)}):u(),a.push(t.name),n+=l})}),!o.every(t=>t)){const t=r.filter((t,e)=>!o[e]);throw new Error("Could not find weights in manifest with names: "+t.join(", ")+". \nManifest JSON has weights with names: "+a.join(", ")+".")}const l=s.reduce((t,e,n)=>(e&&t.push(n),t),[]),u=[];l.forEach(t=>{e[t].paths.forEach(t=>{const e=n+(n.endsWith("/")?"":"/")+t;u.push(e)})});const c=await t(u),h={};let d=0;return l.forEach(t=>{const n=e[t].paths.length;let r=0;for(let e=0;e<n;e++)r+=c[d+e].byteLength;const s=new ArrayBuffer(r),o=new Uint8Array(s);let a=0;for(let e=0;e<n;e++){const t=new Uint8Array(c[d+e]);o.set(t,a),a+=t.byteLength}i[t].forEach(t=>{const e=Qb(s.slice(t.groupOffset,t.groupOffset+t.sizeBytes),[t.manifestEntry]);for(const n in e)h[n]=e[n]}),d+=n}),h}}av.registerSaveRouter(t=>Np().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Mv.URL_SCHEME)?function(t="model"){return new Mv(t)}(t.slice(Mv.URL_SCHEME.length)):null);class Wv{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,null!=e.fetchFunc?(Kp("function"==typeof e.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=Np().platform.fetch,Kp(null!=t&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&Kp(2===t.length,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData,e.body.append("model.json",new Blob([JSON.stringify({modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata,weightsManifest:[{paths:["./model.weights.bin"],weights:t.weightSpecs}]})],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const n=await this.fetch(this.path,e);if(n.ok)return{modelArtifactsInfo:iv(t),responses:[n]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+n.status+".")}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code `+t.status+". Please verify this URL points to the model JSON of the model to load.");let e;try{e=await t.json()}catch(c){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=e.modelTopology,r=e.weightsManifest,s=e.generatedBy,i=e.convertedBy,o=e.format,a=e.userDefinedMetadata;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let l,u;if(null!=r){const t=await this.loadWeights(r);[l,u]=t}return{modelTopology:n,weightSpecs:l,weightData:u,userDefinedMetadata:a,generatedBy:s,convertedBy:i,format:o}}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?");return[t.substring(0,e)+"/",n>e?t.substring(n):""]}(e),s=this.weightPathPrefix||n,i=[];for(const a of t)i.push(...a.weights);const o=[];return t.forEach(t=>{t.paths.forEach(t=>{o.push(s+t+r)})}),[i,rv(await Bv(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function jv(t){return null!=t.match(Wv.URL_SCHEME_REGEX)}Wv.URL_SCHEME_REGEX=/^https?:\/\//;const Hv=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every(t=>jv(t)):jv(t),n)return qv(t,e)}return null};function qv(t,e){return new Wv(t,e)}function Gv(t,e){return qv(t,e)}av.registerSaveRouter(Hv),av.registerLoadRouter(Hv);class Kv{constructor(t){this.modelArtifacts=t}async load(){return this.modelArtifacts}}class Xv{constructor(t){this.saveHandler=t}async save(t){return this.saveHandler(t)}}function Yv(t,e,n,r){return 1===arguments.length?null!=t.modelTopology||null!=t.weightSpecs?new Kv(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Kv({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Kv({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))}function Zv(t){return new Xv(t)}const Jv=xm({oneHot_:function(t,e,n=1,r=0){if(e<2)throw new Error("Error in oneHot: depth must be >=2, but it is "+e);let s=bm(t,"indices","oneHot","int32");const i=[...s.shape,e];return s=s.flatten(),lm.runKernelFunc((t,o)=>(o([s]),Km(t.oneHot(s,e,n,r),i)),{indices:s},null,"OneHot",{depth:e,onValue:n,offValue:r})}});let Qv;async function tx(t,e){let n=bm(t,"img","toPixels");if(!(t instanceof qf)){const t=n;n=t.toInt(),t.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[r,s]=n.shape.slice(0,2),i=2===n.rank?1:n.shape[2];if(i>4||2===i)throw new Error("toPixels only supports depth of size 1, 3 or 4 but got "+i);const o=await n.data(),a=n.min(),l=n.max(),u=await Promise.all([a.data(),l.data()]),c=u[0][0],h=u[1][0];if(a.dispose(),l.dispose(),"float32"===n.dtype){if(c<0||h>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [${c} - ${h}].`)}else{if("int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);if(c<0||h>255)throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [${c} - ${h}].`)}const d="float32"===n.dtype?255:1,p=new Uint8ClampedArray(s*r*4);for(let f=0;f<r*s;++f){let t,e,n,r;1===i?(t=o[f]*d,e=o[f]*d,n=o[f]*d,r=255):3===i?(t=o[3*f]*d,e=o[3*f+1]*d,n=o[3*f+2]*d,r=255):4===i&&(t=o[4*f]*d,e=o[4*f+1]*d,n=o[4*f+2]*d,r=o[4*f+3]*d);const s=4*f;p[s+0]=Math.round(t),p[s+1]=Math.round(e),p[s+2]=Math.round(n),p[s+3]=Math.round(r)}if(null!=e){e.width=s,e.height=r;const t=e.getContext("2d"),n=new ImageData(p,s,r);t.putImageData(n,0,0)}return n!==t&&n.dispose(),p}xm({confusionMatrix_:function(t,e,n){const r=bm(t,"labels","confusionMatrix"),s=bm(e,"predictions","confusionMatrix");Kp(null==n||n>0&&Number.isInteger(n),()=>"If provided, numClasses must be a positive integer, but got "+n),Kp(1===r.rank,()=>"Expected the rank of labels to be 1, but got "+r.rank),Kp(1===s.rank,()=>"Expected the rank of predictions to be 1, but got "+s.rank),Kp(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),Kp(n>0&&Number.isInteger(n),()=>"numClasses is required to be a positive integer, but got "+n);const i=Jv(r.asType("int32"),n),o=Jv(s.asType("int32"),n);return i.transpose().matMul(o).asType("int32")}});const ex=xm({fromPixels_:function(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,i=!1,o=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&t instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement)s=!0;else if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement)i=!0;else{if(null==t.getContext)throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was "+t.constructor.name);o=!0}if(s){const e=2;if(s&&t.readyState<e)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=Mp("FromPixels",lm.backendName))return lm.runKernel("FromPixels",{pixels:t},{numChannels:e});const[a,l]=s?[t.videoWidth,t.videoHeight]:[t.width,t.height];let u,c;if(o?u=t.getContext("2d").getImageData(0,0,a,l).data:r||n?u=t.data:(i||s)&&(null==Qv&&(Qv=document.createElement("canvas").getContext("2d")),Qv.canvas.width=a,Qv.canvas.height=l,Qv.drawImage(t,0,0,a,l),u=Qv.getImageData(0,0,a,l).data),4===e)c=new Int32Array(u);else{const t=a*l;c=new Int32Array(t*e);for(let n=0;n<t;n++)for(let t=0;t<e;++t)c[n*e+t]=u[4*n+t]}return $m(c,[l,a,e],"int32")}});function nx(t,e){if(t.rank<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[e.rank-1]>t.rank)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[e.rank-1]} vs. ${t.rank}`);if(0===t.size)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const n=e.shape,r=n[n.length-1];let s=1;for(let u=0;u<n.length-1;++u)s*=n[u];const i=t.shape,o=n.slice();o.pop();let a=1;for(let u=r;u<t.rank;++u)a*=i[u],o.push(i[u]);const l=[...Ef(t.shape).map(t=>t/a),1].slice(0,r);return[o,s,a,l]}function rx(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,i="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+n.shape+`, indices.shape: ${e.shape}, shape: ${t}`+`, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(i+` update.rank < ${s}. `);if(t.length<r+(n.rank-s))throw new Error(i+" Output shape length < "+(r+(n.rank-s)));if(n.rank!==s+t.length-r)throw new Error(i+" update.rank != "+(s+t.length-r));for(let o=0;o<s;++o)if(n.shape[o]!==e.shape[o])throw new Error(i+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<n.rank-s;++o)if(n.shape[o+s]!==t[o+r])throw new Error(i+` updates.shape[${o+s}] (${n.shape[o+s]}) != shape[${o+s}] (${t[o+s]})`)}function sx(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: "+e.dtype);if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+n);if(0===n.length){if(0===e.size)throw new Error("Indices specified for empty output. indices shape: "+e.shape);if(0===t.size)throw new Error("Updates specified for empty output. updates shape: "+t.shape)}rx(n,e,t)}function ix(t,e,n){const r=e.shape.length,s=r>1?e.shape[r-1]:1,i=n.length;let o=1;for(let l=s;l<i;++l)o*=n[l];const a=s<1?1:s;return{sliceRank:s,numUpdates:Jp(e.shape)/a,sliceSize:o,strides:[...Ef(n.slice(0,s)),1],outputSize:Jp(n)}}class ox{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class ax{constructor(){this.classNameMap={}}static getMap(){return null==ax.instance&&(ax.instance=new ax),ax.instance}static register(t){ax.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function lx(t){Kp(null!=t.className,()=>"Class being registered does not have the static className property defined."),Kp("string"==typeof t.className,()=>"className is required to be a string, but got type "+typeof t.className),Kp(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),ax.register(t)}function ux(t){Np().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function cx(){return lm}function hx(){return lm.memory()}function dx(t,e){return lm.tidy(t,e)}function px(t){im(t).forEach(t=>t.dispose())}function fx(t){return lm.keep(t)}function mx(t,e,n=1){return lm.registerBackend(t,e,n)}Hf=ux;const gx=xm({addN_:function(t){Kp(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),Kp(t.length>=1,()=>"Must pass at least one tensor to tf.addN(), but got "+t.length);const e=t.map((t,e)=>bm(t,"tensors"+e,"addN")),n=e[0];return e.forEach(t=>{if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(t=>{if(!tf(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),lm.runKernelFunc((t,n)=>{const r=t.addN(e);return n(e),r},e,null,"AddN")}}),yx=xm({atan2_:function(t,e){let n=bm(t,"a","atan2"),r=bm(e,"b","atan2");return[n,r]=nm(n,r),lm.runKernelFunc((t,e)=>{const s=t.atan2(n,r);return e([n,r]),s},{a:n,b:r},null,"Atan2")}}),bx=xm({avgPool_:function(t,e,n,r,s){const i=bm(t,"x","avgPool","float32");Kp(fy(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let o=i,a=!1;3===i.rank&&(a=!0,o=Km(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Kp(4===o.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),null!=s&&Kp(ef(r),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let l=lm.runKernelFunc((t,i)=>{const a=sy(o.shape,e,n,1,r,s);return i([o]),1===a.filterWidth&&1===a.filterHeight&&tf(a.inShape,a.outShape)?o.clone():t.avgPool(o,a)},{x:o},null,"AvgPool",{filterSize:e,strides:n,pad:r,dimRoundingMode:s});return l=qm(l,i.dtype),a?l.as3D(l.shape[1],l.shape[2],l.shape[3]):l}}),vx=xm({avgPool3d_:function(t,e,n,r,s,i="NDHWC",o){null==o?o=[1,1,1]:ux("dilations is deprecated, this field will be gone in v3.0.0.");const a=bm(t,"x","avgPool3d","float32");let l=a,u=!1;4===a.rank&&(u=!0,l=Km(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),Kp(5===l.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${l.rank}.`),Kp("NDHWC"===i,()=>"Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of "+i),Kp(fy(n,o),()=>`Error in avgPool3d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),null!=s&&Kp(ef(r),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let c=lm.runKernelFunc((t,a)=>{null==o&&(o=[1,1,1]);const u=iy(l.shape,e,n,o,r,s,i);return a([l]),t.avgPool3d(l,u)},{x:l},null,"AvgPool3D",{filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:i,dilations:o});return c=qm(c,l.dtype),u?c.as4D(c.shape[1],c.shape[2],c.shape[3],c.shape[4]):c}});function xx(t){return null==t?null:0===t.rank?t.as1D():1===t.rank?t:2===t.rank?t.as4D(1,1,t.shape[0],t.shape[1]):3===t.rank?t.as4D(1,t.shape[0],t.shape[1],t.shape[2]):t}const wx=xm({batchNorm_:function(t,e,n,r,s,i){null==i&&(i=.001);const o=bm(t,"x","batchNorm"),a=bm(e,"mean","batchNorm"),l=bm(n,"variance","batchNorm");let u,c;null!=s&&(u=bm(s,"scale","batchNorm")),null!=r&&(c=bm(r,"offset","batchNorm")),Kp(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Kp(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Kp(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h=function(t){let e;return e=0===t.rank||1===t.rank?t.as4D(1,1,1,t.size):2===t.rank?t.as4D(1,1,t.shape[0],t.shape[1]):3===t.rank?t.as4D(1,t.shape[0],t.shape[1],t.shape[2]):t,e}(o),d=lm.runKernelFunc((t,e)=>(e([h,a,l,u]),t.batchNorm(h,xx(a),xx(l),xx(c),xx(u),i)),{x:h,scale:u,offset:c,mean:a,variance:l},null,"FusedBatchNorm",{varianceEpsilon:i});return Km(d,o.shape)}}),Cx=xm({batchNorm2d_:function(t,e,n,r,s,i){const o=bm(t,"x","batchNorm"),a=bm(e,"mean","batchNorm"),l=bm(n,"variance","batchNorm");let u,c;return null!=s&&(u=bm(s,"scale","batchNorm")),null!=r&&(c=bm(r,"offset","batchNorm")),Kp(2===o.rank,()=>"Error in batchNorm3D: x must be rank 3 but got rank "+o.rank+"."),Kp(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),Kp(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&Kp(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&Kp(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),wx(o,a,l,c,u,i)}}),Sx=xm({batchNorm3d_:function(t,e,n,r,s,i){const o=bm(t,"x","batchNorm"),a=bm(e,"mean","batchNorm"),l=bm(n,"variance","batchNorm");let u,c;return null!=s&&(u=bm(s,"scale","batchNorm")),null!=r&&(c=bm(r,"offset","batchNorm")),Kp(3===o.rank,()=>"Error in batchNorm3D: x must be rank 3 but got rank "+o.rank+"."),Kp(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),Kp(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&Kp(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&Kp(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),wx(o,a,l,c,u,i)}}),_x=xm({batchNorm4d_:function(t,e,n,r,s,i){const o=bm(t,"x","batchNorm"),a=bm(e,"mean","batchNorm"),l=bm(n,"variance","batchNorm");let u,c;return null!=s&&(u=bm(s,"scale","batchNorm")),null!=r&&(c=bm(r,"offset","batchNorm")),Kp(4===o.rank,()=>"Error in batchNorm4D: x must be rank 4 but got rank "+o.rank+"."),Kp(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),Kp(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&Kp(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&Kp(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),wx(o,a,l,c,u,i)}}),Ex=xm({clone_:function(t){const e=bm(t,"x","clone",null);return lm.runKernelFunc(()=>lm.makeTensorFromDataId(e.dataId,e.shape,e.dtype),{x:e},null,"Identity")}}),kx=xm({broadcastTo_:function(t,e){let n=bm(t,"broadcastTo","x");const r=n.shape;if(e.some(t=>!(t>0)||t%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=Km(n,t)}const s=n.shape,i=Array.from(e);for(let o=e.length-1;o>=0;o--)if(s[o]===e[o])i[o]=1;else if(1!==n.shape[o])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);return 0===i.map((t,e)=>t>1?e:-1).filter(t=>t>=0).length?Ex(n):lm.runKernelFunc(t=>t.tile(n,i),{x:n},null,"BroadcastTo",{shape:e,inputShape:s})}}),Ax=xm({concat1d_:function(t){return Wm(t,0)}}),Ix=xm({concat2d_:function(t,e){return Wm(t,e)}}),Nx=xm({concat3d_:function(t,e){return Wm(t,e)}}),Tx=xm({concat4d_:function(t,e){return Wm(t,e)}}),Rx=xm({conv1d_:function(t,e,n,r,s="NWC",i=1,o){const a=bm(t,"x","conv1d"),l=bm(e,"filter","conv1d");let u=a,c=!1;2===a.rank&&(c=!0,u=Km(a,[1,a.shape[0],a.shape[1]])),Kp(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),Kp(3===l.rank,()=>"Error in conv1d: filter must be rank 3, but got rank "+l.rank+"."),null!=o&&Kp(ef(r),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`),Kp(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),Kp(fy(n,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`),Kp("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=Km(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=Km(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=Ty(d,h,[1,n],r,"NHWC",[1,i],o);return Km(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),$x=xm({conv2dTranspose_:function(t,e,n,r,s,i){const o=bm(t,"x","conv2dTranspose"),a=bm(e,"filter","conv2dTranspose");return Iy(n,o,a,r,s,"NHWC",i)}}),Dx=xm({conv3d_:function(t,e,n,r,s="NDHWC",i=[1,1,1]){const o=bm(t,"x","conv3d"),a=bm(e,"filter","conv3d");let l=o,u=!1;4===o.rank&&(u=!0,l=Km(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Kp(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),Kp(5===a.rank,()=>"Error in conv3d: filter must be rank 5, but got rank "+a.rank+"."),Kp(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),Kp(fy(n,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),Kp("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const c=lm.runKernelFunc((t,e)=>{const s=ay(l.shape,a.shape,n,i,r),o=t.conv3d(l,a,s);return e([l,a]),o},{x:l,filter:a},null,"Conv3D",{strides:n,pad:r,dataFormat:s,dilations:i});return u?c.as4D(c.shape[1],c.shape[2],c.shape[3],c.shape[4]):c}}),Ox=xm({conv3dTranspose_:function(t,e,n,r,s){const i=bm(t,"x","conv3dTranspose"),o=bm(e,"filter","conv3dTranspose");return Dy(n,i,o,r,s)}}),Fx=xm({depthToSpace_:function(t,e,n="NHWC"){const r=bm(t,"x","depthToSpace"),s="NHWC"===n?r.shape[1]:r.shape[2],i="NHWC"===n?r.shape[2]:r.shape[3],o="NHWC"===n?r.shape[3]:r.shape[1];return Kp(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${e}  for depthToSpace with input shape\n    ${r.shape}`),Kp(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${e} for depthToSpace with input shape\n        ${r.shape}`),Kp(o%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${r.shape}`),lm.runKernelFunc(t=>t.depthToSpace(r,e,n),{x:r},null,"DepthToSpace",{blockSize:e,dataFormat:n})}}),Mx=xm({depthwiseConv2d_:function(t,e,n,r,s="NHWC",i=[1,1],o){const a=bm(t,"x","depthwiseConv2d"),l=bm(e,"filter","depthwiseConv2d");let u=a,c=!1;3===a.rank&&(c=!0,u=Km(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Kp(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),Kp(4===l.rank,()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+l.rank+"."),Kp(u.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),null!=o&&Kp(ef(r),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`);const h=lm.runKernelFunc((t,e)=>{null==i&&(i=[1,1]),Kp(fy(n,i),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);const s=oy(u.shape,l.shape,n,i,r,o,!0),a=t.depthwiseConv2D(u,l,s);return e([u,l]),a},{x:u,filter:l},null,"DepthwiseConv2dNative",{strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o});return c?Km(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Lx=xm({diag_:function(t){const e=bm(t,"x","diag").flatten();return lm.runKernelFunc(n=>{const r=n.diag(e),s=[...t.shape,...t.shape];return Km(r,s)},{x:e},null,"Diag")}}),Px=xm({divNoNan_:function(t,e){let n=bm(t,"a","div"),r=bm(e,"b","div");[n,r]=nm(n,r);const s=tg(n,r),i=Um(s),o=r.equal(i);return gb(o,i,s)}}),zx=xm({dot_:function(t,e){const n=bm(t,"t1","dot"),r=bm(e,"t2","dot");Kp(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=1===n.rank?n.size:n.shape[1],i=1===r.rank?r.size:r.shape[0];if(Kp(s===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${i}.`),1===n.rank&&1===r.rank){const t=Km(n,[1,-1]),e=Km(r,[-1,1]),s=xy(t,e);return Km(s,[])}if(1===n.rank&&2===r.rank){const t=Km(n,[1,-1]),e=Km(r,[r.shape[0],r.shape[1]]),s=xy(t,e);return Km(s,[s.size])}if(2===n.rank&&1===r.rank){const t=Km(r,[-1,1]),e=xy(n,t);return Km(e,[e.size])}{const t=Km(r,[r.shape[0],r.shape[1]]);return xy(n,t)}}}),Bx=xm({elu_:function(t){const e=bm(t,"x","elu");return lm.runKernelFunc((t,n)=>{const r=t.elu(e);return n([r]),r},{x:e},null,"Elu")}}),Vx=xm({equal_:function(t,e){let n=bm(t,"a","equal"),r=bm(e,"b","equal");return[n,r]=nm(n,r),fm(n.shape,r.shape),lm.runKernelFunc(t=>t.equal(n,r),{a:n,b:r},null,"Equal")}}),Ux=xm({eye_:function(t,e,n,r="float32"){null==e&&(e=t);const s=jm([t,e],r),i=t<=e?t:e;for(let a=0;a<i;++a)s.set(1,a,a);const o=s.toTensor().as2D(t,e);if(null==n)return o;if(1===n.length)return Hy(Gm(o,0),[n[0],1,1]);if(2===n.length)return Hy(Gm(Gm(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return Hy(Gm(Gm(Gm(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});function Wx(t,e,n){return lm.runKernelFunc(r=>r.fill(t,e,n),{},null,"Fill",{shape:t,value:e,dtype:n})}const jx=xm({maximum_:function(t,e){let n=bm(t,"a","maximum"),r=bm(e,"b","maximum");return[n,r]=nm(n,r),"bool"===n.dtype&&(n=qm(n,"int32"),r=qm(r,"int32")),fm(n.shape,r.shape),lm.runKernelFunc((t,e)=>{const s=t.maximum(n,r);return e([n,r]),s},{a:n,b:r},null,"Maximum")}}),Hx=xm({leakyRelu_:function(t,e=.2){const n=bm(t,"x","leakyRelu");return jx(eg(Nm(e),n),n)}}),qx=xm({localResponseNormalization_:function(t,e=5,n=1,r=1,s=.5){const i=bm(t,"x","localResponseNormalization");Kp(4===i.rank||3===i.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`),Kp(ef(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=i,a=!1;3===i.rank&&(a=!0,o=Km(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l=lm.runKernelFunc((t,i)=>{const a=t.localResponseNormalization4D(o,e,n,r,s);return i([o,a]),a},{x:o},null,"LRN",{depthRadius:e,bias:n,alpha:r,beta:s});return a?l.as3D(l.shape[1],l.shape[2],l.shape[3]):l}}),Gx=xm({max_:function(t,e=null,n=!1){const r=bm(t,"x","max"),s=lm.runKernelFunc((t,n)=>{let s=uf(e,r.shape);const i=lg(s,r.rank);let o=r;null!=i&&(o=Fy(r,i),s=cg(s.length,o.rank));const a=t.max(o,s);return n([r,a]),null!=i&&t.disposeData(o.dataId),a},{x:r},null,"Max",{reductionIndices:e,keepDims:n});return n?Km(s,og(s.shape,uf(e,r.shape))):s}}),Kx=xm({maxPool_:function(t,e,n,r,s){const i=bm(t,"x","maxPool");let o=i,a=!1;3===i.rank&&(a=!0,o=Km(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Kp(4===o.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),Kp(fy(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),null!=s&&Kp(ef(r),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const l=lm.runKernelFunc((t,i)=>{const a=sy(o.shape,e,n,1,r,s);let l;return l=1===a.filterWidth&&1===a.filterHeight&&tf(a.inShape,a.outShape)?o.clone():t.maxPool(o,a),i([o,l]),l},{x:o},null,"MaxPool",{filterSize:e,strides:n,pad:r,dimRoundingMode:s});return a?Km(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),Xx=xm({maxPool3d_:function(t,e=[1,1,1],n,r,s,i="NDHWC",o){null==o?o=[1,1,1]:ux("dilations is deprecated, this field will be gone in v3.0.0.");const a=bm(t,"x","maxPool3d");let l=a,u=!1;4===a.rank&&(u=!0,l=a.as5D(1,a.shape[0],a.shape[1],a.shape[2],a.shape[3])),Kp(5===l.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${l.rank}.`),Kp("NDHWC"===i,()=>"Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of "+i),Kp(fy(n,o),()=>`Error in maxPool3d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),null!=s&&Kp(ef(r),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const c=lm.runKernelFunc((t,a)=>{null==o&&(o=[1,1,1]);const u=iy(l.shape,e,n,o,r,s,i),c=t.maxPool3d(l,u);return a([l,c]),c},{x:l},null,"MaxPool3D",{filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:i,dilations:o});return u?Km(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),Yx=xm({maxPoolWithArgmax_:function(t,e,n,r,s=!1){const i=bm(t,"x","maxPoolWithArgmax"),o=lm.runKernel("MaxPoolWithArgmax",{x:i},{filterSize:e,strides:n,pad:r,includeBatchInIndex:s});return{result:o[0],indexes:o[1]}}}),Zx=xm({minimum_:function(t,e){let n=bm(t,"a","minimum"),r=bm(e,"b","minimum");return[n,r]=nm(n,r),"bool"===n.dtype&&(n=qm(n,"int32"),r=qm(r,"int32")),fm(n.shape,r.shape),lm.runKernelFunc((t,e)=>{const s=t.minimum(n,r);return e([n,r]),s},{a:n,b:r},null,"Minimum")}}),Jx=xm({mod_:function(t,e){let n=bm(t,"a","mod"),r=bm(e,"b","mod");return[n,r]=nm(n,r),lm.runKernelFunc((t,e)=>{const s=t.mod(n,r);return e([n,r]),s},{a:n,b:r},null,"Mod")}}),Qx=xm({multinomial_:function(t,e,n,r=!1){const s=bm(t,"logits","multinomial"),i=s.size,o=s.rank;if(i<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+i+".");if(o>2)throw new Error("Rank of probabilities must be 1 or 2, but is "+o);n=n||Math.random();const a=1===o?s.as2D(1,-1):s,l=lm.runKernelFunc(t=>t.multinomial(a,r,e,n),{logits2D:a});return 1===o?l.as1D():l}}),tw=xm({notEqual_:function(t,e){let n=bm(t,"a","notEqual"),r=bm(e,"b","notEqual");return[n,r]=nm(n,r),fm(n.shape,r.shape),lm.runKernelFunc(t=>t.notEqual(n,r),{a:n,b:r},null,"NotEqual")}}),ew=xm({outerProduct_:function(t,e){const n=bm(t,"v1","outerProduct"),r=bm(e,"v2","outerProduct");Kp(1===n.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const s=Km(n,[-1,1]),i=Km(r,[1,-1]);return xy(s,i)}}),nw=xm({pad1d_:function(t,e,n=0){return Kp(2===e.length,()=>"Invalid number of paddings. Must be length of 2."),$b(t,[e],n)}}),rw=xm({pad2d_:function(t,e,n=0){return Kp(2===e.length&&2===e[0].length&&2===e[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),$b(t,e,n)}}),sw=xm({pad3d_:function(t,e,n=0){return Kp(3===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),$b(t,e,n)}}),iw=xm({pad4d_:function(t,e,n=0){return Kp(4===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length&&2===e[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),$b(t,e,n)}}),ow=xm({pool_:function(t,e,n,r,s,i){null==s&&(s=[1,1]),null==i&&(i=1),0===r&&(r="valid");const o=bm(t,"x","maxPool");let a=o,l=!1;3===o.rank&&(l=!0,a=Km(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Kp(fy(i,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${s}'`);const u=sy(a.shape,e,i,s,r),c=[u.dilationHeight,u.dilationWidth];let h;h="same"===r?function(t,e){const n=t.map((t,n)=>t+(t-1)*(e[n]-1)).map(t=>t-1),r=n.map(t=>Math.floor(t/2)),s=n.map((t,e)=>t-r[e]);return n.map((t,e)=>[r[e],s[e]])}([u.filterHeight,u.filterWidth],c):[[0,0],[0,0]];const d=1===c[0]&&1===c[1],[p,f]=function(t,e,n){const r=n.map(t=>t[0]),s=n.map(t=>t[1]),i=t.concat(r,s),o=e.map((t,e)=>(t-i[e]%t)%t),a=s.map((t,e)=>t+o[e]);return[e.map((t,e)=>[r[e],a[e]]),e.map((t,e)=>[0,o[e]])]}([u.inHeight,u.inWidth],c,h),m=d?r:"valid",g=d?a:Cy(a,c,p),y=("avg"===n?()=>bx(g,e,i,m):()=>Kx(g,e,i,m))(),b=d?y:kb(y,c,f);return l?Km(b,[b.shape[1],b.shape[2],b.shape[3]]):b}}),aw=xm({prelu_:function(t,e){const n=bm(t,"x","prelu"),r=bm(e,"alpha","prelu");return lm.runKernelFunc((t,e)=>{const s=t.prelu(n,r);return e([n,r]),s},{x:n,alpha:r},null,"Prelu")}}),lw=xm({rand_:function(t,e,n){const r=Jp(t);let s=null;if(null==n||"float32"===n)s=new Float32Array(r);else if("int32"===n)s=new Int32Array(r);else{if("bool"!==n)throw new Error("Unknown data type "+n);s=new Uint8Array(r)}for(let i=0;i<r;i++)s[i]=e();return lm.makeTensor(s,t,n)}});var uw=n("YSVl");class cw{constructor(t,e,n,r,s){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=s||Math.random();this.random=uw.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,s,i;do{r=2*this.random()-1,s=2*this.random()-1,i=r*r+s*s}while(i>=1||0===i);const o=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*r*o,e=this.mean+this.stdDev*s*o,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class hw{constructor(t,e,n,r){this.alpha=t,this.beta=1/e,this.dtype=n;const s=r||Math.random();this.randu=uw.alea(s.toString()),this.randn=new cw(0,1,n,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,n,r,s,i;for(;;){do{r=this.randn.nextValue(),i=1+this.c*r}while(i<=0);if(i*=i*i,t=r*r,e=1-.331*t*t,n=.5*t+this.d*(1-i+Math.log(i)),s=this.randu(),s<e||Math.log(s)<n)break}return i*=1/this.beta*this.d,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class dw{constructor(t=0,e=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=uw.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const pw=xm({randomGamma_:function(t,e,n=1,r="float32",s){if(null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error("Unsupported data type "+r);const i=new hw(e,n,r,s),o=jm(t,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),fw=xm({randomNormal_:function(t,e=0,n=1,r,s){if(null!=r&&"bool"===r)throw new Error("Unsupported data type "+r);const i=new cw(e,n,r,!1,s),o=jm(t,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),mw=xm({randomUniform_:function(t,e=0,n=1,r="float32",s){const i=jm(t,r),o=new dw(e,n,null,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),gw=xm({relu_:function(t){const e=bm(t,"x","relu");return lm.runKernelFunc((t,n)=>(n([e]),"bool"===e.dtype?e.toInt():t.relu(e)),{x:e},null,"Relu")}}),yw=xm({relu6_:function(t){const e=bm(t,"x","relu6");return lm.runKernelFunc((t,n)=>(n([e]),"bool"===e.dtype?qm(e,"int32"):t.relu6(e)),{x:e},null,"Relu6")}}),bw=xm({selu_:function(t){const e=bm(t,"x","selu");return lm.runKernelFunc((t,n)=>{const r=t.selu(e);return n([e]),r},{x:e},null,"Selu")}}),vw=xm({separableConv2d_:function(t,e,n,r,s,i=[1,1],o="NHWC"){const a=bm(t,"x","separableConv2d"),l=bm(e,"depthwiseFilter","separableConv2d"),u=bm(n,"pointwiseFilter","separableConv2d");let c=a,h=!1;if(3===a.rank&&(h=!0,c=a.as4D(1,a.shape[0],a.shape[1],a.shape[2])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Kp(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),Kp(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),Kp(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),Kp(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),Kp(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const d=l.shape[2],p=l.shape[3];Kp(u.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`);const f=Mx(c,l,r,s,o,i),m=Ty(f,u,1,"valid",o);return h?m.as3D(m.shape[1],m.shape[2],m.shape[3]):m}}),xw=xm({squaredDifference_:function(t,e){let n=bm(t,"a","squaredDifference"),r=bm(e,"b","squaredDifference");return[n,r]=nm(n,r),fm(n.shape,r.shape),lm.runKernelFunc((t,e)=>{const s=t.squaredDifference(n,r);return e([n,r]),s},{a:n,b:r},null,"SquaredDifference",{})}}),ww=xm({truncatedNormal_:function(t,e=0,n=1,r,s){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const i=new cw(e,n,r,!0,s),o=jm(t,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),Cw=30;function Sw(t){return t<=Cw?t:_f(t,Math.floor(Math.sqrt(t)))}function _w(t,e){let n,r=!1;for(t<=Cw?(n=t,r=!0):n=_f(t,Math.floor(Math.sqrt(t)));!r;)n>e||n===t?r=!0:n=_f(t,n+1);return n}function Ew(t,e,n){const r=[],s=t.length;for(let i=0;i<s;i++)r.push(i!==e?t[i]:n);return r}function kw(t,e,n){const r=t.shape[n],s=[];let i=1,o=1;for(let a=0;a<n;a++)s.push(t.shape[a]),i*=t.shape[a];for(let a=0;a<e.rank;a++)s.push(e.shape[a]);for(let a=n+1;a<t.rank;a++)s.push(t.shape[a]),o*=t.shape[a];return{batchSize:i,sliceSize:o,dimSize:r,outputShape:s}}function Aw(t,e){const n=[];for(let r=t;r<e;++r)n.push(r);return n}function Iw(t){const e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}const Nw=xm({gather_:function(t,e,n=0){const r=bm(t,"x","gather"),s=bm(e,"indices","gather","int32");n=uf(n,r.shape)[0];const i=kw(r,s,n);return lm.runKernelFunc((t,e)=>{const i=t.gather(r,s.flatten(),n);return e([s]),i},{x:r,indices:s},(t,e)=>{const[s]=e;return{x:()=>{const e=r.shape,i=s.size,o=e.slice(0,n),a=o.length,l=e.slice(n,e.length).slice(1),u=l.length,c=Aw(0,a),h=Aw(a+1,a+1+u),d=Iw([o,[i],l]),p=t.reshape(d),f=s.reshape([i]),m=Iw([[a],c,h]),g=p.transpose(m);let y=Tw(g,f,r.shape[n]);const b=ug(m);return y=y.transpose(b),y},indices:()=>s}},"Gather",{axis:n}).reshape(i.outputShape)}}),Tw=xm({unsortedSegmentSum_:function(t,e,n){const r=bm(t,"x","unsortedSegmentSum"),s=bm(e,"segmentIds","unsortedSegmentSum","int32");return Kp(ef(n),()=>"numSegments must be of dtype int"),lm.runKernelFunc((t,e)=>{const i=t.unsortedSegmentSum(r,s,n);return e([s]),i},{$x:r},(t,e)=>{const[n]=e;return{$x:()=>function(t,e){const n=jx(e,Um(e)),r=Nw(t,n);let s=Zy(e,Nm(0,"int32"));const i=r.rank-s.rank;for(let a=0;a<i;++a)s=Gm(s,a+1);s=db(s,Lm(r.shape,"bool"));const o=Um(r);return gb(s,r,o)}(t,n)}})}}),Rw=async function(t,e,n){const r=bm(t,"tensor","boolMask"),s=bm(e,"mask","boolMask","bool"),i=null==n?0:n,o=s.rank,a=r.shape;Kp(o>0,()=>"mask cannot be scalar"),Xp(a.slice(i,i+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=i;m<i+o;m++)l*=a[m];const u=a.slice(0,i).concat([l],a.slice(i+o)),c=r.reshape(u),h=s.reshape([-1]),d=await yb(h),p=d.squeeze([1]),f=Nw(c,p,i);return t!==r&&r.dispose(),e!==s&&s.dispose(),p.dispose(),c.dispose(),h.dispose(),d.dispose(),f},$w=xm({reverse_:function(t,e){const n=bm(t,"x","reverse");if(0===n.rank)return n.clone();const r=uf(e,n.shape);return lm.runKernelFunc(t=>t.reverse(n,r),{$x:n},t=>({$x:()=>t.reverse(r)})).reshapeAs(n)}}),Dw=xm({reverse1d_:function(t){const e=bm(t,"x","reverse");return Kp(1===e.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),$w(e,0)}}),Ow=xm({reverse2d_:function(t,e){const n=bm(t,"x","reverse");return Kp(2===n.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),$w(n,e)}}),Fw=xm({reverse3d_:function(t,e){const n=bm(t,"x","reverse");return Kp(3===n.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),$w(n,e)}}),Mw=xm({reverse4d_:function(t,e){const n=bm(t,"x","reverse");return Kp(4===n.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),$w(n,e)}}),Lw=xm({equalStrict_:function(t,e){ux("strict variants of ops have been deprecated and will be removed in future");const n=bm(t,"a","equalStrict"),r=bm(e,"b","equalStrict");return Xp(n.shape,r.shape,"Error in equalStrict: "),n.equal(r)}}),Pw=xm({greaterEqualStrict_:function(t,e){ux("strict variants of ops have been deprecated and will be removed in future");const n=bm(t,"a","greaterEqualStrict"),r=bm(e,"b","greaterEqualStrict");return Xp(n.shape,r.shape,"Error in greaterEqualStrict: "),n.greaterEqual(r)}}),zw=xm({greaterStrict_:function(t,e){ux("strict variants of ops have been deprecated and will be removed in future");const n=bm(t,"a","greaterStrict"),r=bm(e,"b","greaterStrict");return Xp(n.shape,r.shape,"Error in greaterStrict: "),n.greater(r)}}),Bw=xm({lessEqualStrict_:function(t,e){ux("strict variants of ops have been deprecated and will be removed in future");const n=bm(t,"a","lessEqualStrict"),r=bm(e,"b","lessEqualStrict");return Xp(n.shape,r.shape,"Error in lessEqualStrict: "),n.lessEqual(r)}}),Vw=xm({lessStrict_:function(t,e){ux("strict variants of ops have been deprecated and will be removed in future");const n=bm(t,"a","lessStrict"),r=bm(e,"b","lessStrict");return Xp(n.shape,r.shape,"Error in lessStrict: "),n.less(r)}}),Uw=xm({notEqualStrict_:function(t,e){ux("strict variants of ops have been deprecated and will be removed in future");const n=bm(t,"a","notEqualStrict"),r=bm(e,"b","notEqualStrict");return Xp(n.shape,r.shape,"Error in notEqualStrict: "),n.notEqual(r)}}),Ww=xm({addStrict_:function(t,e){ux("strict variants of ops have been deprecated and will be removed in future");const n=bm(t,"a","addStrict"),r=bm(e,"b","addStrict");return Xp(n.shape,r.shape,"Error in addStrict: "),n.add(r)}}),jw=xm({divStrict_:function(t,e){ux("strict variants of ops have been deprecated and will be removed in future");const n=bm(t,"a","div"),r=bm(e,"b","div");return Xp(n.shape,r.shape,"Error in divideStrict: "),n.div(r)}}),Hw=xm({maximumStrict_:function(t,e){ux("strict variants of ops have been deprecated and will be removed in future");const n=bm(t,"a","maximumStrict"),r=bm(e,"b","maximumStrict");return Xp(n.shape,r.shape,"Error in maximumStrict: "),n.maximum(r)}}),qw=xm({minimumStrict_:function(t,e){ux("strict variants of ops have been deprecated and will be removed in future");const n=bm(t,"a","minimumStrict"),r=bm(e,"b","minimumStrict");return Xp(n.shape,r.shape,"Error in minimumStrict: "),n.minimum(r)}}),Gw=xm({modStrict_:function(t,e){ux("strict variants of ops have been deprecated and will be removed in future");const n=bm(t,"a","modStrict"),r=bm(e,"b","modStrict");return Xp(n.shape,r.shape,"Error in modStrict: "),n.mod(r)}}),Kw=xm({mulStrict_:function(t,e){ux("strict variants of ops have been deprecated and will be removed in future");const n=bm(t,"a","mul"),r=bm(e,"b","mul");return Xp(n.shape,r.shape,"Error in multiplyStrict: "),n.mul(r)}}),Xw=xm({powStrict_:function(t,e){return ux("strict variants of ops have been deprecated and will be removed in future"),Xp(t.shape,e.shape,"Error in powStrict: "),t.pow(e)}}),Yw=xm({squaredDifferenceStrict_:function(t,e){ux("strict variants of ops have been deprecated and will be removed in future");const n=bm(t,"a","squaredDifferenceStrict"),r=bm(e,"b","squaredDifferenceStrict");return Xp(n.shape,r.shape,"Error in squaredDifferenceStrict: "),n.squaredDifference(r)}}),Zw=xm({subStrict_:function(t,e){ux("strict variants of ops have been deprecated and will be removed in future");const n=bm(t,"a","subStrict"),r=bm(e,"b","subStrict");return Xp(n.shape,r.shape,"Error in subStrict: "),n.sub(r)}}),Jw=xm({softmax_:function(t,e=-1){const n=bm(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);return lm.runKernelFunc((t,r)=>{const s=t.softmax(n,e);return r([s]),s},{logits:n},(t,n)=>{const[r]=n,s=t.mul(r);return{logits:()=>s.sub(s.sum([e],!0).mul(r))}},"Softmax",{dim:e},[],[!0])}}),Qw=xm({logSoftmax_:function(t,e=-1){const n=bm(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return ng((t,n)=>{const r=t.max(e,!0),s=t.sub(r),i=s.toFloat().sub(s.exp().sum(e,!0).log());return n([i]),{value:i,gradFunc:(t,n)=>{const[r]=n,s=r.exp();return t.sub(t.sum(e,!0).mul(s))}}})(n)}}),tC=xm({norm_:function(t,e="euclidean",n=null,r=!1){const s=function t(e,n,r=null){if(0===e.rank)return e.abs();if(1!==e.rank&&null===r)return t(e.reshape([-1]),n,r);if(1===e.rank||"number"==typeof r||Array.isArray(r)&&1===r.length){if(1===n)return e.abs().sum(r);if(n===1/0)return e.abs().max(r);if(n===-1/0)return e.abs().min(r);if("euclidean"===n||2===n)return e.abs().pow(Nm(2,"int32")).sum(r).sqrt();throw new Error("Error in norm: invalid ord value: "+n)}if(Array.isArray(r)&&2===r.length){if(1===n)return e.abs().sum(r[0]).max(r[1]-1);if(n===1/0)return e.abs().sum(r[1]).max(r[0]);if(n===-1/0)return e.abs().sum(r[1]).min(r[0]);if("fro"===n||"euclidean"===n)return e.square().sum(r).sqrt();throw new Error("Error in norm: invalid ord value: "+n)}throw new Error("Error in norm: invalid axis: "+r)}(t=bm(t,"x","norm"),e,n);let i=s.shape;if(r){const e=uf(n,t.shape);i=og(s.shape,e)}return s.reshape(i)}}),eC=xm({basicLSTMCell_:function(t,e,n,r,s,i){const o=bm(t,"forgetBias","basicLSTMCell"),a=bm(e,"lstmKernel","basicLSTMCell"),l=bm(n,"lstmBias","basicLSTMCell"),u=bm(r,"data","basicLSTMCell"),c=bm(s,"c","basicLSTMCell"),h=bm(i,"h","basicLSTMCell"),d=u.concat(h,1).matMul(a).add(l),p=d.shape[1]/4,f=[d.shape[0],p],m=d.slice([0,0],f),g=d.slice([0,p],f),y=d.slice([0,2*p],f),b=d.slice([0,3*p],f),v=m.sigmoid().mul(g.tanh()).add(c.mul(o.add(y).sigmoid())),x=v.tanh().mul(b.sigmoid());return[v,x]}}),nC=xm({multiRNNCell_:function(t,e,n,r){const s=bm(e,"data","multiRNNCell"),i=vm(n,"c","multiRNNCell"),o=vm(r,"h","multiRNNCell");let a=s;const l=[];for(let h=0;h<t.length;h++){const e=t[h](a,i[h],o[h]);l.push(e[0]),l.push(e[1]),a=e[1]}const u=[],c=[];for(let h=0;h<l.length;h+=2)u.push(l[h]),c.push(l[h+1]);return[u,c]}}),rC=xm({movingAverage_:function(t,e,n,r,s=!0){const i=bm(t,"v","movingAverage"),o=bm(e,"x","movingAverage"),a=bm(n,"decay","movingAverage");rm(i,o),Kp(tf(i.shape,o.shape),()=>"Shape mismatch in v and x");const l=Nm(1),u=l.sub(a);let c=o.sub(i).mul(u);if(s){Kp(null!=r,()=>"When using zeroDebias: true, step is required.");const t=bm(r,"step","movingAverage");c=c.div(l.sub(bb(a,t)))}return i.add(c)}}),sC=xm({stridedSlice_:function(t,e,n,r,s=0,i=0,o=0,a=0,l=0){null==r&&(r=new Array(e.length));const u=Ob(o);if(u.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==o&&0!==a)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==o&&0!==l)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");let c=bm(t,"x","stridedSlice");const h=c.rank-e.length,d=Ob(a),p=c.shape.slice();d.forEach(t=>{e[t]=0,n[t]=1,p.splice(t,0,1)}),c=c.reshape(p);for(let y=0;y<c.rank;y++)e[y]=Bb(s,e,r,c.shape,y,o),n[y]=Vb(i,n,r,c.shape,y,o),r[y]=zb(r,y,o);if(u.length&&h>0){const t=u[0],s=h+1;e=Lb(e,t,s),n=Pb(n,t,s,c.shape),r=Mb(r,t,s)}const f=Ob(l);f.forEach(t=>{n[t]=e[t]+1,r[t]=1});const m=Fb(e,n,r),g=m.filter((t,e)=>-1===f.indexOf(e));return r.every(t=>1===t)?jb(c,e,m).reshape(g):lm.runKernelFunc(t=>t.stridedSlice(c,e,n,r),{$x:c}).reshape(g)}}),iC=xm({topk_:function(t,e=1,n=!0){const r=bm(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got `+e);const[i,o]=lm.runKernelFunc(t=>t.topk(r,e,n),{$x:r});return{values:i,indices:o}}}),oC=xm({scatterND_:function(t,e,n){const r=bm(t,"indices","scatterND","int32"),s=bm(e,"updates","scatterND");return sx(s,r,n),lm.runKernelFunc(t=>t.scatterND(r,s,n),{indices:r,updates:s},null,"ScatterNd",{shape:n})}}),aC=xm({fft_:function(t){Kp("complex64"===t.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e=t.shape[t.shape.length-1],n=t.as2D(t.size/e,e);return lm.runKernelFunc(t=>t.fft(n),{input:t}).reshape(t.shape)}}),lC=xm({ifft_:function(t){Kp("complex64"===t.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e=t.shape[t.shape.length-1],n=t.as2D(t.size/e,e);return lm.runKernelFunc(t=>t.ifft(n),{input:t}).reshape(t.shape)}}),uC=xm({rfft_:function(t,e){Kp("float32"===t.dtype,()=>"The dtype for rfft() must be real value but got "+t.dtype);let n=t.shape[t.shape.length-1];const r=t.size/n;let s;if(null!=e&&e<n){const r=t.shape.map(t=>0),i=t.shape.map(t=>t);i[t.shape.length-1]=e,s=t.slice(r,i),n=e}else if(null!=e&&e>n){const r=t.shape.map(t=>t);r[t.shape.length-1]=e-n,s=t.concat(Pm(r),t.shape.length-1),n=e}else s=t;const i=s.zerosLike(),o=_m(s,i).as2D(r,n),a=aC(o),l=Math.floor(n/2)+1,u=km(a),c=Em(a),h=u.split([l,n-l],u.shape.length-1),d=c.split([l,n-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,_m(h[0],d[0]).reshape(p)}}),cC=xm({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;if(e<=2){const r=t.as2D(n,e),s=lC(r);return km(s)}{const r=[n,2*(e-1)],s=km(t).as2D(n,e),i=Em(t).as2D(n,e),o=s.slice([0,1],[n,e-2]).reverse(1),a=i.slice([0,1],[n,e-2]).reverse(1).mul(Nm(-1)),l=s.concat(o,1),u=i.concat(a,1),c=_m(l,u).as2D(r[0],r[1]),h=lC(c);return km(h)}}}),hC=xm({sparseToDense_:function(t,e,n,r=0){const s=bm(t,"sparseIndices","sparseToDense","int32"),i=bm(e,"sparseValues","sparseToDense"),o=bm(r,"defaultValue","sparseToDense",i.dtype);return function(t,e,n,r){if("int32"!==t.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const s=t.rank>0?t.shape[0]:1,i=t.rank>1?t.shape[1]:1;if(n.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${i}.`);if(0!==e.rank&&(1!==e.rank||e.size!==s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,i,n,o),lm.runKernelFunc(t=>t.sparseToDense(s,i,n,o),{$sparseIndices:s,$sparseValues:i,$defaultValue:o})}}),dC=xm({gatherND_:function(t,e){const n=bm(e,"indices","gatherND","int32"),r=bm(t,"x","gatherND");return lm.runKernelFunc(t=>t.gatherND(r,n),{params:r,indices:n},null,"GatherNd")}}),pC=xm({dropout_:function(t,e,n,r){const s=bm(t,"x","dropout");if(Kp("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),Kp(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),0===e)return t instanceof qf?s.clone():s;const i=function(t,e){if(null==e)return t.shape.slice();if(tf(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)n.push(null==e[r]&&null!=t.shape[r]?t.shape[r]:e[r]);return n}return e}(s,n),o=1-e,a=mw(i,0,1,"float32",r).add(o).floor().div(o);return s.mul(a)}});function fC(t,e,n){const r=1-t%2,s=new Float32Array(t);for(let i=0;i<t;++i){const o=2*Math.PI*i/(t+r-1);s[i]=e-n*Math.cos(o)}return Tm(s,"float32")}const mC=xm({hannWindow_:function(t){return fC(t,.5,.5)}}),gC=xm({hammingWindow_:function(t){return fC(t,.54,.46)}}),yC=xm({frame_:function(t,e,n,r=!1,s=0){let i=0;const o=[];for(;i+e<=t.size;)o.push(jb(t,i,e)),i+=n;if(r)for(;i<t.size;){const r=i+e-t.size,a=Wm([jb(t,i,e-r),Wx([r],s)]);o.push(a),i+=n}return 0===o.length?Rm([],[0,e]):Wm(o).as2D(o.length,e)}}),bC=xm({stft_:function(t,e,n,r,s=mC){null==r&&(r=Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2)))));const i=yC(t,e,n),o=eg(i,s(e)),a=[];for(let l=0;l<i.shape[0];l++)a.push(uC(o.slice([l,0],[1,e]),r));return Wm(a)}}),vC=async function(t,e,n=1){const r=bm(t,"predictions","inTopK"),s=bm(e,"targets","inTopK");Kp(r.rank>1,()=>"inTopK() expects the predictions to be of rank 2 or higher, but got "+r.rank),Kp(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),Xp(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=r.shape[r.shape.length-1];Kp(n>0&&n<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${n}`);const o=await r.data(),a=await s.data(),[l,u]=[o.length/i,i],c=hf("bool",l);for(let h=0;h<l;h++){const t=h*u,e=o.subarray(t,t+u),r=[];for(let n=0;n<e.length;n++)r.push({value:e[n],index:n});r.sort((t,e)=>e.value-t.value),c[h]=0;for(let s=0;s<n;s++)if(r[s].index===a[h]){c[h]=1;break}}return t!==r&&r.dispose(),e!==s&&s.dispose(),Am(c,s.shape,"bool")};var xC;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(xC||(xC={}));const wC=xm({absoluteDifference_:function(t,e,n,r=xC.SUM_BY_NONZERO_WEIGHTS){const s=bm(t,"labels","absoluteDifference"),i=bm(e,"predictions","absoluteDifference");let o=null;null!=n&&(o=bm(n,"weights","absoluteDifference")),Xp(s.shape,i.shape,"Error in absoluteDifference: ");const a=s.sub(i).abs();return CC(a,o,r)}}),CC=xm({computeWeightedLoss_:function(t,e,n=xC.SUM_BY_NONZERO_WEIGHTS){const r=bm(t,"losses","computeWeightedLoss");let s=null;null!=e&&(s=bm(e,"weights","computeWeightedLoss"));const i=null==s?r:r.mul(s);if(n===xC.NONE)return i;if(n===xC.SUM)return i.sum();if(n===xC.MEAN){if(null==s)return i.mean();{const t=r.size/s.size,e=i.sum().div(s.sum());return t>1?e.div(Nm(t)):e}}if(n===xC.SUM_BY_NONZERO_WEIGHTS){if(null==s)return i.sum().div(Nm(r.size));{const t=s.mul(Lm(r.shape)).notEqual(Nm(0)).sum().toFloat();return i.sum().div(t)}}throw Error("Unknown reduction: "+n)}}),SC=xm({cosineDistance_:function(t,e,n,r,s=xC.SUM_BY_NONZERO_WEIGHTS){const i=bm(t,"labels","cosineDistance"),o=bm(e,"predictions","cosineDistance");let a=null;null!=r&&(a=bm(r,"weights","cosineDistance")),Xp(i.shape,o.shape,"Error in cosineDistance: ");const l=Nm(1).sub(i.mul(o).sum(n,!0));return CC(l,a,s)}}),_C=xm({hingeLoss_:function(t,e,n,r=xC.SUM_BY_NONZERO_WEIGHTS){let s=bm(t,"labels","hingeLoss");const i=bm(e,"predictions","hingeLoss");let o=null;null!=n&&(o=bm(n,"weights","hingeLoss")),Xp(s.shape,i.shape,"Error in hingeLoss: ");const a=Nm(1);s=Nm(2).mul(s).sub(a);const l=a.sub(s.mul(i)).relu();return CC(l,o,r)}}),EC=xm({huberLoss_:function(t,e,n,r=1,s=xC.SUM_BY_NONZERO_WEIGHTS){const i=bm(t,"labels","huberLoss"),o=bm(e,"predictions","huberLoss");let a=null;null!=n&&(a=bm(n,"weights","huberLoss")),Xp(i.shape,o.shape,"Error in huberLoss: ");const l=Nm(r),u=o.sub(i).abs(),c=Zx(u,l),h=u.sub(c),d=Nm(.5).mul(c.square()).add(l.mul(h));return CC(d,a,s)}}),kC=xm({logLoss_:function(t,e,n,r=1e-7,s=xC.SUM_BY_NONZERO_WEIGHTS){const i=bm(t,"labels","logLoss"),o=bm(e,"predictions","logLoss");let a=null;null!=n&&(a=bm(n,"weights","logLoss")),Xp(i.shape,o.shape,"Error in logLoss: ");const l=Nm(1),u=Nm(r),c=i.mul(o.add(u).log()).neg().sub(l.sub(i).mul(l.sub(o).add(u).log()));return CC(c,a,s)}}),AC=xm({meanSquaredError_:function(t,e,n,r=xC.SUM_BY_NONZERO_WEIGHTS){const s=bm(t,"labels","meanSquaredError"),i=bm(e,"predictions","meanSquaredError");let o=null;null!=n&&(o=bm(n,"weights","meanSquaredError")),Xp(s.shape,i.shape,"Error in meanSquaredError: ");const a=s.squaredDifference(i);return CC(a,o,r)}}),IC=xm({sigmoidCrossEntropy_:function(t,e,n,r=0,s=xC.SUM_BY_NONZERO_WEIGHTS){let i=bm(t,"multiClassLabels","sigmoidCrossEntropy");const o=bm(e,"logits","sigmoidCrossEntropy");let a=null;if(null!=n&&(a=bm(n,"weights","sigmoidCrossEntropy")),Xp(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const t=Nm(r),e=Nm(1),n=Nm(.5);i=i.mul(e.sub(t)).add(n.mul(t))}const l=function(t,e){const n=bm(t,"labels","sigmoidCrossEntropyWithLogits"),r=bm(e,"logits","sigmoidCrossEntropyWithLogits");Xp(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=r.relu(),i=r.mul(n),o=r.abs().neg().exp().log1p();return s.sub(i).add(o)}(i,o);return CC(l,a,s)}}),NC=xm({softmaxCrossEntropy_:function(t,e,n,r=0,s=xC.SUM_BY_NONZERO_WEIGHTS){let i=bm(t,"onehotLabels","softmaxCrossEntropy");const o=bm(e,"logits","softmaxCrossEntropy");let a=null;if(null!=n&&(a=bm(n,"weights","softmaxCrossEntropy")),Xp(i.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const t=Nm(r),e=Nm(1),n=Nm(i.shape[1]);i=i.mul(e.sub(t)).add(t.div(n))}const l=function(t,e,n=-1){if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was `+n);return ng((t,e,r)=>{const s=e.logSumExp([n],!0),i=e.toFloat().sub(s);return r([t,i]),{value:i.mul(t).neg().sum([n]),gradFunc:(t,e)=>{const[r,s]=e,i=og(t.shape,[n]);return[t.reshape(i).mul(r.toFloat().sub(s.exp())),t.reshape(i).mul(s.exp().sub(r.toFloat()))]}}})(t,e)}(i,o);return CC(l,a,s)}});function TC(t,e=!1){return lm.tidy(()=>{if(2!==t.shape.length)throw new Error(`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],r=t.shape[1];let s=Ux(n),i=t.clone();const o=Rm([[1]],[1,1]);let a=o.clone();const l=n>=r?r:n;for(let t=0;t<l;++t){const e=i,l=a,u=s;[a,i,s]=lm.tidy(()=>{const e=i.slice([t,t],[n-t,1]),l=e.norm(),u=i.slice([t,t],[1,1]),c=Rm([[-1]]).where(u.greater(0),Rm([[1]])),h=u.sub(c.mul(l)),d=e.div(h);a=1===d.shape[0]?o.clone():o.concat(d.slice([1,0],[d.shape[0]-1,d.shape[1]]),0);const p=c.matMul(h).div(l).neg(),f=i.slice([t,0],[n-t,r]),m=p.mul(a),g=a.transpose();if(0===t)i=f.sub(m.matMul(g.matMul(f)));else{const e=f.sub(m.matMul(g.matMul(f)));i=i.slice([0,0],[t,r]).concat(e,0)}const y=m.transpose(),b=s.slice([0,t],[n,s.shape[1]-t]);if(0===t)s=b.sub(b.matMul(a).matMul(y));else{const e=b.sub(b.matMul(a).matMul(y));s=s.slice([0,0],[n,t]).concat(e,1)}return[a,i,s]}),px([e,l,u])}return!e&&n>r&&(s=s.slice([0,0],[n,r]),i=i.slice([0,0],[r,r])),[s,i]})}const RC=xm({bandPart_:function(t,e,n){if(e%1!=0)throw new Error(`bandPart(): numLower must be an integer, got ${e}.`);if(n%1!=0)throw new Error(`bandPart(): numUpper must be an integer, got ${n}.`);const r=bm(t,"a","bandPart");if(r.rank<2)throw new Error(`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[i,o]=r.shape.slice(-2);if(!(e<=i))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);e<0&&(e=i),n<0&&(n=o);const a=Bm(0,i,1,"int32").reshape([-1,1]),l=Bm(0,o,1,"int32"),u=jy(a,l),c=db(u.lessEqual(Nm(+e,"int32")),u.greaterEqual(Nm(-n,"int32"))),h=Pm([i,o],r.dtype);return Ym(Zm(r.reshape([-1,i,o])).map(t=>gb(c,t,h))).reshape(s)}}),$C=xm({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,Kp(null!=t&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=t[0].shape[0];for(let e=1;e<t.length;++e)Kp(t[e].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[e].shape[0]} vs. ${n})`)}else e=!0,t=Ey(t,t.shape[0],0).map(t=>Xm(t,[0]));Kp(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],r=t;for(let s=0;s<t.length;++s)n.push(lm.tidy(()=>{let t=r[s];if(s>0)for(let e=0;e<s;++e){const r=xg(n[e].mul(t)).mul(n[e]);t=t.sub(r)}return t.div(tC(t,"euclidean"))}));return e?Ym(n,0):n}}),DC=xm({qr_:function(t,e=!1){if(t.rank<2)throw new Error("qr() requires input tensor to have a rank >= 2, but got rank "+t.rank);if(2===t.rank)return TC(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((t,e)=>t*e),r=Zm(t.reshape([n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],i=[];return r.forEach(t=>{const[n,r]=TC(t,e);s.push(n),i.push(r)}),[Ym(s,0).reshape(t.shape),Ym(i,0).reshape(t.shape)]}}});function OC(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,s=t.length,i=0,o=!1;for(;r<s;){i=r+(s-r>>>1);const a=n(e,t[i]);a>0?r=i+1:(s=i,o=!a)}return o?r:-r-1}(t,e,n||FC)}(t,e,n);t.splice(r<0?-(r+1):r,0,e)}function FC(t,e){return t>e?1:t<e?-1:0}function MC(t,e,n,r,s){const i=PC(t,e,n,r,s,0);return i.selectedScores.dispose(),i.numValidOutputs.dispose(),i.selectedIndices}function LC(t,e,n,r,s,i){const o=PC(t,e,n,r,s,i,!0);return o.numValidOutputs.dispose(),{selectedIndices:o.selectedIndices,selectedScores:o.selectedScores}}function PC(t,e,n,r,s,i,o=!1,a=!1){const l=[];for(let p=0;p<e.length;p++)e[p]>s&&l.push({score:e[p],boxIndex:p,suppressBeginIndex:0});l.sort(VC);const u=i>0?-.5/i:0,c=[],h=[];for(;c.length<n&&l.length>0;){const e=l.pop(),{score:n,boxIndex:i,suppressBeginIndex:o}=e;if(n<s)break;let a=!1;for(let l=c.length-1;l>=o;--l){const n=zC(t,i,c[l]);if(n>=r){a=!0;break}if(e.score=e.score*BC(r,u,n),e.score<=s)break}e.suppressBeginIndex=c.length,a||(e.score===n?(c.push(i),h.push(e.score)):e.score>s&&OC(l,e,VC))}const d=c.length;return a&&(c.fill(0,d),h.fill(0,d)),{selectedIndices:Tm(c,"int32"),selectedScores:Tm(h,"float32"),numValidOutputs:Nm(d,"int32")}}function zC(t,e,n){const r=t.subarray(4*e,4*e+4),s=t.subarray(4*n,4*n+4),i=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(a-i)*(l-o),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(i,u),g=Math.max(o,c),y=Math.min(a,h),b=Math.min(l,d),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function BC(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function VC(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}function UC(t,e,n,r,s,i){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==i&&(i=0);const o=t.shape[0];return n=Math.min(n,o),Kp(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),Kp(2===t.rank,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),Kp(4===t.shape[1],()=>"boxes must have 4 columns, but 2nd dimension was "+t.shape[1]),Kp(1===e.rank,()=>"scores must be a 1D tensor"),Kp(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was `+e.shape[0]),Kp(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:i}}const WC=xm({nonMaxSuppression_:function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const i=bm(t,"boxes","nonMaxSuppression"),o=bm(e,"scores","nonMaxSuppression"),a=UC(i,o,n,r,s);return lm.runKernelFunc(t=>t.nonMaxSuppression(i,o,n,r,s),{boxes:i,scores:o},null,"NonMaxSuppressionV3",{maxOutputSize:n=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:s=a.scoreThreshold})}}),jC=xm({resizeBilinear_:function(t,e,n=!1){const r=bm(t,"images","resizeBilinear");Kp(3===r.rank||4===r.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),Kp(2===e.length,()=>"Error in resizeBilinear: new shape must 2D, but got shape "+e+".");let s=r,i=!1;3===r.rank&&(i=!0,s=r.as4D(1,r.shape[0],r.shape[1],r.shape[2]));const[o,a]=e,l=lm.runKernelFunc((t,e)=>(e([s]),t.resizeBilinear(s,o,a,n)),{x:s},(t,e)=>({x:()=>lm.runKernelFunc(r=>r.resizeBilinearBackprop(t,e[0],n),{})}),"ResizeBilinear",{alignCorners:n,newHeight:o,newWidth:a});return i?l.as3D(l.shape[1],l.shape[2],l.shape[3]):l}}),HC=xm({resizeNearestNeighbor_:function(t,e,n=!1){const r=bm(t,"images","resizeNearestNeighbor");Kp(3===r.rank||4===r.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),Kp(2===e.length,()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+e+"."),Kp("float32"===r.dtype||"int32"===r.dtype,()=>"`images` must have `int32` or `float32` as dtype");let s=r,i=!1;3===r.rank&&(i=!0,s=r.as4D(1,r.shape[0],r.shape[1],r.shape[2]));const[o,a]=e,l=lm.runKernelFunc((t,e)=>(e([s]),t.resizeNearestNeighbor(s,o,a,n)),{batchImages:s},(t,e)=>({batchImages:()=>lm.runKernelFunc(r=>r.resizeNearestNeighborBackprop(t,e[0],n),{})}));return i?l.as3D(l.shape[1],l.shape[2],l.shape[3]):l}}),qC=async function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const i=bm(t,"boxes","nonMaxSuppressionAsync"),o=bm(e,"scores","nonMaxSuppressionAsync"),a=UC(i,o,n,r,s);n=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=await Promise.all([i.data(),o.data()]),u=MC(l[0],l[1],n,r,s);return i!==t&&i.dispose(),o!==e&&o.dispose(),u},GC=xm({nonMaxSuppressionWithScore_:function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=bm(t,"boxes","nonMaxSuppression"),a=bm(e,"scores","nonMaxSuppression"),l=UC(o,a,n,r,s,i),u=lm.runKernel("NonMaxSuppressionV5",{boxes:o,scores:a},{maxOutputSize:n=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:i=l.softNmsSigma});return{selectedIndices:u[0],selectedScores:u[1]}}}),KC=async function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=bm(t,"boxes","nonMaxSuppressionAsync"),a=bm(e,"scores","nonMaxSuppressionAsync"),l=UC(o,a,n,r,s,i);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const u=await Promise.all([o.data(),a.data()]),c=LC(u[0],u[1],n,r,s,i);return o!==t&&o.dispose(),a!==e&&a.dispose(),c},XC=xm({cropAndResize_:function(t,e,n,r,s,i){const o=bm(t,"image","cropAndResize"),a=bm(e,"boxes","cropAndResize","float32"),l=bm(n,"boxInd","cropAndResize","int32");s=s||"bilinear",i=i||0;const u=a.shape[0];return Kp(4===o.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),Kp(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),Kp(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),Kp(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),Kp(r[0]>=1&&r[1]>=1,()=>"cropSize must be atleast [1,1], but was "+r),Kp("bilinear"===s||"nearest"===s,()=>"method must be bilinear or nearest, but was "+s),lm.runKernelFunc((t,e)=>t.cropAndResize(o,a,l,r,s,i),{images:o,boxes:a,boxInd:l},null,"CropAndResize",{method:s,extrapolationValue:i,cropSize:r})}}),YC=(t,e)=>!(t>0)||"linear"===e,ZC=(t,e,n)=>{if(null==n||"linear"===n)return t;if("relu"===n)return t.mul(e.step());throw new Error(`Gradient for activation ${n} has not been implemented yet.`)},JC=(t,e)=>{let n=e;const r=pm(t.shape,e.shape);return r.length>0&&(n=n.sum(r)),n.reshape(t.shape)},QC=(t,e,n)=>{if("linear"===e)return t;if("relu"===e)return gw(t);if("elu"===e)return Bx(t);if("relu6"===e)return yw(t);if("prelu"===e)return aw(t,n);throw new Error(`Unknown fused activation ${e}.`)},tS=xm({fusedMatMul_:function({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:s,activation:i="linear",preluActivationWeights:o}){if(!1===YC(lm.state.gradientDepth,i)){let a=xy(t,e,n,r);return null!=s&&(a=wm(a,s)),QC(a,i,o)}let a=bm(t,"a","fused matMul"),l=bm(e,"b","fused matMul");[a,l]=nm(a,l);const u=n?a.shape[a.rank-2]:a.shape[a.rank-1],c=r?l.shape[l.rank-1]:l.shape[l.rank-2],h=n?a.shape[a.rank-1]:a.shape[a.rank-2],d=r?l.shape[l.rank-2]:l.shape[l.rank-1],p=a.shape.slice(0,-2),f=l.shape.slice(0,-2),m=Jp(p),g=Jp(f);Kp(a.rank>=2&&l.rank>=2&&a.rank===l.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${a.rank} and ${l.rank}.`),Kp(tf(p,f),()=>`Error in fused matMul: outer dimensions (${p}) and (${f}) of Tensors with shapes ${a.shape} and `+l.shape+" must match."),Kp(u===c,()=>`Error in fused matMul: inner shapes (${u}) and (${c}) of Tensors with shapes ${a.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`);const y=a.shape.slice(0,-2).concat([h,d]),b=n?a.as3D(m,u,h):a.as3D(m,h,u),v=r?l.as3D(g,d,c):l.as3D(g,c,d);let x,w;null!=s&&(x=bm(s,"bias","fused matMul"),[x]=nm(x,a),fm(y,x.shape)),null!=o&&(w=bm(o,"prelu weights","fused matMul"));const C={a:b,b:v};return null!=s&&(C.bias=x),null!=o&&(C.preluActivationWeights=w),lm.runKernelFunc((t,e)=>{const s=t.fusedBatchMatMul({a:b,b:v,transposeA:n,transposeB:r,bias:x,activation:i,preluActivationWeights:w});return e([b,v,s]),s},C,(t,e)=>{const[o,a,l]=e,u=ZC(t,l,i);let c={};return null!=s&&(c={bias:()=>JC(x,u)}),Object.assign(n||r?!n&&r?{a:()=>u.matMul(a,!1,!1),b:()=>u.matMul(o,!0,!1)}:n&&!r?{a:()=>a.matMul(u,!1,!0),b:()=>o.matMul(u,!1,!1)}:{a:()=>a.matMul(u,!0,!0),b:()=>u.matMul(o,!0,!0)}:{a:()=>u.matMul(a,!1,!0),b:()=>o.matMul(u,!0,!1)},c)},"_FusedMatMul",{transposeA:n,transposeB:r,activation:i},[b,v],[!0]).reshape(y)}}),eS=xm({fusedConv2d_:function({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u}){if(!1===YC(lm.state.gradientDepth,l=l||"linear")){let c=Ty(t,e,n,r,s,i,o);return null!=a&&(c=wm(c,a)),QC(c,l,u)}const c=bm(t,"x","conv2d"),h=bm(e,"filter","conv2d");let d=c,p=!1;3===c.rank&&(p=!0,d=c.as4D(1,c.shape[0],c.shape[1],c.shape[2])),Kp(4===d.rank,()=>"Error in fused conv2d: input must be rank 4, but got rank "+d.rank+"."),Kp(4===h.rank,()=>"Error in fused conv2d: filter must be rank 4, but got rank "+h.rank+"."),null!=o&&Kp(ef(r),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`),Kp(d.shape[3]===h.shape[2],()=>`Error in conv2d: depth of input (${d.shape[3]}) must match input depth for filter ${h.shape[2]}.`),Kp(fy(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),Kp("NHWC"===s,()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);const f=oy(d.shape,h.shape,n,i,r,o);let m,g;null!=a&&(m=bm(a,"bias","fused conv2d"),[m]=nm(m,c),fm(f.outShape,m.shape)),null!=u&&(g=bm(u,"prelu weights","fused conv2d"));const y={x:d,filter:h};null!=a&&(y.bias=m),null!=u&&(y.preluActivationWeights=g);const b=lm.runKernelFunc((t,e)=>{const n=t.fusedConv2d({input:d,filter:h,convInfo:f,bias:m,activation:l,preluActivationWeights:g});return e([h,d,n]),n},y,(t,e)=>{const[s,o,u]=e,c=ZC(t,u,l);Kp(py(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);let h={};return null!=a&&(h={bias:()=>JC(m,c)}),Object.assign({x:()=>Iy(o.shape,c,s,n,r),filter:()=>Ay(o,c,s.shape,n,r)},h)},"FusedConv2D",{convInfo:f,activation:l},[h,d],[!0]);return p?b.as3D(b.shape[1],b.shape[2],b.shape[3]):b}}),nS=xm({fusedDepthwiseConv2d_:function({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u}){if(!1===YC(lm.state.gradientDepth,l)){let c=Mx(t,e,n,r,s,i,o);return null!=a&&(c=wm(c,a)),QC(c,l,u)}const c=bm(t,"x","depthwiseConv2d"),h=bm(e,"filter","depthwiseConv2d");let d=c,p=!1;3===c.rank&&(p=!0,d=c.as4D(1,c.shape[0],c.shape[1],c.shape[2])),Kp(4===d.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),Kp(4===h.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),Kp(d.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),null==i&&(i=[1,1]),Kp(fy(n,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),null!=o&&Kp(ef(r),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${o} but got pad ${r}.`);const f=oy(d.shape,h.shape,n,i,r,o,!0);let m,g;null!=a&&(m=bm(a,"bias","fused conv2d"),[m]=nm(m,c),fm(f.outShape,m.shape)),null!=u&&(g=bm(u,"prelu weights","fused depthwiseConv2d"));const y={x:d,filter:h};null!=a&&(y.bias=m),null!=u&&(y.preluActivationWeights=g);const b=lm.runKernelFunc((t,e)=>{const n=t.fusedDepthwiseConv2D({input:d,filter:h,convInfo:f,bias:m,activation:l,preluActivationWeights:g});return e([h,d,n]),n},y,(t,e)=>{Kp(py(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[n,r,s]=e,o=ZC(t,s,l);let u={};return null!=a&&(u={bias:()=>JC(m,o)}),Object.assign({x:()=>zy(r.shape,o,n,f),filter:()=>Py(r,o,n.shape,f)},u)},"FusedDepthwiseConv2D",{convInfo:f,activation:l},[h,d],[!0]);return p?b.as3D(b.shape[1],b.shape[2],b.shape[3]):b}});class rS extends ox{minimize(t,e=!1,n){const{value:r,grads:s}=this.computeGradients(t,n);if(null!=n){const t=n.map(t=>({name:t.name,tensor:s[t.name]}));this.applyGradients(t)}else this.applyGradients(s);return px(s),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){Kp(Sf(t),()=>"The f passed in variableGrads(f) must be a function"),Kp(null==e||Array.isArray(e)&&e.every(t=>t instanceof Gf),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=e;if(!n){e=[];for(const t in lm.registeredVariables)e.push(lm.registeredVariables[t])}const r=n?e.filter(t=>!t.trainable):null,s=e.length;Kp((e=e.filter(t=>t.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:i,grads:o}=lm.gradients(t,e,null,!0);Kp(o.some(t=>null!=t),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Kp(0===i.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const a={};return e.forEach((t,e)=>{null!=o[e]&&(a[t.name]=o[e])}),null!=r&&r.forEach(t=>a[t.name]=null),{value:i,grads:a}}(t,e)}dispose(){null!=this.iterations_&&px(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Nm(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for this optimizer class "+this.getClassName())}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(rS,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});class sS extends rS{constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=lm.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=lm.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:e+"/accum_grad",variable:dx(()=>Um(r).variable(!1))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:e+"/accum_var",variable:dx(()=>Um(r).variable(!1))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;dx(()=>{const t=i.mul(this.rho).add(s.square().mul(1-this.rho)),e=o.add(this.epsilon).sqrt().div(i.add(this.epsilon).sqrt()).mul(s),n=o.mul(this.rho).add(e.square().mul(1-this.rho));i.assign(t),o.assign(n);const a=e.mul(-this.learningRate).add(r);r.assign(a)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(px(this.accumulatedGrads.map(t=>t.variable)),px(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedUpdates=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}sS.className="Adadelta",lx(sS);class iS extends rS{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=lm.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:e+"/accumulator",variable:dx(()=>Wx(r.shape,this.initialAccumulatorValue).variable(t))}}const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const i=this.accumulatedGrads[n].variable;dx(()=>{const t=i.add(s.square());i.assign(t);const e=s.div(t.add(lm.backend.epsilon()).sqrt()).mul(-this.learningRate).add(r);r.assign(e)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&px(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),this.accumulatedGrads=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}iS.className="Adagrad",lx(iS);class oS extends rS{constructor(t,e,n,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],dx(()=>{this.accBeta1=Nm(e).variable(),this.accBeta2=Nm(n).variable()}),null==r&&(this.epsilon=lm.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);dx(()=>{const n=jy(1,this.accBeta1),r=jy(1,this.accBeta2);e.forEach((e,s)=>{const i=lm.registeredVariables[e];null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:e+"/m",variable:dx(()=>Um(i).variable(!1))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:e+"/v",variable:dx(()=>Um(i).variable(!1))});const o=Array.isArray(t)?t[s].tensor:t[e];if(null==o)return;const a=this.accumulatedFirstMoment[s].variable,l=this.accumulatedSecondMoment[s].variable,u=a.mul(this.beta1).add(o.mul(1-this.beta1)),c=l.mul(this.beta2).add(o.square().mul(1-this.beta2)),h=u.div(n),d=c.div(r);a.assign(u),l.assign(c);const p=h.div(d.sqrt().add(this.epsilon)).mul(-this.learningRate).add(i);i.assign(p)}),this.accBeta1.assign(this.accBeta1.mul(this.beta1)),this.accBeta2.assign(this.accBeta2.mul(this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&px(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&px(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),dx(()=>{this.accBeta1.assign(bb(this.beta1,this.iterations_+1)),this.accBeta2.assign(bb(this.beta2,this.iterations_+1))});const e=t.length/2;this.accumulatedFirstMoment=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedSecondMoment=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}oS.className="Adam",lx(oS);class aS extends rS{constructor(t,e,n,r=null,s=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],dx(()=>{this.iteration=Nm(0).variable(),this.accBeta1=Nm(e).variable()}),null==r&&(this.epsilon=lm.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);dx(()=>{const n=jy(1,this.accBeta1),r=tg(-this.learningRate,this.iteration.mul(this.decay).add(1));e.forEach((e,s)=>{const i=lm.registeredVariables[e];null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:e+"/m",variable:Um(i).variable(!1)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:e+"/v",variable:Um(i).variable(!1)});const o=Array.isArray(t)?t[s].tensor:t[e];if(null==o)return;const a=this.accumulatedFirstMoment[s].variable,l=this.accumulatedWeightedInfNorm[s].variable,u=a.mul(this.beta1).add(o.mul(1-this.beta1)),c=l.mul(this.beta2),h=o.abs(),d=c.maximum(h);a.assign(u),l.assign(d);const p=r.div(n).mul(u.div(d.add(this.epsilon))).add(i);i.assign(p)}),this.iteration.assign(this.iteration.add(1)),this.accBeta1.assign(this.accBeta1.mul(this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&px(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&px(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}aS.className="Adamax",lx(aS);class lS extends rS{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const s=lm.registeredVariables[e];dx(()=>{const t=this.c.mul(r).add(s);s.assign(t)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=fx(Nm(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}lS.className="SGD",lx(lS);class uS extends lS{constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=Nm(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=lm.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:e+"/momentum",variable:dx(()=>Um(r).variable(t))}}const s=this.accumulations[n].variable,i=Array.isArray(t)?t[n].tensor:t[e];null!=i&&dx(()=>{let t;const e=this.m.mul(s).add(i);t=this.useNesterov?this.c.mul(i.add(e.mul(this.m))).add(r):this.c.mul(e).add(r),s.assign(e),r.assign(t)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&px(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),this.accumulations=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}uS.className="Momentum",lx(uS);class cS extends rS{constructor(t,e=.9,n=0,r=null,s=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=lm.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=lm.registeredVariables[e];null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:e+"/rms",variable:dx(()=>Um(r).variable(!1))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:e+"/momentum",variable:dx(()=>Um(r).variable(!1))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:e+"/mg",variable:dx(()=>Um(r).variable(!1))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;dx(()=>{const t=i.mul(this.decay).add(s.square().mul(1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,a=e.mul(this.decay).add(s.mul(1-this.decay)),l=o.mul(this.momentum).add(s.mul(this.learningRate).div(t.sub(a.square().add(this.epsilon)).sqrt()));i.assign(t),e.assign(a),o.assign(l);const u=r.sub(l);r.assign(u)}else{const t=i.mul(this.decay).add(s.square().mul(1-this.decay)),e=o.mul(this.momentum).add(s.mul(this.learningRate).div(t.add(this.epsilon).sqrt()));i.assign(t),o.assign(e);const n=r.sub(e);r.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&px(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&px(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&px(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2;this.accumulatedMeanSquares=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedMoments=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}cS.className="RMSProp",lx(cS);class hS{static sgd(t){return new lS(t)}static momentum(t,e,n=!1){return new uS(t,e,n)}static rmsprop(t,e=.9,n=0,r=null,s=!1){return new cS(t,e,n,r,s)}static adam(t=.001,e=.9,n=.999,r=null){return new oS(t,e,n,r)}static adadelta(t=.001,e=.95,n=null){return new sS(t,e,n)}static adamax(t=.002,e=.9,n=.999,r=null,s=0){return new aS(t,e,n,r,s)}static adagrad(t,e=.1){return new iS(t,e)}}const dS={sgd:hS.sgd,momentum:hS.momentum,adadelta:hS.adadelta,adagrad:hS.adagrad,rmsprop:hS.rmsprop,adamax:hS.adamax,adam:hS.adam},pS="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:t=>t();function fS(){return new Promise(t=>pS(()=>t()))}function mS(t,e,n,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(t[0]/n),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const n=e.length;for(let r=0;r<n;++r)s=s.concat([t[r+1]/e[r],e[r]]);s=s.concat(t.slice(n+1))}return s}function gS(t,e,n=!0){const r=[];if(n){r.push(e);for(let n=e+1;n<t;++n)n<=2*e?(r.push(n),r.push(n-(e+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<t;++r)r>=2*e+1||r%2==1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function yS(t,e,n,r=!0){const s=[];s.push(r?t[0]/n:t[0]*n);for(let i=1;i<t.length;++i)s.push(i<=e.length?r?e[i-1]*t[i]:t[i]/e[i-1]:t[i]);return s}function bS(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function vS(t,e,n){const r=t.slice(0,1);for(let s=0;s<n;++s)r.push(t[s+1]-e[s][0]-e[s][1]);return r}const xS=.3275911,wS=.254829592,CS=-.284496736,SS=1.421413741,_S=-1.453152027,ES=1.061405429;function kS(...t){Np().getBool("IS_TEST")||console.warn(...t)}function AS(...t){Np().getBool("IS_TEST")||console.log(...t)}function IS(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(2*t.length);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function NS(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function TS(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function RS(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function $S(t,e){return{real:t[2*e],imag:t[2*e+1]}}function DS(t,e,n,r){t[2*r]=e,t[2*r+1]=n}function OS(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const i=(e?2:-2)*Math.PI*(s/t);n[s]=Math.cos(i),r[s]=Math.sin(i)}return{real:n,imag:r}}function FS(t,e,n){const r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}}function MS(t,e,n){if("complex64"===e){if("complex64"===t.dtype)return t.clone();const e=Pm(t.shape),r=t.toFloat(),s=n.complex(r,e);return e.dispose(),r.dispose(),s}if(!mf(t.dtype,e))return lm.makeTensorFromDataId(t.dataId,t.shape,e);if("complex64"===t.dtype){const r=n.real(t),s=r.cast(e);return r.dispose(),s}if("int32"===e)return n.int(t);if("bool"===e){const e=Nm(0,t.dtype),r=n.notEqual(t,e);return e.dispose(),r}throw new Error(`Error in Cast: failed to cast ${t.dtype} to ${e}`)}function LS(t,e){return lm.makeTensorFromDataId(t.dataId,e,t.dtype)}function PS(t,e,n){const r=(e-t)/(n-1),s=Nf(n,"float32");s[0]=t;for(let i=1;i<s.length;i++)s[i]=s[i-1]+r;return Tm(s,"float32")}function zS(t,e,n){const r=new Array(t.rank).fill(0),s=t.shape.slice();return e.map(e=>{const i=[...s];i[n]=e;const o=t.slice(r,i);return r[n]+=e,o})}function BS(t,e){const n=new Array(t.rank);for(let s=0;s<n.length;s++)n[s]=t.shape[s]*e[s];const r=jm(n,t.dtype);for(let s=0;s<r.values.length;++s){const e=r.indexToLoc(s),n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=e[r]%t.shape[r];const i=t.locToIndex(n);r.values[s]=t.values[i]}return r.toTensor()}function VS(t,e,n,r,s){const i=e[e.length-1],[o,a]=[t.length/i,i],l=hf(n,o*r),u=hf("int32",o*r);for(let h=0;h<o;h++){const e=h*a,n=t.subarray(e,e+a),s=[];for(let t=0;t<n.length;t++)s.push({value:n[t],index:t});s.sort((t,e)=>e.value-t.value);const i=h*r,o=l.subarray(i,i+r),c=u.subarray(i,i+r);for(let t=0;t<r;t++)o[t]=s[t].value,c[t]=s[t].index}const c=e.slice();return c[c.length-1]=r,[Am(l,c,n),Am(u,c,"int32")]}class US{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class WS{time(t){return jS("time")}read(t){return jS("read")}readSync(t){return jS("readSync")}numDataIds(){return jS("numDataIds")}disposeData(t){return jS("disposeData")}write(t,e,n){return jS("write")}move(t,e,n,r){return jS("move")}memory(){return jS("memory")}floatPrecision(){return jS("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}batchMatMul(t,e,n,r){return jS("batchMatMul")}fusedBatchMatMul({}){return jS("fusedBatchMatMul")}slice(t,e,n){return jS("slice")}stridedSlice(t,e,n,r){return jS("stridedSlice")}unstack(t,e){return jS("unstack")}reverse(t,e){return jS("reverse")}concat(t,e){return jS("concat")}neg(t){return jS("neg")}add(t,e){return jS("add")}addN(t){return jS("addN")}subtract(t,e){return jS("subtract")}multiply(t,e){return jS("multiply")}realDivide(t,e){return jS("realDivide")}floorDiv(t,e){return jS("floorDiv")}sum(t,e){return jS("sum")}prod(t,e){return jS("prod")}unsortedSegmentSum(t,e,n){return jS("unsortedSegmentSum")}argMin(t,e){return jS("argMin")}argMax(t,e){return jS("argMax")}equal(t,e){return jS("equal")}notEqual(t,e){return jS("notEqual")}less(t,e){return jS("less")}lessEqual(t,e){return jS("lessEqual")}greater(t,e){return jS("greater")}greaterEqual(t,e){return jS("greaterEqual")}logicalNot(t){return jS("logicalNot")}logicalAnd(t,e){return jS("logicalAnd")}logicalOr(t,e){return jS("logicalOr")}where(t){return jS("where")}select(t,e,n){return jS("select")}topk(t,e,n){return jS("topk")}min(t,e){return jS("min")}minimum(t,e){return jS("minimum")}mod(t,e){return jS("mod")}max(t,e){return jS("max")}maximum(t,e){return jS("maximum")}all(t,e){return jS("all")}any(t,e){return jS("any")}squaredDifference(t,e){return jS("squaredDifference")}ceil(t){return jS("ceil")}floor(t){return jS("floor")}round(t){return jS("round")}sign(t){return jS("sign")}isNaN(t){return jS("isNaN")}isInf(t){return jS("isInf")}isFinite(t){return jS("isFinite")}pow(t,e){return jS("pow")}exp(t){return jS("exp")}expm1(t){return jS("expm1")}softmax(t,e){return jS("softmax")}log(t){return jS("log")}log1p(t){return jS("log1p")}sqrt(t){return jS("sqrt")}rsqrt(t){return jS("rsqrt")}square(t){return jS("square")}reciprocal(t){return jS("reciprocal")}relu(t){return jS("relu")}relu6(t){return jS("relu6")}prelu(t,e){return jS("prelu")}elu(t){return jS("elu")}eluDer(t,e){return jS("eluDer")}selu(t){return jS("selu")}int(t){return jS("int")}clip(t,e,n){return jS("clip")}abs(t){return jS("abs")}complexAbs(t){return jS("complexAbs")}sigmoid(t){return jS("sigmoid")}softplus(t){return jS("softplus")}sin(t){return jS("sin")}cos(t){return jS("cos")}tan(t){return jS("tan")}asin(t){return jS("asin")}acos(t){return jS("acos")}atan(t){return jS("atan")}atan2(t,e){return jS("atan2")}sinh(t){return jS("sinh")}cosh(t){return jS("cosh")}tanh(t){return jS("tanh")}asinh(t){return jS("asinh")}acosh(t){return jS("acosh")}atanh(t){return jS("atanh")}erf(t){return jS("erf")}step(t,e){return jS("step")}fusedConv2d({}){return jS("fusedConv2d")}conv2d(t,e,n){return jS("conv2d")}conv2dDerInput(t,e,n){return jS("conv2dDerInput")}conv2dDerFilter(t,e,n){return jS("conv2dDerFilter")}fusedDepthwiseConv2D({}){return jS("fusedDepthwiseConv2D")}depthwiseConv2D(t,e,n){return jS("depthwiseConv2D")}depthwiseConv2DDerInput(t,e,n){return jS("depthwiseConv2DDerInput")}depthwiseConv2DDerFilter(t,e,n){return jS("depthwiseConv2DDerFilter")}conv3d(t,e,n){return jS("conv3d")}conv3dDerInput(t,e,n){return jS("conv3dDerInput")}conv3dDerFilter(t,e,n){return jS("conv3dDerFilter")}maxPool(t,e){return jS("maxPool")}maxPoolBackprop(t,e,n,r){return jS("maxPoolBackprop")}avgPool(t,e){return jS("avgPool")}avgPoolBackprop(t,e,n){return jS("avgPoolBackprop")}avgPool3d(t,e){return jS("avgPool3d")}avgPool3dBackprop(t,e,n){return jS("avgPool3dBackprop")}maxPool3d(t,e){return jS("maxPool3d")}maxPool3dBackprop(t,e,n,r){return jS("maxPool3dBackprop")}reshape(t,e){return jS("reshape")}cast(t,e){return jS("cast")}tile(t,e){return jS("tile")}pad(t,e,n){return jS("pad")}transpose(t,e){return jS("transpose")}gather(t,e,n){return jS("gather")}gatherND(t,e){return jS("gatherND")}scatterND(t,e,n){return jS("scatterND")}batchToSpaceND(t,e,n){return jS("batchToSpaceND")}spaceToBatchND(t,e,n){return jS("spaceToBatchND")}resizeBilinear(t,e,n,r){return jS("resizeBilinear")}resizeBilinearBackprop(t,e,n){return jS("resizeBilinearBackprop")}resizeNearestNeighbor(t,e,n,r){return jS("resizeNearestNeighbor")}resizeNearestNeighborBackprop(t,e,n){return jS("resizeNearestNeighborBackprop")}batchNorm(t,e,n,r,s,i){return jS("batchNorm")}localResponseNormalization4D(t,e,n,r,s){return jS("localResponseNormalization4D")}LRNGrad(t,e,n,r,s,i,o){return jS("LRNGrad")}multinomial(t,e,n,r){return jS("multinomial")}oneHot(t,e,n,r){return jS("oneHot")}cumsum(t,e,n,r){return jS("cumsum")}nonMaxSuppression(t,e,n,r,s){return jS("nonMaxSuppression")}fft(t){return jS("fft")}ifft(t){return jS("ifft")}complex(t,e){return jS("complex")}real(t){return jS("real")}imag(t){return jS("imag")}cropAndResize(t,e,n,r,s,i){return jS("cropAndResize")}depthToSpace(t,e,n){return jS("depthToSpace")}split(t,e,n){return jS("split")}sparseToDense(t,e,n,r){return jS("sparseToDense")}diag(t){return jS("diag")}fill(t,e,n){return jS("fill")}onesLike(t){return jS("onesLike")}zerosLike(t){return jS("zerosLike")}linspace(t,e,n){return jS("linspace")}dispose(){return jS("dispose")}}function jS(t){throw new Error(`'${t}' not yet implemented or not found in the registry. Did you forget to import the kernel?`)}let HS;function qS(){return null==HS&&(HS=lm.backend.epsilon()),HS}qf.prototype.add=function(t){return this.throwIfDisposed(),wm(this,t)},qf.prototype.atan2=function(t){return this.throwIfDisposed(),yx(this,t)},qf.prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),bx(this,t,e,n,r)},qf.prototype.batchNorm=function(t,e,n,r,s){return this.throwIfDisposed(),wx(this,t,e,n,r,s)},qf.prototype.broadcastTo=function(t){return this.throwIfDisposed(),kx(this,t)},qf.prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),kb(this,t,e)},qf.prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof qf&&(t=[t]),Wm([this,...t],e)},qf.prototype.conv1d=function(t,e,n,r,s,i){return this.throwIfDisposed(),Rx(this,t,e,n,r,s,i)},qf.prototype.conv2d=function(t,e,n,r,s,i){return this.throwIfDisposed(),Ty(this,t,e,n,r,s,i)},qf.prototype.conv2dTranspose=function(t,e,n,r,s){return this.throwIfDisposed(),$x(this,t,e,n,r,s)},qf.prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),My(this,t,e,n)},qf.prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),Fx(this,t,e)},qf.prototype.depthwiseConv2d=function(t,e,n,r,s,i){return this.throwIfDisposed(),Mx(this,t,e,n,r,s,i)},qf.prototype.depthwiseConv2D=function(t,e,n,r,s,i){return ux("depthwiseConv2D is deprecated, use depthwiseConv2d instead"),this.throwIfDisposed(),Mx(this,t,e,n,r,s,i)},qf.prototype.div=function(t){return this.throwIfDisposed(),tg(this,t)},qf.prototype.divNoNan=function(t){return this.throwIfDisposed(),Px(this,t)},qf.prototype.dot=function(t){return this.throwIfDisposed(),zx(this,t)},qf.prototype.elu=function(){return this.throwIfDisposed(),Bx(this)},qf.prototype.equal=function(t){return this.throwIfDisposed(),Vx(this,t)},qf.prototype.floorDiv=function(t){return this.throwIfDisposed(),Qm(this,t)},qf.prototype.greater=function(t){return this.throwIfDisposed(),sb(this,t)},qf.prototype.greaterEqual=function(t){return this.throwIfDisposed(),Zy(this,t)},qf.prototype.leakyRelu=function(t){return this.throwIfDisposed(),Hx(this,t)},qf.prototype.less=function(t){return this.throwIfDisposed(),Jy(this,t)},qf.prototype.lessEqual=function(t){return this.throwIfDisposed(),ib(this,t)},qf.prototype.localResponseNormalization=function(t,e,n,r){return this.throwIfDisposed(),qx(this,t,e,n,r)},qf.prototype.matMul=function(t,e,n){return this.throwIfDisposed(),xy(this,t,e,n)},qf.prototype.max=function(t,e){return this.throwIfDisposed(),Gx(this,t,e)},qf.prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),Kx(this,t,e,n,r)},qf.prototype.maximum=function(t){return this.throwIfDisposed(),jx(this,t)},qf.prototype.minimum=function(t){return this.throwIfDisposed(),Zx(this,t)},qf.prototype.mod=function(t){return this.throwIfDisposed(),Jx(this,t)},qf.prototype.mul=function(t){return this.throwIfDisposed(),eg(this,t)},qf.prototype.notEqual=function(t){return this.throwIfDisposed(),tw(this,t)},qf.prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),Jv(this,t,e,n)},qf.prototype.pad=function(t,e){return this.throwIfDisposed(),$b(this,t,e)},qf.prototype.pool=function(t,e,n,r,s){return this.throwIfDisposed(),ow(this,t,e,n,r,s)},qf.prototype.pow=function(t){return this.throwIfDisposed(),bb(this,t)},qf.prototype.prelu=function(t){return this.throwIfDisposed(),aw(this,t)},qf.prototype.relu=function(){return this.throwIfDisposed(),gw(this)},qf.prototype.relu6=function(){return this.throwIfDisposed(),yw(this)},qf.prototype.selu=function(){return this.throwIfDisposed(),bw(this)},qf.prototype.separableConv2d=function(t,e,n,r,s,i){return this.throwIfDisposed(),vw(this,t,e,n,r,s,i)},qf.prototype.split=function(t,e){return this.throwIfDisposed(),Ey(this,t,e)},qf.prototype.squaredDifference=function(t){return this.throwIfDisposed(),xw(this,t)},qf.prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),Cy(this,t,e)},qf.prototype.sub=function(t){return this.throwIfDisposed(),jy(this,t)},qf.prototype.tile=function(t){return this.throwIfDisposed(),Hy(this,t)},qf.prototype.transpose=function(t){return this.throwIfDisposed(),Fy(this,t)},jf=y;class GS extends Error{constructor(t){super(t),Object.setPrototypeOf(this,GS.prototype)}}class KS extends Error{constructor(t){super(t),Object.setPrototypeOf(this,KS.prototype)}}class XS extends Error{constructor(t){super(t),Object.setPrototypeOf(this,XS.prototype)}}class YS extends Error{constructor(t){super(t),Object.setPrototypeOf(this,YS.prototype)}}class ZS extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ZS.prototype)}}function JS(t,e){if(Array.isArray(t)){let n=[];for(let r=0;r<e;r++)n=n.concat(t);return n}{const n=new Array(e);return n.fill(t),n}}function QS(t,e){if(!t)throw new ZS(e)}function t_(t,e){let n=0;for(const r of t)r===e&&n++;return n}function e_(t){return 1===t.length?t[0]:t}function n_(t){return Array.isArray(t)?t:[t]}function r_(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function s_(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}Error;let i_={};function o_(t){if(null==t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function a_(t,e={},n={},r="object",s=!1){if("string"==typeof t){const s=t;let i;if(s in n)i=n[s];else if(s in i_)i=i_[s];else if(i=e[s],null==i)throw new XS(`Unknown ${r}: ${t}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const i=t;if(null==i.className||null==i.config)throw new XS(r+": Improper config format: "+JSON.stringify(i)+".\n'className' and 'config' must set.");const o=i.className;let a,l;if(o in n?[a,l]=n[o]:o in i_?[a,l]=i_.className:o in e&&([a,l]=e[o]),null==a)throw new XS(`Unknown ${r}: ${o}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const t={};for(const n of Object.keys(i_))t[n]=i_[n];for(const s of Object.keys(n))t[s]=n[s];i.config.customObjects=t;const e=Object.assign({},i_);for(const s of Object.keys(n))i_[s]=n[s];!function t(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach(e=>t(e));else{const n=Object.keys(e);for(const r of n){const n=e[r];null!=n&&"object"==typeof n&&(Array.isArray(n)||"ndarray"!==n.type||"number"!=typeof n.value?t(n):e[r]=n.value)}}}(i.config);const r=l(a,i.config,n,s);return i_=Object.assign({},e),r}{const t=Object.assign({},i_);for(const r of Object.keys(n))i_[r]=n[r];const e=new a(i.config);return i_=Object.assign({},t),e}}}function l_(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function u_(t){if(null==t)return t;const e=[];for(const n of t)-1===e.indexOf(n)&&e.push(n);return e}function c_(t){if(null==t)throw new XS("Invalid value in obj: "+JSON.stringify(t));for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function h_(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new XS(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function d_(t,e,n=0,r=1/0){return QS(n>=0),QS(r>=n),Array.isArray(t)&&t.length>=n&&t.length<=r&&t.every(t=>typeof t===e)}function p_(t,e){Array.isArray(t)?(r.assert(t.length>0,()=>e+" is unexpectedly an empty array."),t.forEach((t,n)=>p_(t,`element ${n+1} of ${e}`))):r.assert(Number.isInteger(t)&&t>0,()=>`Expected ${e} to be a positive integer, but got `+function t(e){return null===e?"null":Array.isArray(e)?"["+e.map(e=>t(e)).join(",")+"]":"string"==typeof e?`"${e}"`:""+e}(t)+".")}function f_(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}function m_(t,e){return dx(()=>Qg(xg(eg(t,t),e,!0)))}class g_ extends u.Serializable{getConfig(){return{}}}class y_ extends g_{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return dx(()=>{const e=m_(t,this.axis),n=Rg(e,0,this.maxValue);return eg(t,tg(n,wm(qS(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}y_.className="MaxNorm",u.registerClass(y_);class b_ extends g_{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return dx(()=>tg(t,wm(qS(),m_(t,this.axis))))}getConfig(){return{axis:this.axis}}}b_.className="UnitNorm",u.registerClass(b_);class v_ extends g_{apply(t){return gw(t)}}v_.className="NonNeg",u.registerClass(v_);class x_ extends g_{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return dx(()=>{const e=m_(t,this.axis),n=wm(eg(this.rate,Rg(e,this.minValue,this.maxValue)),eg(1-this.rate,e));return eg(t,tg(n,wm(qS(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}x_.className="MinMaxNorm",u.registerClass(x_);const w_={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function C_(t){return o_(t)}function S_(t,e={}){return a_(t,u.SerializationMap.getMap().classNameMap,e,"constraint")}function __(t){return null==t?null:"string"==typeof t?S_({className:t in w_?w_[t]:t,config:{}}):t instanceof g_?t:S_(t)}const E_=["channelsFirst","channelsLast"],k_=["valid","same","causal"],A_=["max","avg"],I_=["sum","mul","concat","ave"],N_=new Map;function T_(t){h_(E_,"DataFormat",t)}function R_(t){h_(k_,"PaddingMode",t)}function $_(t){h_(A_,"PoolMode",t)}const D_=[];function O_(t,e){D_.push(t);try{const t=e();return D_.pop(),t}catch(n){throw D_.pop(),n}}function F_(t){if(!P_(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===D_.length?"":D_.join("/")+"/")+t}function M_(t){if(!P_(t))throw new Error("Not a valid tensor name: '"+t+"'");N_.has(t)||N_.set(t,0);const e=N_.get(t);if(N_.set(t,N_.get(t)+1),e>0){const n=`${t}_${e}`;return N_.set(n,1),n}return t}const L_=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function P_(t){return!!t.match(L_)}function z_(t,e,n){null==e&&(e=0),null==n&&(n=t.length);let r=1;for(let s=e;s<n;++s)r*=t[s];return r}function B_(t){return Tm(t=Array.isArray(t)?new Float32Array(t):t)}function V_(t){return bg(B_(t)).dataSync()[0]}function U_(t){return Gx(B_(t)).dataSync()[0]}function W_(t,e){if(e<t)throw new XS(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let r=t;r<e;++r)n.push(r);return n}function j_(t,e){return t.asType(e)}function H_(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),t.reshape(n)}function q_(t,e,n){return dx(()=>{switch(t.rank){case 1:return Hb(t,e,n);case 2:return qb(t,[e,0],[n,t.shape[1]]);case 3:return Gb(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return Kb(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return jb(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return jb(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new XS("sliceAlongFirstAxis() received an unsupported tensor rank: "+t.rank)}})}function G_(t,e,n){return dx(()=>{switch(t.rank){case 1:return Hb(t,e,n);case 2:return qb(t,[0,e],[t.shape[0],n]);case 3:return Gb(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return Kb(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new XS("sliceAlongLastAxis() received an unsupported tensor rank: "+t.rank)}})}function K_(t,e,n,r){return dx(()=>{switch(t.rank){case 1:return Hb(t,e,n);case 2:switch(r){case 1:return q_(t,e,n);case 2:return G_(t,e,n);default:throw new XS("The axis is not within the rank of the tensor "+r)}case 3:switch(r){case 1:return q_(t,e,n);case 2:return Gb(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return G_(t,e,n);default:throw new XS("The axis is not within the rank of the tensor "+r)}case 4:switch(r){case 1:return q_(t,e,n);case 2:return Kb(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return Kb(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return G_(t,e,n);default:throw new XS("The axis is not within the rank of the tensor "+r)}default:throw new XS("sliceAlongLastAxis() received an unsupported tensor rank: "+t.rank)}})}function X_(t,e=-1){let n;return e<0&&(n=t[0].rank,e=0!==n?n:0),e===t[0].rank&&(e=-1),Wm(t,e)}function Y_(t,e){switch(t.rank){case 1:return Ax([t,e]);case 2:return Ix([t,e],0);case 3:return Nx([t,e],0);case 4:return Tx([t,e],0);default:throw new XS("concatAlongFirstAxis() received an unsupported tensor rank: "+t.rank)}}function Z_(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new XS(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return Hy(t,e)}function J_(t,e=0,n=1,r,s){return fw(t,e,n,r,s)}function Q_(t,e,n,r){if(t.rank<2||e.rank<2)throw new YS(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3&&t.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new YS(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = `+e.shape);if(2===t.rank&&2===e.rank)return g.matMul({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?nE(t.rank,r,"channelsLast"):null,activation:n});{const s=t.shape.slice(),i=s.pop();t=t.reshape([-1,i]);const o=e.shape.slice(),a=o.pop(),l=o.pop(),u=[...o,a],c=Array.from({length:e.rank},(t,n)=>0===n?e.rank-2:n<=e.rank-2?n-1:n);e=e.transpose(c).reshape([l,-1]);const h=[...s,...u];return g.matMul({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?nE(t.rank,r,"channelsLast"):null,activation:n}).reshape(h)}}function tE(t,e,n){return dx(()=>(e=Array.isArray(e)?Tm(e,"int32"):e.toInt(),Nw(t,e,n)))}function eE(t){return eg(t,t)}function nE(t,e,n){const r=e.shape;if(1!==e.rank&&e.rank!==t)throw new XS("Unexpected bias dimensions: "+e.rank+"; expected it to be 1 or "+t);if(5===t){if("channelsFirst"===n)return e.reshape(1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return e.reshape(1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===t){if("channelsFirst"===n)return e.reshape(1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===n)return e.reshape(1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===t){if("channelsFirst"===n)return e.reshape(1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===n)return e.reshape(1===r.length?[1,1,r[0]]:[1].concat(r))}else if(t<3)return e;throw new XS("Unsupported input rank by biasAdd: "+e.rank)}function rE(t,e,n){return dx(()=>(null==n&&(n="channelsLast"),T_(n),t.add(nE(t.rank,e,n))))}function sE(t,e,n,r){return dx(()=>pC(t,e,n,r))}function iE(t,e,n=!1){return n?t():e()}const oE=["fanIn","fanOut","fanAvg"],aE=["normal","uniform","truncatedNormal"];class lE extends u.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class uE extends lE{apply(t,e){return Pm(t,e)}}uE.className="Zeros",u.registerClass(uE);class cE extends lE{apply(t,e){return Lm(t,e)}}cE.className="Ones",u.registerClass(cE);class hE extends lE{constructor(t){if(super(),"object"!=typeof t)throw new XS("Expected argument of type ConstantConfig but got "+t);if(void 0===t.value)throw new XS("config must have value set but got "+t);this.value=t.value}apply(t,e){return dx(()=>eg(Nm(this.value),Lm(t,e)))}getConfig(){return{value:this.value}}}hE.className="Constant",u.registerClass(hE);class dE extends lE{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return mw(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}dE.className="RandomUniform",u.registerClass(dE);class pE extends lE{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new YS(`randomNormal does not support dType ${e}.`);return J_(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}pE.className="RandomNormal",u.registerClass(pE);class fE extends lE{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new YS(`truncatedNormal does not support dType ${e}.`);return ww(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}fE.className="TruncatedNormal",u.registerClass(fE);class mE extends lE{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return dx(()=>{if(2!==t.length||t[0]!==t[1])throw new XS("Identity matrix initializer can only be used for 2D square matrices.");return eg(this.gain,Ux(t[0]))})}getConfig(){return{gain:this.gain}}}mE.className="Identity",u.registerClass(mE);class gE extends lE{constructor(t){if(super(),t.scale<0)throw new XS("scale must be a positive float. Got: "+t.scale);this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,h_(oE,"FanMode",this.mode),this.distribution=null==t.distribution?"normal":t.distribution,function(t){h_(aE,"Distribution",t)}(this.distribution),this.seed=t.seed}apply(t,e){const n=function(t,e="channelsLast"){let n,r;if(T_(e),2===t.length)n=t[0],r=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===e){const e=z_(t,2);n=t[1]*e,r=t[0]*e}else if("channelsLast"===e){const e=z_(t,0,t.length-2);n=t[t.length-2]*e,r=t[t.length-1]*e}}else{const e=z_(t);n=Math.sqrt(e),r=Math.sqrt(e)}return[n,r]}(t),r=n[0],s=n[1];let i=this.scale;if(i/="fanIn"===this.mode?Math.max(1,r):"fanOut"===this.mode?Math.max(1,s):Math.max(1,(r+s)/2),"normal"===this.distribution){const n=Math.sqrt(i);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new YS(`${this.getClassName()} does not support dType ${e}.`);return ww(t,0,n,e,this.seed)}{const n=Math.sqrt(3*i);return mw(t,-n,n,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}gE.className="VarianceScaling",u.registerClass(gE);class yE extends gE{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return gE.className}}yE.className="GlorotUniform",u.registerClass(yE);class bE extends gE{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return gE.className}}bE.className="GlorotNormal",u.registerClass(bE);class vE extends gE{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return gE.className}}vE.className="HeNormal",u.registerClass(vE);class xE extends gE{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return gE.className}}xE.className="HeUniform",u.registerClass(xE);class wE extends gE{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return gE.className}}wE.className="LeCunNormal",u.registerClass(wE);class CE extends gE{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return gE.className}}CE.className="LeCunNormal",u.registerClass(CE);class SE extends lE{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,null!=this.seed)throw new YS("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return dx(()=>{if(2!==t.length)throw new YS("The Orthogonal Initializer does not support non-2D shapes yet.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);const e=J_(t[0]>t[1]?[t[1],t[0]]:t,0,1,"float32");let n=f.gramSchmidt(e);return t[0]>t[1]&&(n=n.transpose()),eg(this.gain,n)})}getConfig(){return{gain:this.gain,seed:this.seed}}}SE.className="Orthogonal",u.registerClass(SE);const _E={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function EE(t,e={}){return a_(t,u.SerializationMap.getMap().classNameMap,e,"initializer")}function kE(t){return o_(t)}function AE(t){if("string"==typeof t){const e=t in _E?_E[t]:t;if("GlorotNormal"===e)return new bE;if("GlorotUniform"===e)return new yE;if("HeNormal"===e)return new vE;if("HeUniform"===e)return new xE;if("LeCunNormal"===e)return new wE;if("LeCunUniform"===e)return new CE;{const t={};return t.className=e,t.config={},EE(t)}}return t instanceof lE?t:EE(t)}let IE=0;function NE(){return IE++}const TE={};function RE(t=""){return t in TE||(TE[t]=0),TE[t]+=1,t+TE[t].toString()}function $E(t){return Array.isArray(t)&&Array.isArray(t[0])}function DE(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function OE(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new XS("Expected Tensor length to be 1; got "+t.length);e=t[0]}else e=t;return e}function FE(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return(t=t)[0];throw new XS("Expected exactly 1 Shape; got "+t.length)}return t}function ME(t){let e=0;for(const n of t)e+=0===n.shape.length?1:n.shape.reduce((t,e)=>t*e);return e}class LE{constructor(t,e="float32",n="Variable",r=!0,s=null){this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=NE(),this.originalName=F_(n=null==n?"Variable":n),this.name=M_(this.originalName),this.trainable_=r,this.constraint=s,this.val=Mm(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function PE(t){return t.map(t=>t.read())}function zE(t){t.forEach(t=>{t[0].write(t[1])})}class BE{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class VE{constructor(t,e,n,r,s,i,o){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=o,this.id=NE(),null!=i&&(this.originalName=F_(i),this.name=M_(this.originalName)),this.rank=e.length}}let UE=0;class WE{constructor(t,e){this.callArgs=e,this.id=UE++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const n of t.inboundLayers)null!=n&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let jE=0;class HE extends u.Serializable{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=jE++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const t=this.getClassName();e=r_(t)+"_"+RE(t)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new KS(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new XS(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return e_(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return e_(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new GS("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new GS("Layer "+this.name+" is not connected, no input to return.");return e_(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new GS("Layer "+this.name+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new GS("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return e_(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=n_(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=n_(this.inputSpec);if(t.length!==e.length)throw new XS(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: `+t);for(let n=0;n<t.length;n++){const r=t[n],s=e[n];if(null==s)continue;const i=r.rank;if(null!=s.ndim&&i!==s.ndim)throw new XS(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(null!=s.maxNDim&&i>s.maxNDim)throw new XS(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(null!=s.minNDim&&i<s.minNDim)throw new XS(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(null!=s.dtype&&r.dtype!==s.dtype)throw new XS(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){const t=r.shape;for(const e in s.axes){const r=Number(e),i=s.axes[e],o=r>=0?t[r]:t[t.length+r];if(null!=i&&-1===[i,null].indexOf(o))throw new XS(`Input ${n} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${i} but got shape ${t}.`)}}if(null!=s.shape)for(let t=0;t<s.shape.length;++t){const e=s.shape[t],i=r.shape[t];if(null!=e&&null!=i&&e!==i)throw new XS(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=n_(t);let r=!0;for(const i of n)if(!(i instanceof VE)){r=!1;break}let s=!0;for(const i of n)if(i instanceof VE){s=!1;break}if(r===s)throw new XS("Arguments to apply() must be all SymbolicTensors or all Tensors");return O_(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of n_(t))e.push(n.shape);this.build(e_(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(t),s){let r=this.call(t,e);const s=n_(r),i=[];for(let t of s)-1!==n.indexOf(t)&&(t=t.clone()),i.push(t);if(r=e_(i),null!=this.activityRegularizer)throw new YS("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(t){t=n_(t);const e=[];for(const n of t)e.push(n.shape);return e_(e)}(t),r=this.computeOutputShape(n);let s;const i="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),s=null!=r&&r.length>0&&Array.isArray(r[0])?r.map((n,r)=>new VE(i,n,this,n_(t),e,this.name,r)):new VE(i,r,this,n_(t),e,this.name),this.addInboundNode(t,s,null,null,n,r,e),this._refCount++,null!=this.activityRegularizer)throw new YS("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+JSON.stringify(t)+") does not match that of the "+`batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer `+this.name);else{let e=!1;this.batchInputShape.forEach((n,r)=>{null!=n&&null!=t[r]&&t[r]!==n&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: `+JSON.stringify(this.batchInputShape))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new GS(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new GS(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "outut shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new KS(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return ME(this.weights)}build(t){this.built=!0}getWeights(t=!1){return PE(t?this.trainableWeights:this.weights)}setWeights(t){dx(()=>{const e=this.weights;if(e.length!==t.length)throw new XS(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const n=[],s=PE(e);for(let i=0;i<s.length;++i){const o=s[i],a=e[i],l=t[i];if(!r.arraysEqual(o.shape,l.shape))throw new XS(`Layer weight shape ${o.shape} not compatible with provided weight shape `+l.shape);n.push([a,l])}zE(n)})}addWeight(t,e,n,r,s,i,o){if(-1!==this._addedWeightNames.indexOf(t))throw new XS(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=AE("zeros"));const a=r.apply(e,n),l=new LE(a,n,t,i,o);return a.dispose(),null!=s&&this.addLoss(()=>s.apply(l.read())),null==i&&(i=!0),i?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=n_(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(t=>{if(null!=t)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,n,r,s,i,o=null){const a=n_(t);e=n_(e),n=n_(n),r=n_(r),s=DE(s),i=DE(i);const l=[],u=[],c=[];for(const h of a)l.push(h.sourceLayer),u.push(h.nodeIndex),c.push(h.tensorIndex);new WE({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:a,outputTensors:e,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:i},o);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}class qE extends HE{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:RE("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new XS("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(null==e){if(null==t.inputShape)throw new XS("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new XS("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const r=new VE(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new WE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new XS("Cannot pass any input to an InputLayer's apply() method. InputLayer name: "+this.name)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}async function GE(t){if(null==t)return;const e=[],n=[],r=[];for(const s in t){const i=t[s];if("number"!=typeof i){const t=i;e.push(t.data()),n.push(s),r.push(t)}}if(e.length>0){const s=await Promise.all(e);for(let e=0;e<s.length;++e)t[n[e]]=s[e][0];px(r)}}function KE(t){if(null!=t)for(const e in t){const n=t[e];"number"!=typeof n&&n.dispose()}}var XE;qE.className="InputLayer",u.registerClass(qE),function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(XE||(XE={}));class YE{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class ZE{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class JE extends YE{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){null==e&&(e={});const n=null==e.size?0:e.size;this.seen+=n;for(const r in e){const t=e[r];if("number"==typeof t)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+t*n;else{let e;r in this.totals?e=this.totals[r]:this.totals[r]=0;const s=dx(()=>wm(this.totals[r],eg(t,n)));this.totals[r]=s,null!=e&&e.dispose()}}}async onEpochEnd(t,e){if(null!=e)for(const n of this.params.metrics)null!=this.totals[n]&&("number"==typeof this.totals[n]?e[n]=this.totals[n]/this.seen:dx(()=>{const t=eg(tg(1,this.seen),this.totals[n]);e[n]=t,this.totals[n].dispose(),fx(e[n])}))}}class QE extends YE{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){null==e&&(e={}),this.epoch.push(t);for(const n in e)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){const t=[],e=[],n=[];for(const s in this.history){const r=this.history[s];for(let i=0;i<r.length;++i)"number"!=typeof r[i]&&(t.push(r[i].data()),e.push(s),n.push(i))}const r=await Promise.all(t);for(let s=0;s<r.length;++s)this.history[e[s]][n[s]].dispose(),this.history[e[s]][n[s]]=r[s][0]}}class tk extends YE{constructor(t,e){if(super(),this.currentEpoch=0,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");r.isNumber(this.yieldEvery)&&(this.maybeWait=function(t,e){let n,s=r.now();return(...i)=>{const o=r.now();return o-s<e||(s=o,n=t(...i)),n}}(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){const r=[];null!=this.yield&&(await GE(n),r.push(this.yield(t,e,n))),r.push(fS()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,null!=this.epochBegin&&(await GE(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const n=[];null!=this.epochEnd&&(await GE(e),n.push(this.epochEnd(t,e))),"epoch"===this.yieldEvery&&n.push(fS()),await Promise.all(n)}async onBatchBegin(t,e){null!=this.batchBegin&&(await GE(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const n=[];null!=this.batchEnd&&(await GE(e),n.push(this.batchEnd(t,e))),"batch"===this.yieldEvery?n.push(fS()):r.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){null!=this.trainBegin&&(await GE(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await GE(t),await this.trainEnd(t))}}function ek(t,e){return null==t&&(t={}),t instanceof YE?[t]:Array.isArray(t)&&t[0]instanceof YE?t:n_(t).map(t=>new tk(t,e))}class nk{constructor(){}static registerCallbackConstructor(t,e){r.assert(t>=0&&Number.isInteger(t),()=>"Verbosity level is expected to be an integer >= 0, but got "+t),nk.checkForDuplicate(e),null==nk.constructors[t]&&(nk.constructors[t]=[]),nk.constructors[t].push(e)}static checkForDuplicate(t){for(const e in nk.constructors)nk.constructors[+e].forEach(e=>{if(e===t)throw new XS("Duplicate callback constructor.")})}static clear(){nk.constructors={}}static createCallbacks(t){const e=[];for(const n in nk.constructors){const r=+n;t>=r&&e.push(...nk.constructors[r])}return e.map(t=>new t)}}function rk(t,e,n,r,s,i,o,a,l){const u=new QE,c=[new JE,...nk.createCallbacks(e)];null!=t&&c.push(...t),c.push(u);const h=new ZE(c);return h.setParams({epochs:n,initialEpoch:r,samples:s,steps:i,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:u}}function sk(t,e={},n=!1){return a_(t,u.SerializationMap.getMap().classNameMap,e,"layer",n)}function ik(t,e){return dx(()=>{"float32"!==t.dtype&&(t=t.asType("float32"));const n=xg(eE(t),e,!0),r=Wx(n.shape,qS()),s=Qg(jx(n,r));return tg(t,s)})}function ok(t,e){return dx(()=>yg(eE(jy(e,t)),-1))}function ak(t,e){return dx(()=>yg(Sg(jy(e,t)),-1))}function lk(t,e){return dx(()=>{const n=jy(t,e),r=Rg(Sg(t),qS(),Number.MAX_VALUE),s=Sg(tg(n,r));return eg(100,yg(s,-1))})}function uk(t,e,n=!1){return dx(()=>{if(n)e=Jw(e);else{const t=xg(e,e.shape.length-1,!0);e=tg(e,t)}return e=Rg(e,qS(),1-qS()),Vg(xg(eg(t.toFloat(),Pg(e)),e.shape.length-1))})}function ck(t,e,n=!1){return dx(()=>{const r=Lg(function(t){const e=[z_(t.shape)];return t.reshape(e)}(t)).toInt(),s=(e=Rg(e,qS(),1-qS())).shape;return uk(Jv(r,s[s.length-1]).reshape(s),e,n)})}function hk(t,e){return dx(()=>{let n;return n=Rg(e,qS(),1-qS()),n=Pg(tg(n,jy(1,n))),yg(function(t,e){if(!r.arraysEqual(t.shape,e.shape))throw new XS(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return dx(()=>{const n=e.relu(),r=e.abs().neg();return n.sub(e.mul(t)).add(r.exp().log1p())})}(t,n),-1)})}function dk(t,e){return dx(()=>{const n=ik(t,-1),r=ik(e,-1),s=eg(n,r);return Vg(xg(s,-1))})}nk.constructors={};const pk={meanSquaredError:ok,meanAbsoluteError:ak,meanAbsolutePercentageError:lk,meanSquaredLogarithmicError:function(t,e){return dx(()=>{const n=Rg(e,qS(),Number.MAX_VALUE),r=Pg(wm(1,n)),s=Rg(t,qS(),Number.MAX_VALUE),i=Pg(wm(1,s));return yg(eE(jy(r,i)),-1)})},squaredHinge:function(t,e){return dx(()=>{const n=jx(0,jy(1,eg(t,e)));return yg(eE(n),-1)})},hinge:function(t,e){return dx(()=>{const n=jx(0,jy(1,eg(t,e)));return yg(n,-1)})},categoricalHinge:function(t,e){return dx(()=>{const n=xg(eg(t,e),-1),r=Gx(eg(jy(1,t),e),-1);return jx(0,wm(1,jy(r,n)))})},logcosh:function(t,e){return dx(()=>{const n=Math.log(2),r=jy(e,t),s=jy(wm(r,Jg(eg(-2,r))),n);return yg(s,-1)})},categoricalCrossentropy:uk,sparseCategoricalCrossentropy:ck,binaryCrossentropy:hk,kullbackLeiblerDivergence:function(t,e){return dx(()=>{const n=Rg(t,qS(),1),r=Rg(e,qS(),1);return xg(eg(t,Pg(tg(n,r))),-1)})},poisson:function(t,e){return dx(()=>{const n=Pg(wm(qS(),e));return yg(jy(e,eg(t,n)),-1)})},cosineProximity:dk};function fk(t){if("string"==typeof t){if(t in pk)return pk[t];let e="Unknown loss "+t;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new XS(e)}return t}function mk(t,e){return dx(()=>{const n=eg(.5,Vm(e)),r=j_(sb(e,n),t.dtype);return yg(Vx(t,r),-1)})}function gk(t,e){return dx(()=>j_(Vx(fg(t,-1),fg(e,-1)),"float32"))}function yk(t,e){return hk(t,e)}function bk(t,e){return t.rank===e.rank&&(t=t.squeeze([t.rank-1])),(e=e.argMax(-1)).dtype!==t.dtype&&(e=e.asType(t.dtype)),Vx(t,e).asType("float32")}const vk=uk,xk=ck,wk={binaryAccuracy:mk,categoricalAccuracy:gk,precision:function(t,e){return dx(()=>{const n=function(t,e){return dx(()=>db(t.equal(1),e.equal(1)).sum().cast("float32"))}(t,e),r=function(t,e){return dx(()=>db(t.equal(0),e.equal(1)).sum().cast("float32"))}(t,e),s=n.add(r);return gb(sb(s,0),n.div(s),0).cast("float32")})},categoricalCrossentropy:vk,sparseCategoricalCrossentropy:xk,mse:ok,MSE:ok,mae:ak,MAE:ak,mape:lk,MAPE:lk,cosine:dk};function Ck(t){if("string"==typeof t&&t in wk)return wk[t];if("string"!=typeof t&&null!=t)return t;throw new XS("Unknown metric "+t)}function Sk(t){if(QS(null!==t,"Unknown LossOrMetricFn "+t),"string"==typeof t)return t;{let e;for(const n of Object.keys(pk))if(pk[n]===t){e=n;break}if(void 0!==e)return e;for(const n of Object.keys(wk))if(wk[n]===t){e=n;break}return void 0!==e?e:t.name}}function _k(t,e,n=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!function t(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const n=Object.keys(e);for(const r of n){if("string"!=typeof r)return!1;if(!t(e[r]))return!1}return!0}if(Array.isArray(e)){for(const n of e)if(!t(n))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(t);n.length>1048576&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function Ek(t,e,n=console.log){let r="";for(let s=0;s<t.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=t[s],r=r.slice(0,e[s]),r+=" ".repeat(e[s]-r.length);n(r)}function kk(t,e,n){let r;try{r=JSON.stringify(t.outputShape)}catch(wF){r="multiple"}Ek([`${t.name} (${t.getClassName()})`,r,t.countParams().toString()],e,n)}function Ak(t,e,n,r){let s;try{s=JSON.stringify(t.outputShape)}catch(wF){s="multiple"}const i=[];for(const u of t.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let t=0;t<u.inboundLayers.length;++t)i.push(`${u.inboundLayers[t].name}[${u.nodeIndices[t]}][${u.tensorIndices[t]}]`);const o=t.name,a=t.getClassName(),l=0===i.length?"":i[0];Ek([`${o} (${a})`,s,t.countParams().toString(),l],e,r);for(let u=1;u<i.length;++u)Ek(["","","",i[u]],e,r)}function Ik(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"==typeof n}function Nk(t,e){if(null===t)return null;if("string"==typeof t)return s_(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let s=0;s<r;++s){const r=t[s];Ik(e,s,r)?n.push(r):n.push(Nk(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n];if("name"===n&&"string"==typeof r)e[n]=r;else{const t=s_(n);e[t]=Nk(r,t)}}return e}}class Tk{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Tk)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(null!=this.id2Value[t.id])throw new XS(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return qm(e,t.dtype)}catch(wF){throw new XS(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=n&&(this.id2Mask[t.id]=n),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof VE){if(null==this.id2Value[t.id])throw new XS("Nonexistent key: "+t.name);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new XS("Feed dict has no SymbolicTensor name: "+t);return this.id2Value[e]}}getMask(t){if(t instanceof VE){if(null==this.id2Value[t.id])throw new XS("Nonexistent key: "+t.name);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new XS("Feed dict has no SymbolicTensor name: "+t);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&px(this.id2Mask)}}const Rk={},$k={};function Dk(t,e,n,s){const i=null!=n&&n.training,o=Array.isArray(t),a=o?t:[t],l=a.map(t=>t.name),u=[],c=e.names();for(const r of l)-1!==c.indexOf(r)?u.push(e.getValue(r)):u.push(null);null!=s&&(s.maxNumTensors=-1/0,s.minNumTensors=1/0);const h=l.join(",")+"|"+e.names().join(",");let d,p;if(null==Rk[h]){const t=function(t,e){r.assert(null!=t&&t.length>0,()=>"Expected at least one fetch, got none");let n=[],s={};if(1===t.length){const r=Fk(t[0],e);n=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of t){const{sorted:t,recipientMap:o}=Fk(i,e);for(const e of t)r.has(e.name)||(n.push(e),r.add(e.name));for(const e in o)null==s[e]&&(s[e]=new Set),o[e].forEach(t=>s[e].add(t))}}return{sorted:n,recipientCounts:Ok(s)}}(a,e);d=t.sorted,p=t.recipientCounts,Rk[h]=d,$k[h]=p}d=Rk[h],p={},i||Object.assign(p,$k[h]);const f=new Tk(e);for(let r=0;r<d.length;++r){if(null!=s){const t=hx().numTensors;t>s.maxNumTensors&&(s.maxNumTensors=t),t<s.minNumTensors&&(s.minNumTensors=t)}const t=d[r],o=t.sourceLayer;if(o instanceof qE)continue;const a=[],c=[],h=[];let m=!1;for(const n of t.inputs){const t=f.getValue(n),r=f.getMask(n);a.push(t),c.push(r),null!=r&&(m=!0),i||(p[n.name]--,0!==p[n.name]||e.hasKey(n)||-1!==l.indexOf(n.name)||t.isDisposed||!0===n.sourceLayer.stateful||h.push(t))}m&&((n=n||{}).mask=c[0]);const g=n_(o.apply(a,n));let y=null;o.supportsMasking&&(y=o.computeMask(a,c));const b=Mk(t),v=Array.isArray(b)?b:[b];for(let e=0;e<v.length;++e){f.hasKey(v[e])||f.add(v[e],g[e],Array.isArray(y)?y[0]:y);const t=l.indexOf(v[e].name);-1!==t&&(u[t]=g[e])}i||px(h)}return f.disposeMasks(),o?u:u[0]}function Ok(t){const e={};for(const n in t)e[n]=t[n].size;return e}function Fk(t,e){const n=new Set,r=[],s={};for(const a of e.names())n.add(a);const i=[],o=[];for(i.push(t);i.length>0;){const t=i[i.length-1];if(n.has(t.name)){i.pop();continue}const e=o[o.length-1]===i.length-1;if(0===t.inputs.length||e)i.pop(),r.push(t),n.add(t.name),e&&o.pop();else{o.push(i.length-1);for(const e of t.inputs)null==s[e.name]&&(s[e.name]=new Set),s[e.name].add(t.name),n.has(e.name)||i.push(e)}}return{sorted:r,recipientMap:s}}function Mk(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let n=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const r of t.sourceLayer.inboundNodes[e].outputTensors)if(r.id===t.id){n=e;break}e=t.sourceLayer.getOutputAt(n)}return e}class Lk extends HE{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=RE(t)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],u_(this.inputs).length!==this.inputs.length)throw new XS("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+this.inputs.map(t=>t.name));u_(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+this.outputs.map(t=>t.name)),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const t=y.nodeIndex,e=y.tensorIndex;this.outputLayers.push(y.sourceLayer),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(e)}for(const y of this.inputs){const t=y.sourceLayer,e=y.nodeIndex,n=y.tensorIndex;QS(0===e,"input layer has >1 nodes"),QS(0===n,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(e),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const e=this.inputLayers[y];if(!(e instanceof qE))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${y} (0-based) originates from layer type ${e.getClassName()}.`);this.inputNames.push(e.name),this.feedInputShapes.push(e.batchInputShape),this.feedInputNames.push(e.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(t=>t.shape),this.internalOutputShapes=this.outputs.map(t=>t.shape);const e={},n={},r={},s={},i={},o=[],a=(t,e,n,r,s,l)=>{null!=r&&null!=s&&null!=l||(r=t.sourceLayer,s=t.nodeIndex,l=t.tensorIndex);const u=r.inboundNodes[s];if(-1!==n.indexOf(u))throw new KS(`The tensor ${t.name} at layer "${r.name}" is part of a cycle.`);if(-1!==e.indexOf(u))return;this.containerNodes.add(Lk.nodeKey(r,s)),r.id in i||(i[r.id]=Object.keys(i).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let i=0;i<c;i++)a(u.inputTensors[i],e,n,u.inboundLayers[i],u.nodeIndices[i],u.tensorIndices[i]);for(e.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);o.push(u)},l=[],u=[];for(const y of this.outputs)a(y,l,u);const c=o.slice().reverse();for(const y of c){n[y.id]=y,y.id in e||(e[y.id]=0);let t=e[y.id];t=Math.max(t,null==r[y.outboundLayer.id]?0:r[y.outboundLayer.id]),r[y.outboundLayer.id]=t,s[y.outboundLayer.id]=y.outboundLayer,e[y.id]=t;for(let r=0;r<y.inboundLayers.length;r++){const s=y.inboundLayers[r].inboundNodes[y.nodeIndices[r]];e[s.id]=Math.max(t+1,null==e[s.id]?0:e[s.id]),n[s.id]=s}}const h={};for(const y in e){const t=e[y];t in h||(h[t]=[]),h[t].push(n[y])}const d={};for(const y in r){const t=r[y];t in d||(d[t]=[]),d[t].push(s[y])}let p=Object.keys(d).map(t=>parseInt(t,10)).sort(l_);this.layers=[];for(const y of p){const t=d[y];t.sort((t,e)=>{const n=i[t.id],r=i[e.id];return n<r?-1:n>r?1:0});for(const e of t)e instanceof Lk&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=d,p=Object.keys(h).map(t=>parseInt(t,10)).sort(l_);const f=this.inputs.slice(),m=[];for(const y of p)for(const t of h[y]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new KS("Graph disconnected: cannot obtain value for tensor "+n+` at layer "${e.name}". The following previous layers were accessed without issue: `+m);for(const e of t.outputTensors)f.push(e);m.push(e.name)}}this.nodesByDepth=h;const g=this.layers.map(t=>t.name);for(const y of g){const t=g.filter(t=>t===y).length;if(1!==t)throw new KS(`The name "${y}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new WE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(t=>null),outputMasks:this.outputs.map(t=>null),inputShapes:this.inputs.map(t=>t.shape),outputShapes:this.outputs.map(t=>t.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(e=>e.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new XS("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const n={};let r=0;for(const i of this.layers)for(const t of i.weights){if(null!=n[t.originalName])throw new XS("Duplicate weight name: "+t.originalName);n[t.originalName]=t,r++}const s=[];for(const i in t){let r=i;if(null==n[i]){const t=i.split("/");r=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[r])s.push([n[r],t[i]]);else if(e)throw new XS("Provided weight data has no target variable: "+i);delete n[r]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new XS(`${t.length} of ${r} weights are not set: `+t)}zE(s)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 2.0.1",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const n=function t(e,n){if(null==e)return null;if("string"==typeof e)return r_(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const r=[],s=e.length;for(let i=0;i<s;++i){const s=e[i];Ik(n,i,s)?r.push(s):r.push(t(s,n))}return r}{const n={};for(const r of Object.keys(e)){const s=e[r];n[r_(r)]="name"!==r&&"className"!==r||"string"!=typeof s?t(s,r):s}return n}}(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return dx(()=>{t=n_(t);const n=new Tk;for(let e=0;e<this.inputs.length;++e)n.add(this.inputs[e],t[e]);return Dk(this.outputs,n,e)})}computeMask(t,e){return dx(()=>{let n;return t=n_(t),n=null==e?JS(null,t.length):n_(e),this.runInternalGraph(t,n)[1]})}computeOutputShape(t){const e=DE(t);if(e.length!==this.inputLayers.length)throw new XS(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let o=0;o<e.length;o++)n[this.inputLayers[o].name+"_0_0"]=e[o];const r=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort(l_);if(r.length>1)for(const o of r){const t=this.nodesByDepth[o];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map(t=>t.id).indexOf(t.id))continue;const r=[];for(let o=0;o<e.inboundLayers.length;o++)r.push(n[`${e.inboundLayers[o].name}_${e.nodeIndices[o]}_${e.tensorIndices[o]}`]);const s=DE(t.computeOutputShape(e_(r))),i=t.inboundNodes.indexOf(e);for(let e=0;e<s.length;e++)n[`${t.name}_${i}_${e}`]=s[e]}}const s=[],i=[];for(let o=0;o<this.outputLayers.length;o++)i.push(`${this.outputLayers[o].name}_${this.outputLayersNodeIndices[o]}_${this.outputLayersTensorIndices[o]}`);for(let o=0;o<i.length;o++){const t=i[o];QS(t in n),s.push(n[t])}return e_(s)}runInternalGraph(t,e){null==e&&(e=JS(null,t.length));const n={};for(let a=0;a<this.inputs.length;++a)n[this.inputs[a].id]=[t[a],e[a]];const r=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort(l_);for(const a of r){const t=this.nodesByDepth[a];for(const e of t){const t=e.outboundLayer,r=e.inputTensors,s=e.outputTensors,i=new Array;for(const e of r)e.id in n&&i.push(n[e.id]);if(i.length===r.length){let r,o,a,l,u={};if(null!=e.callArgs&&(u=e.callArgs),1===i.length){const[e,n]=i[0];null==u.mask&&(u.mask=n),a=n_(t.call(e,u)),l=n_(t.computeMask(e,n)),r=[e],o=[n]}else r=i.map(t=>t[0]),o=i.map(t=>t[1]),null==u.mask&&(u.mask=o),a=n_(t.call(r,u)),l=n_(t.computeMask(r,o));if(t.activityRegularizer)throw new YS("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<s.length;++t)n[s[t].id]=[a[t],l[t]]}}}const s=[],i=[],o=[];for(const a of this.outputs){QS(a.id in n,`Could not compute output ${a.name} : ${a.id}`);const[t,e]=n[a.id];o.push(t.shape),s.push(t),i.push(e)}return[s,i,o]}buildNodeConversionMap(t){const e={};let n;for(const r of this.layers){n=r instanceof Lk?1:0;for(let t=0;t<r.inboundNodes.length;t++){const s=Lk.nodeKey(r,t);this.containerNodes.has(s)&&(e[s]=n,n+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new XS(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new XS("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===t)return n;throw new XS("No such layer: "+t)}calculateLosses(){return dx(()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const r=Lk.nodeKey(e,n);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const i of this.layers){const t=i.getClassName(),r=i.getConfig(),s=[];for(let n=0;n<i.inboundNodes.length;n++){const t=i.inboundNodes[n],r=Lk.nodeKey(i,n);let o={};if(this.containerNodes.has(r)){if(t.callArgs)try{JSON.stringify(t.callArgs),o=t.callArgs}catch(wF){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: `+t.callArgs+". They will not be included in the serialized model (and thus will be missing at deserialization time)."),o={}}if(t.inboundLayers.length>0){const n=[];for(let r=0;r<t.inboundLayers.length;r++){const s=t.inboundLayers[r],i=t.tensorIndices[r];let a=e[Lk.nodeKey(s,t.nodeIndices[r])];null==a&&(a=0),n.push([s.name,a,i,o])}s.push(n)}}}const o={};o.name=i.name,o.className=t,o.config=r,o.inboundNodes=s,n.push(o)}t.layers=n;const r=[];for(let i=0;i<this.inputLayers.length;i++){const t=this.inputLayers[i],n=Lk.nodeKey(t,this.inputLayersNodeIndices[i]);if(!this.containerNodes.has(n))continue;let s=e[n];null==s&&(s=0),r.push([t.name,s,this.inputLayersTensorIndices[i]])}t.inputLayers=r;const s=[];for(let i=0;i<this.outputLayers.length;i++){const t=this.outputLayers[i],n=Lk.nodeKey(t,this.outputLayersNodeIndices[i]);if(!this.containerNodes.has(n))continue;let r=e[n];null==r&&(r=0),s.push([t.name,r,this.outputLayersTensorIndices[i]])}return t.outputLayers=s,t}static fromConfig(t,e,n={},r=!1){const s={},i={};function o(t,e){t.name in i?i[t.name].push(e):i[t.name]=[e]}function a(t,e){const n=[];let r;for(const i of e){const a=i[0],l=i[1],u=i[2];if(r=null==i[3]?{}:i[3],!(a in s))return void o(t,e);const c=s[a];if(c.inboundNodes.length<=l)return void o(t,e);n.push(c.inboundNodes[l].outputTensors[u])}n.length>0&&t.apply(e_(n),r)}function l(t){const n=t.name,i=sk(t,null!=e.customObjects?e.customObjects:{});i.setFastWeightInitDuringBuild(r),s[n]=i,t.inboundNodes.forEach(t=>{if(!(t instanceof Array))throw new XS("Corrupted configuration, expected array for nodeData: "+t);o(i,t)})}const u=e.name,c=e.layers;for(const m of c)l(m);for(;!c_(i);)for(const t of c){const e=s[t.name];if(e.name in i){const t=i[e.name];delete i[e.name];for(const n of t)a(e,n)}}const h=[],d=[],p=e.inputLayers;for(const m of p){const t=m[0],e=m[1],n=m[2];QS(t in s),h.push(s[t].inboundNodes[e].outputTensors[n])}const f=e.outputLayers;for(const m of f){const t=m[0],e=m[1],n=m[2];QS(t in s),d.push(s[t].inboundNodes[e].outputTensors[n])}return new t({inputs:h,outputs:d,name:u})}get stateful(){if(this._stateful)throw new XS("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){dx(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function Pk(t,e){return function(t,e,n){const r=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map(t=>null);if(1===r)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error(`Provided classWeight is an array of ${t.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){const n=[];return e.forEach(e=>{n.push(e in t?t[e]:null)}),n}throw new Error(`The model has multiple (${r}) outputs, so classWeight must be either an array with ${r} elements or an object with ${e} keys. Provided classWeight not understood: ${JSON.stringify(t)}`)}(t,e)}async function zk(t,e,n,r){if(null!=e||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const e=dx(()=>{if(1===t.shape.length)return t.clone();if(2===t.shape.length){if(t.shape[1]>1)return t.argMax(1);if(1===t.shape[1])return t.reshape([t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),r=Array.from(await e.data());px(e);const s=[];return r.forEach(t=>{if(null==n[t])throw new Error(`classWeight must contain all classes in the training data. The class ${t} exists in the data but not in classWeight`);s.push(n[t])}),Tm(s,"float32")}return null}function Bk(t,e){return eg(t,e)}function Vk(t,e){let n,s;n=e.xs,s=e.ys,r.assert(null!=n&&null!=s,()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+e);const i=Uk("input",t.inputNames,n),o=Uk("output",t.outputNames,s),a=i[0].shape[0];r.assert(i.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: `+JSON.stringify(t.inputNames)+")"),r.assert(o.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: `+JSON.stringify(t.outputNames)+")");for(let l=0;l<i.length;l++)r.assert(i[l].shape[0]===a,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);for(let l=0;l<o.length;l++)r.assert(o[l].shape[0]===a,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);return{xs:i,ys:o}}function Uk(t,e,n){if(n instanceof qf)return[n];if(Array.isArray(n))return r.assert(n.length===e.length,()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`),n;{const r=[];for(const s of e){if(null==n[s])throw new XS(`The feature data generated by the dataset lacks the required ${t} key '${s}'.`);r.push(n[s])}return r}}function Wk(t){return"function"==typeof t.iterator}function jk(t){r.assert(t>0&&Number.isInteger(t),()=>"batchSize is required to be a positive integer, but got "+t)}function Hk(t,e,n){return null==t?[null]:Array.isArray(t)?t.map(t=>q_(t,e,n-e)):q_(t,e,n-e)}function qk(t,e){return dx(()=>null==t?null:Array.isArray(t)?t.map(t=>qk(t,e)):tE(t,"int32"===e.dtype?e:e.toInt()))}function Gk(t,e){const n=[];let r=0,s=null;for(;r<t;)s=r+e,s>=t&&(s=t),n.push([r,s]),r=s;return n}function Kk(t){const e=[];t instanceof qf&&(t=[t]);for(let n=0;n<t.length;++n){const r=t[n];if(1===r.rank)e.push(H_(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function Xk(t,e){if(null==t)return;const n=[];if(e instanceof qf)n.push(e.id);else if(Array.isArray(e))e.forEach(t=>n.push(t.id));else if(null!=e)for(const s in e)n.push(e[s].id);const r=[];if(t instanceof qf)-1===n.indexOf(t.id)&&r.push(t);else if(Array.isArray(t))t.forEach(t=>{-1===n.indexOf(t.id)&&r.push(t)});else if(null!=t)for(const s in t){const e=t[s];-1===n.indexOf(e.id)&&r.push(e)}r.forEach(t=>{t.isDisposed||t.dispose()})}function Yk(t){return Array.isArray(t)}function Zk(t){return!function(t){return t instanceof qf}(t)&&!Yk(t)}function Jk(t,e,n,r=!0,s=""){if(null==e||0===e.length){if(null!=t){let e=!1;if(Yk(t)&&t.length>0)e=!0;else if(Zk(t)){for(const n in t)if(t.hasOwnProperty(n)){e=!0;break}}else e=!0;if(e)throw new XS(`Error when checking model ${s} expected no data, but got `+t)}return[]}if(null==t)return e.map(t=>null);let i;if(Zk(t)){t=t,i=[];for(const n of e){if(null==t[n])throw new XS(`No data provided for "${n}". Need data for each key in: `+e);i.push(t[n])}}else if(Yk(t)){if((t=t).length!==e.length)throw new XS(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): `+t);i=t}else{if(t=t,e.length>1)throw new XS(`The model ${s} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape `+t.shape);i=[t]}if(i=Kk(i),null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=i[o];if(t.shape.length!==n[o].length)throw new XS(`Error when checking ${s}: expected ${e[o]} to have ${n[o].length} dimension(s). but got array with shape `+t.shape);for(let i=0;i<n[o].length;++i){if(0===i&&!r)continue;const a=t.shape[i],l=n[o][i];if(null!=l&&l>=0&&a!==l)throw new XS(`Error when checking ${s}: expected ${e[o]} to have shape [${n[o]}], but got array with shape [${t.shape}].`)}}return i}function Qk(t,e,n,r=!0,s=""){let i;if(Array.isArray(t)){if(t.length!==e.length)throw new XS(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);i=t}else{if(e.length>1)throw new XS(`The model expects ${e.length} ${s} Tensors, but only received one Tensor. Found: array with shape `+JSON.stringify(t.shape)+".");i=[t]}if(null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=i[o];if(t.shape.length!==n[o].length)throw new XS(`Error when checking ${s}: expected ${e[o]} to have ${n[o].length} dimension(s), but got array with shape `+JSON.stringify(t.shape));for(let i=0;i<n[o].length;++i){if(0===i&&!r)continue;const a=t.shape[i],l=n[o][i];if(null!=l&&l!==a)throw new XS(`Error when checking ${s}: expected ${e[o]} to have shape ${JSON.stringify(n[o])} but got array with shape ${JSON.stringify(t.shape)}.`)}}}class tA extends Lk{constructor(t){super(t),this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new XS("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(t,e,n,r=console.log){const s=function(t){let e=!0;const n=[],r=[];for(const s in t.nodesByDepth)n.push(t.nodesByDepth[s]);for(const s of n){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){e=!1;break}r.push(...s)}if(e)for(const s of t.layers){let t=!1;for(const n of s.inboundNodes)if(-1!==r.indexOf(n)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),i=["Layer (type)","Output shape","Param #"];let o;if(s?(e=e||65,n=n||[.45,.85,1]):(e=e||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(t=>Math.floor(e*t))),!s){i.push("Receives inputs"),o=[];for(const e in t.nodesByDepth)o.push(...t.nodesByDepth[e])}r("_".repeat(e)),Ek(i,n,r),r("=".repeat(e));const a=t.layers;for(let c=0;c<a.length;++c)s?kk(a[c],n,r):Ak(a[c],n,o,r),r((c===a.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=function(t){let e;return e=ME(null!=t.collectedTrainableWeights?t.collectedTrainableWeights:t.trainableWeights),e}(t),u=ME(t.nonTrainableWeights);r("Total params: "+(l+u)),r("Trainable params: "+l),r("Non-trainable params: "+u),r("_".repeat(e))}(this,t,e,n)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"==typeof t.optimizer)this.optimizer_=function(t){const e={Adagrad:()=>dS.adagrad(.01),Adadelta:()=>dS.adadelta(1,.95,qS()),Adam:()=>dS.adam(.001,.9,.999,qS()),Adamax:()=>dS.adamax(.002,.9,.999,qS(),0),RMSProp:()=>dS.rmsprop(.001,.9,0,qS()),SGD:()=>dS.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new XS("Unknown Optimizer "+t)}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof rS))throw new XS("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(Array.isArray(t.loss)||"string"==typeof t.loss||"function"==typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new XS(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(t=>fk(t))}else{const n=fk(t.loss);this.outputs.forEach(t=>{e.push(n)})}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new XS(`Unknown entry in loss dictionary: "${e}". Only expected the following keys: `+this.outputNames);for(const n of this.outputNames)null==t.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),e.push(fk(t.loss[n]))}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const t=this.internalOutputShapes[i];this.feedOutputNames.push(this.outputNames[i]),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[i])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],O_("loss",()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;const e=this.lossFunctions[t];this.outputs.length>1&&(this.metricsTensors.push([e,t]),this.metricsNames.push(this.outputNames[t]+"_loss"))}});const r=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map(t=>[]);let n;if("string"==typeof t||"function"==typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError("Type of metrics argument not understood. Expected an string,function, Array, or Object, found: "+t);n=t}if(Array.isArray(n))return e.map(t=>n);{const t=[];for(const r of e){let e=n.hasOwnProperty(r)?n[r]:[];Array.isArray(e)||(e=[e]),t.push(e)}return t}}(t.metrics,this.outputNames),s=(t,e,n)=>{this.outputNames.length>1&&(e=this.outputNames[t]+"_"+e),this.metricsNames.push(e),this.metricsTensors.push([n,t])};O_("metric",()=>{for(let t=0;t<this.outputs.length;++t)-1===n.indexOf(t)&&(e=>{let n,r,i;for(const o of e){if("string"==typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const e=this.internalOutputShapes[t];let s;1===e[e.length-1]||this.lossFunctions[t]===hk?-1!==["accuracy","acc"].indexOf(o)?r=mk:-1!==["crossentropy","ce"].indexOf(o)&&(r=yk):this.lossFunctions[t]===ck?-1!==["accuracy","acc"].indexOf(o)?r=bk:-1!==["crossentropy","ce"].indexOf(o)&&(r=xk):-1!==["accuracy","acc"].indexOf(o)?r=gk:-1!==["crossentropy","ce"].indexOf(o)&&(r=vk),-1!==["accuracy","acc"].indexOf(o)?s="acc":-1!==["crossentropy","ce"].indexOf(o)&&(s="ce"),i=r,n=""+s}else{const t=Ck(o);i=t,n=""+Sk(o)}let e;O_(n,()=>{e=i}),s(t,n,e)}})(r[t])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){const r=null==n.batchSize?32:n.batchSize;jk(r);const s=this.standardizeUserDataXY(t,e,!0,r);try{const i=s[0].concat(s[1]);return this.makeTestFunction(),e_(this.testLoop(this.testFunction,i,r,n.verbose,n.steps))}finally{Xk(s[0],t),Xk(s[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),async function(t,e,n){const s=null!=(n=n||{}).batches,i=t.testFunction;let o=[];if(n.verbose>0)throw new YS("Verbose mode is not implemented yet.");r.assert(!s||n.batches>0&&Number.isInteger(n.batches),()=>"Test loop expects `batches` to be a positive integer, but received "+JSON.stringify(n.batches));const a="function"==typeof e.next?e:await e.iterator();let l=0,u=0;for(;!s||u<n.batches;){const e=await a.next();if(o=dx(()=>{if(e.value){const{xs:n,ys:r}=Vk(t,e.value),s=n.concat(r),a=dx(()=>i(s));if(px(s),0===u)for(let t=0;t<a.length;++t)o.push(Nm(0));const c=s[0].shape[0];for(let t=0;t<a.length;++t){const e=a[t],n=o[t];o[t]=dx(()=>wm(o[t],eg(c,e))),u>0&&px(n)}px(a),l+=c,++u}return o}),e.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let r=0;r<o.length;++r){const t=o[r];o[r]=tg(o[r],l),px(t)}return e_(o)}(this,t,e)}checkNumSamples(t,e,n,r="steps"){let s;if(null!=n){if(s=null,null!=e)throw new XS(`If ${r} is set, batchSize must be null or undefined.Got batchSize = `+e)}else{if(null==t)throw new XS("Either the input data should have a defined shape, or "+r+" shoud be specified.");s=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return s}execute(t,e){if(Array.isArray(e)&&0===e.length)throw new XS("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),r=this.retrieveSymbolicTensors(n?e:[e]),s=new Tk;if(t instanceof qf&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new XS(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let e=0;e<this.inputs.length;++e)s.add(this.inputs[e],t[e])}else for(const o of this.inputs){const e=t[o.name];if(null==e)throw new XS("No value is provided for the model's input "+o.name);s.add(o,e)}const i=Dk(r,s);return n?i:i[0]}retrieveSymbolicTensors(t){const e=JS(null,t.length);let n=t.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],i=s.map(t=>t.name);for(let r=0;r<t.length;++r){const o=i.indexOf(t[r]);if(-1!==o&&(e[r]=s[o],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw e.forEach((e,r)=>{null==e&&n.push(t[r])}),new XS("Cannot find SymbolicTensors for output name(s): "+JSON.stringify(n))}return e}predictLoop(t,e=32,n=!1){return dx(()=>{const r=this.checkNumSamples(t);if(n)throw new YS("Verbose predictLoop() is not implemented yet.");const s=Gk(r,e),i=this.outputs.map(t=>[]);for(let e=0;e<s.length;++e)dx(()=>{const n=Hk(t,s[e][0],s[e][1]),r=[];if(Array.isArray(n))for(let t=0;t<n.length;++t)r.push({key:this.inputs[t],value:n[t]});else r.push({key:this.inputs[0],value:n});const i=new Tk(r);return Dk(this.outputs,i)}).forEach((t,e)=>i[e].push(t));return e_(i.map(t=>Wm(t,0)))})}predict(t,e={}){const n=Kk(t);Qk(n,this.inputNames,this.feedInputShapes,!1);try{const r=null==e.batchSize?32:e.batchSize;return jk(r),this.predictLoop(n,r)}finally{Xk(n,t)}}predictOnBatch(t){Qk(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,s){if(null==this.optimizer_)throw new KS("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let r=0;r<this.feedOutputShapes.length;++r){const t=this.feedOutputShapes[r];i.push(this.feedLossFns[r]===ck?t.slice(0,t.length-1).concat([1]):t)}if(function(t,e,n){const s=u_(t.map(t=>t.shape[0]));s.sort();const i=u_(e.map(t=>t.shape[0]));if(i.sort(),s.length>1)throw new XS("All input Tensors (x) should have the same number of samples. Got array shapes: "+JSON.stringify(t.map(t=>t.shape)));if(i.length>1)throw new XS("All target Tensors (y) should have the same number of samples. Got array shapes: "+JSON.stringify(e.map(t=>t.shape)));if(s.length>0&&i.length>0&&!r.arraysEqual(s,i))throw new XS(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${i[0]} target sample(s).`)}(t=Jk(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=Jk(e,this.feedOutputNames,i,!1,"target")),function(t,e,n){const r=[ok,hk,uk];for(let s=0;s<t.length;++s){const i=t[s],o=e[s],a=n[s];if(null!=o){if(o===uk&&1===i.shape[i.shape.length-1])throw new XS(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(o)){const t=i.shape.slice(1),e=a.slice(1);for(let n=0;n<t.length;++n){const r=t[n],s=e[n];if(null!=s&&r!==s)throw new XS(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=s&&s>0&&t[0].shape[0]%s!=0)throw new XS(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,n,r,s=!0,i){const[o,a]=this.standardizeUserDataXY(t,e,s,i);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const t=Pk(r,this.outputNames);l=[];for(let e=0;e<t.length;++e)l.push(await zk(a[e],null,t[e]))}return[o,a,l]}testLoop(t,e,n,r=0,s){return dx(()=>{const i=this.checkNumSamples(e,n,s,"steps"),o=[];if(r>0)throw new YS("Verbose mode is not implemented yet.");if(null!=s)throw new YS("steps mode in testLoop() is not implemented yet");{const r=Gk(i,n),s=Tm(W_(0,i));for(let n=0;n<r.length;++n){const i=r[n][0],a=r[n][1],l=q_(s,i,a-i),u=qk(e,l),c=t(u);if(0===n)for(let t=0;t<c.length;++t)o.push(Nm(0));for(let t=0;t<c.length;++t)o[t]=wm(o[t],eg(a-i,c[t]))}for(let t=0;t<o.length;++t)o[t]=tg(o[t],i)}return o})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const r=t[n];let s=r;t_(t,r)>1&&(s+="_"+t_(t.slice(0,n),r)),e.push(s)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),i=[],o=this.collectedTrainableWeights.map(t=>t.read());return[this.optimizer_.minimize(()=>{const t=[];for(let e=0;e<this.inputs.length;++e)t.push({key:this.inputs[e],value:n[e]});const o=new Tk(t),a=Dk(this.outputs,o,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let t=(0,this.lossFunctions[n])(r[n],a[n]);null!=s[n]&&(t=Bk(t,s[n]));const i=yg(t);e.push(i),l=0===n?t:wm(l,t)}for(let n=0;n<this.metricsTensors.length;++n){let t;if(this.outputs.length>1&&n<this.outputs.length)t=e[n];else{const e=this.metricsTensors[n][1];t=yg((0,this.metricsTensors[n][0])(r[e],a[e]))}fx(t),i.push(t)}return l=yg(l),this.calculateLosses().forEach(t=>{l=wm(l,t)}),l},!0,o)].concat(i)}}makeTestFunction(){this.testFunction=t=>dx(()=>{const e=[];let n;const r=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let t=0;t<this.inputs.length;++t)i.push({key:this.inputs[t],value:r[t]});const o=new Tk(i),a=Dk(this.outputs,o);for(let t=0;t<this.lossFunctions.length;++t){const r=yg((0,this.lossFunctions[t])(s[t],a[t]));n=0===t?r:wm(n,r),e.push(n)}for(let t=0;t<this.metricsTensors.length;++t){const n=this.metricsTensors[t][1],r=yg((0,this.metricsTensors[t][0])(s[n],a[n]));e.push(r)}return e})}async fit(t,e,n={}){return async function(t,e,n,s={}){if(t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let i,o,a,l,u,c,h;t.isTraining=!0;try{const d=null==s.batchSize?32:s.batchSize;jk(d);const p=!1,f=await t.standardizeUserData(e,n,s.sampleWeight,s.classWeight,p,d);i=f[0],o=f[1],h=f[2];let m,g=!1;if(null!=s.validationData&&s.validationData.length>0){if(g=!0,2!==s.validationData.length)throw 3===s.validationData.length?new YS("validationData including sample weights is not supported yet."):new XS("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+s.validationData+" is invalid.");a=s.validationData[0],l=s.validationData[1];const e=!0,n=await t.standardizeUserData(a,l,null,null,e,d);u=n[0],c=n[1],m=u.concat(c)}else if(null!=s.validationSplit&&s.validationSplit>0&&s.validationSplit<1){g=!0;const t=Math.floor(i[0].shape[0]*(1-s.validationSplit)),e=i[0].shape[0];u=Hk(i,t,e),i=Hk(i,0,t),c=Hk(o,t,e),o=Hk(o,0,t),m=u.concat(c)}else null!=s.validationSteps&&(g=!0);const y=i.concat(o).concat(h);t.checkTrainableWeightsConsistency();const b=t.makeTrainFunction(),v=t.getDedupedMetricsNames();let x,w;g?(t.makeTestFunction(),x=t.testFunction,w=v.slice().concat(v.map(t=>"val_"+t))):(x=null,m=[],w=v.slice());const C=ek(s.callbacks,s.yieldEvery);return await async function(t,e,n,s,i,o,a,l,u,c,h,d,p,f,m){null==i&&(i=32),null==o&&(o=1),null==h&&(h=!0),null==p&&(p=0);let g=!1;null!=u&&null!=c&&(g=!0);const y=t.checkNumSamples(n,i,null,"steps_per_epoch");let b;null!=y&&(b=W_(0,y)),null==a&&(a=1);const{callbackList:v,history:x}=rk(l,a,o,p,y,null,i,g,d);v.setModel(t),t.history=x,await v.onTrainBegin(),t.stopTraining_=!1;for(let w=p;w<o;++w){await v.onEpochBegin(w);const o={};{if("batch"===h)throw new YS("batch shuffling is not implemneted yet");h&&r.shuffle(b);const a=Tm(b),l=Gk(y,i);for(let r=0;r<l.length;++r){const h={};if(await v.onBatchBegin(r,h),dx(()=>{const d=l[r][0],p=l[r][1],f=q_(a,d,p-d);h.batch=r,h.size=p-d;const m=qk(n,f),y=e(m);for(let t=0;t<s.length;++t){const e=y[t];h[s[t]]=e,fx(e)}if(r===l.length-1&&g){const e=t.testLoop(u,c,i);for(let t=0;t<s.length;++t){const n=s[t],r=e[t];fx(r),o["val_"+n]=r}}}),await v.onBatchEnd(r,h),KE(h),t.stopTraining_)break}a.dispose()}if(await v.onEpochEnd(w,o),t.stopTraining_)break}return await v.onTrainEnd(),await t.history.syncData(),t.history}(t,b,y,v,d,s.epochs,s.verbose,C,x,m,s.shuffle,w,s.initialEpoch)}finally{t.isTraining=!1,Xk(i,e),Xk(o,n),Xk(u,a),Xk(c,l),null!=h&&px(h)}}(this,t,e,n)}async fitDataset(t,e){return async function(t,e,n){const s=null!=n.batchesPerEpoch;if(r.assert(null!=t.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),r.assert(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),r.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>"For fitDataset(), config.epochs is expected to be a positive integer, but got "+n.epochs),r.assert(!s||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>"For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got "+n.batchesPerEpoch),r.assert(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const i=null!=n.validationData;let o,a;if(i)if(Wk(n.validationData))r.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got "+n.validationBatches);else{const t=function(t){if(3===t.length)throw new YS("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(n.validationData);o=t.xs,a=t.ys}const l=t.makeTrainFunction(),u=t.getDedupedMetricsNames();let c;c=i?u.slice().concat(u.map(t=>"val_"+t)):u.slice();const h=ek(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:p,history:f}=rk(h,d,n.epochs,null,null,function(t,e){let n=null;return null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}(e,n),null,i,c);p.setModel(t),t.history=f,await p.onTrainBegin(),t.stopTraining_=!1;let m=null==n.initialEpoch?0:n.initialEpoch,g=await e.iterator();for(;m<n.epochs;){const r={};await p.onEpochBegin(m);let c=0,h=0;for(s||(g=await e.iterator());!s||c<n.batchesPerEpoch;){const e=await g.next();if(s&&e.done){console.warn("You provided `batchesPerEpoch` as "+n.batchesPerEpoch+", but your dataset iterator ran out of data after "+c+" batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=e.value){const{xs:r,ys:s}=Vk(t,e.value),i={};i.batch=h,i.size=r[0].shape[0],await p.onBatchBegin(h,i);const o=[];if(null!=n.classWeight){const e=Pk(n.classWeight,t.outputNames);for(let t=0;t<e.length;++t)o.push(await zk(s[t],null,e[t]))}const a=r.concat(s).concat(o),d=l(a);px(a);for(let t=0;t<u.length;++t){const e=d[t];i[u[t]]=e,fx(e)}await p.onBatchEnd(h,i),KE(i),h++,c++}if(s?c>=n.batchesPerEpoch:e.done){if(i){let e;e=Wk(n.validationData)?n_(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):n_(t.evaluate(o,a,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<t.metricsNames.length;++n)r["val_"+t.metricsNames[n]]=e[n]}break}if(t.stopTraining_)break}if(await p.onEpochEnd(m,r),m++,t.stopTraining_)break}return await p.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}(this,t,e)}async trainOnBatch(t,e){const n=await this.standardizeUserData(t,e),r=n[0],s=n[1],i=this.makeTrainFunction()(r.concat(s)),o=[];for(const a of i){const t=await a.data();o.push(t[0])}return px(i),e_(o)}getNamedWeights(t){const e=[],n=null!=t&&t.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let i=0;i<r.length;++i)n&&!r[i].trainable||e.push({name:r[i].originalName,tensor:s[i]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const e=hx().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-hx().numTensors}return t}getLossIdentifiers(){let t;if("string"==typeof this.loss)t=r_(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if("string"!=typeof t)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(t=>r_(t))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const r of e){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");t[r]=r_(n[r])}}return t}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[r_(Sk(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>r_(Sk(t)));{const t={};for(const e in this.metrics)t[e]=r_(Sk(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const e=sk(Nk(t.optimizer_config));let n,r;if("string"==typeof t.loss)n=s_(t.loss);else if(Array.isArray(t.loss))n=t.loss.map(t=>s_(t));else if(null!=t.loss){n={};for(const e in t.loss)n[e]=s_(t.loss[e])}if(Array.isArray(t.metrics))r=t.metrics.map(t=>s_(t));else if(null!=t.metrics){r={};for(const e in t.metrics)r[e]=s_(t.metrics[e])}this.compile({loss:n,metrics:r,optimizer:e})}async save(t,e){if("string"==typeof t){const e=a.getSaveHandlers(t);if(0===e.length)throw new XS(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new XS(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new XS("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await a.encodeWeights(this.getNamedWeights(e)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v2.0.1",convertedBy:null};if(null!=e&&e.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const t="optimizer",{data:e,specs:s}=await a.encodeWeights(await this.optimizer.getWeights(),t);n.specs.push(...s),n.data=a.concatenateArrayBuffers([n.data,e])}return null!=this.userDefinedMetadata&&(_k(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,t.save(r)}setUserDefinedMetadata(t){_k(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}tA.className="Model",u.registerClass(tA);class eA extends tA{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:RE("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(t=>t<0))throw new XS("Negative dimension size caused by adding layer "+t.name+" with input shape ["+t.inboundNodes[0].inputTensors[0].shape+"]")}add(t){const e=t instanceof eA||t instanceof tA;let n;if(e){if(n=t,1!==n.outputs.length)throw new XS("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new XS("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new XS("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=function(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new XS("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));let n=t.dtype;return null==n&&(n="float32"),new qE({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new XS(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new XS("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=function t(e,n,r){if((null==n||null!=r&&r>0)&&(n=e.sourceLayer,r=e.nodeIndex),0===n.inboundNodes.length)return[e];{const e=n.inboundNodes[r];if(0===e.inboundLayers.length)return e.inputTensors;{const n=[];for(let r=0;r<e.inboundLayers.length;r++){const s=t(e.inputTensors[r],e.inboundLayers[r],e.nodeIndices[r]);for(const t of s)-1===n.indexOf(t)&&n.push(t)}return n}}}(this.outputs[0])}this.inboundNodes=[],new WE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:JS(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(t=>t.shape),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if(FE(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new tA({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,n=console.log){this.built||this.build(),super.summary(t,e,n)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e,n={}){if(!this.built)throw new KS("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new KS("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,n={}){if(!this.built)throw new KS("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new KS("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,n={},s=!1){let i,o={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new XS("Legacy serialization format not supported yet.");i=e}else r.assert(null!=e.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=e.layers,delete e.layers,o=e;const a=new t(o);if(!(a instanceof eA))throw new YS("Sequential.fromConfig called on non-Sequential input: "+a);for(const r of i){const t=sk(r,void 0,s);s&&t.setFastWeightInitDuringBuild(!0),a.add(t)}return a}set stopTraining(t){if(null==this.model)throw new XS("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new XS("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}eA.className="Sequential",u.registerClass(eA);class nA extends u.Serializable{getConfig(){return{}}}class rA extends nA{apply(t,e=1){return function(t,e=1){if(1!==e)throw new YS(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return Bx(t)}(t,e)}}rA.className="elu",u.registerClass(rA);class sA extends nA{apply(t){return bw(t)}}sA.className="selu",u.registerClass(sA);class iA extends nA{apply(t){return gw(t)}}iA.className="relu",u.registerClass(iA);class oA extends nA{apply(t){return dx(()=>Zx(6,gw(t)))}}oA.className="relu6",u.registerClass(oA);class aA extends nA{apply(t){return t}}aA.className="linear",u.registerClass(aA);class lA extends nA{apply(t){return Hg(t)}}lA.className="sigmoid",u.registerClass(lA);class uA extends nA{apply(t){return function(t){return dx(()=>{const e=wm(.5,eg(.2,t));return Rg(e,0,1)})}(t)}}uA.className="hardSigmoid",u.registerClass(uA);class cA extends nA{apply(t){return Jg(t)}}cA.className="softplus",u.registerClass(cA);class hA extends nA{apply(t){return function(t){return dx(()=>tg(t,Sg(t).add(1)))}(t)}}hA.className="softsign",u.registerClass(hA);class dA extends nA{apply(t){return ny(t)}}dA.className="tanh",u.registerClass(dA);class pA extends nA{apply(t,e=-1){return Jw(t,e)}}pA.className="softmax",u.registerClass(pA);class fA extends nA{apply(t,e=-1){return Qw(t,e)}}function mA(t){return t.getClassName()}function gA(t,e={}){return a_(t,u.SerializationMap.getMap().classNameMap,e,"activation")}function yA(t){if(null==t)return gA({className:"linear",config:{}});if("string"==typeof t){const e={};return e.className=t,e.config={},gA(e)}return t instanceof nA?t:gA(t)}fA.className="logSoftmax",u.registerClass(fA);class bA extends u.Serializable{}class vA extends bA{constructor(t){super(),function(t){if(null!=t&&"object"!=typeof t)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an object, but received: "+t)}(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return dx(()=>{let e=Pm([1]);return this.hasL1&&(e=wm(e,xg(eg(this.l1,Sg(t))))),this.hasL2&&(e=wm(e,xg(eg(this.l2,eE(t))))),e.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}vA.className="L1L2",u.registerClass(vA);const xA={l1l2:"L1L2"};function wA(t){return o_(t)}function CA(t,e={}){return a_(t,u.SerializationMap.getMap().classNameMap,e,"regularizer")}function SA(t){return null==t?null:"string"==typeof t?CA({className:t in xA?xA[t]:t,config:{}}):t instanceof bA?t:CA(t)}class _A extends HE{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=OE(t);let n=gw(t);return null!=this.maxValue&&(n=Rg(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}_A.className="ReLU",u.registerClass(_A);class EA extends HE{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=OE(t);return Hx(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}EA.className="LeakyReLU",u.registerClass(EA);class kA extends HE{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=AE(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=SA(t.alphaRegularizer),this.alphaConstraint=__(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new XS("Expected sharedAxes to be a number or an array of numbers, but got "+t.sharedAxes);this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=FE(t)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)e[r-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<t.length;++r)n[r]=t[r];this.inputSpec=[new BE({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=OE(t),aw(t,this.alpha.read())}getConfig(){const t={alphaInitializer:kE(this.alphaInitializer),alphaRegularizer:wA(this.alphaRegularizer),alphaConstraint:C_(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}kA.className="PReLU",u.registerClass(kA);class AA extends HE{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new YS(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=OE(t);return Bx(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}AA.className="ELU",u.registerClass(AA);class IA extends HE{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const n=OE(t);return n.mul(j_(n.greater(this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}IA.className="ThresholdedReLU",u.registerClass(IA);class NA extends HE{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new pA).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){const n=OE(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function TA(t,e,n){if("number"==typeof t)return JS(t,e);if(t.length!==e)throw new XS(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let s=0;s<e;++s){const i=t[s];if((r=i)!==parseInt(r.toString(),10))throw new XS(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number `+i)}return t;var r}function RA(t,e,n,r,s=1){if(null==t)return t;let i;return i="same"===n?t:t-(e+(e-1)*(s-1))+1,Math.floor((i+r-1)/r)}function $A(t,e,n,r){if(null==t)return null;if("valid"===r)t=t*e+U_([n-e,0]);else{if("same"!==r)throw new XS(`Unsupport padding mode: ${r}.`);t*=e}return t}function DA(t,e){return dx(()=>(T_(e),"channelsFirst"===e?Fy(t,[0,2,3,1]):t))}function OA(t,e){return dx(()=>(T_(e),"channelsFirst"===e?Fy(t,[0,2,3,4,1]):t))}function FA(t,e,n,r=[1,1],s="valid",i,o,a=null){return dx(()=>{if(null==i&&(i="channelsLast"),T_(i),3!==t.rank&&4!==t.rank)throw new XS(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==e.rank&&4!==e.rank)throw new XS(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=DA(t,i);if("causal"===s)throw new YS("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=g.conv2d({x:l,filter:e,strides:r,pad:"same"===s?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:a}),"channelsFirst"===i&&(l=Fy(l,[0,3,1,2])),l})}NA.className="Softmax",u.registerClass(NA);class MA extends HE{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",MA.verifyArgs(e),this.rank=t,p_(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new YS(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=TA(e.kernelSize,t,"kernelSize"),this.strides=TA(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,R_(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,T_(this.dataFormat),this.activation=yA(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=AE(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=__(e.biasConstraint),this.biasRegularizer=SA(e.biasRegularizer),this.activityRegularizer=SA(e.activityRegularizer),this.dilationRate=TA(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new XS("dilationRate must be a number or an array of a single number for 1D convolution, but received "+JSON.stringify(this.dilationRate));if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new XS("dilationRate must be a number or array of two numbers for 2D convolution, but received "+JSON.stringify(this.dilationRate))}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new XS("dilationRate must be a number or array of three numbers for 3D convolution, but received "+JSON.stringify(this.dilationRate))}static verifyArgs(t){if(QS("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!d_(t.kernelSize,"number",1,3))throw new XS(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:mA(this.activation),useBias:this.useBias,biasInitializer:kE(this.biasInitializer),biasRegularizer:wA(this.biasRegularizer),activityRegularizer:wA(this.activityRegularizer),biasConstraint:C_(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class LA extends MA{constructor(t,e){super(t,e),this.kernel=null,LA.verifyArgs(e),this.filters=e.filters,p_(this.filters,"filters"),this.kernelInitializer=AE(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=__(e.kernelConstraint),this.kernelRegularizer=SA(e.kernelRegularizer)}build(t){t=FE(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new XS("The channel dimension of the input should be defined. Found "+t[e]);const n=t[e],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return dx(()=>{let e;t=OE(t);const n=null==this.bias?null:this.bias.read(),r=f_(this.activation.getClassName());if(null!=r&&2===this.rank)e=FA(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)e=function(t,e,n,r=1,s="valid",i,o=1){return dx(()=>{if(null==i&&(i="channelsLast"),T_(i),3!==t.shape.length)throw new XS("The input of a conv1dWithBias operation should be 3, but is "+t.shape.length+" instead.");if(3!==e.shape.length)throw new XS("The kernel for a conv1dWithBias operation should be 3, but is "+e.shape.length+" instead");if(null!=n&&1!==n.shape.length)throw new XS("The bias for a conv1dWithBias operation should be 1, but is "+e.shape.length+" instead");if("channelsFirst"===i&&(t=Fy(t,[0,2,1])),"causal"===s)throw new YS("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=Rx(t,e,r,"same"===s?"same":"valid","NWC",o);return null!=n&&(a=rE(a,n)),a})}(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=FA(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new YS("convolutions greater than 3D are not implemented yet.");e=function(t,e,n,r=[1,1,1],s="valid",i,o){return dx(()=>{if(null==i&&(i="channelsLast"),T_(i),4!==t.rank&&5!==t.rank)throw new XS("conv3dWithBias expects input to be of rank 4 or 5, but received "+t.rank+".");if(4!==e.rank&&5!==e.rank)throw new XS("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+t.rank+".");let a=OA(t,i);if("causal"===s)throw new YS("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=Dx(a,e,r,"same"===s?"same":"valid","NDHWC",o),null!=n&&(a=rE(a,n)),"channelsFirst"===i&&(a=Fy(a,[0,4,1,2,3])),a})}(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e})}computeOutputShape(t){t=FE(t);const e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<n.length;++s){const t=RA(n[s],this.kernelSize[s],this.padding,this.strides[s],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[s]);e.push(t)}let r=[t[0]];return"channelsLast"===this.dataFormat?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:kE(this.kernelInitializer),kernelRegularizer:wA(this.kernelRegularizer),kernelConstraint:C_(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new XS("Convolution layer expected config.filters to be a 'number' > 0 but got "+JSON.stringify(t.filters))}}class PA extends LA{constructor(t){super(2,t),PA.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!d_(t.kernelSize,"number",1,2))throw new XS(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}PA.className="Conv2D",u.registerClass(PA);class zA extends LA{constructor(t){super(3,t),zA.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new XS(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}zA.className="Conv3D",u.registerClass(zA);class BA extends PA{constructor(t){if(super(t),this.inputSpec=[new BE({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new XS("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode "+this.padding)}build(t){if(4!==(t=FE(t)).length)throw new XS("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new XS("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new BE({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return dx(()=>{let e=OE(t);if(4!==e.shape.length)throw new XS("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-"+e.shape.length);const n=e.shape;let r,s;"channelsFirst"===this.dataFormat?(r=2,s=3):(r=1,s=2);const i=n[s],o=this.kernelSize[1],a=this.strides[1],l=[n[0],$A(n[r],this.strides[0],this.kernelSize[0],this.padding),$A(i,a,o,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=Fy(e,[0,2,3,1]));let u=$x(e,this.kernel.read(),l,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(u=Fy(u,[0,3,1,2])),null!=this.bias&&(u=rE(u,this.bias.read(),this.dataFormat)),null!=this.activation&&(u=this.activation.apply(u)),u})}computeOutputShape(t){const e=(t=FE(t)).slice();let n,r,s;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3):(n=3,r=1,s=2);const i=this.kernelSize[0],o=this.kernelSize[1],a=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[r]=$A(e[r],a,i,this.padding),e[s]=$A(e[s],l,o,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}BA.className="Conv2DTranspose",u.registerClass(BA);class VA extends LA{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new XS("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new XS("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new XS(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received `+JSON.stringify(e.padding));this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=AE(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=SA(e.depthwiseRegularizer),this.depthwiseConstraint=__(e.depthwiseConstraint),this.pointwiseInitializer=AE(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=SA(e.pointwiseRegularizer),this.pointwiseConstraint=__(e.pointwiseConstraint)}build(t){if((t=FE(t)).length<this.rank+2)throw new XS(`Inputs to SeparableConv${this.rank}D should have rank `+(this.rank+2)+", but received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new XS("The channel dimension of the inputs should be defined, but found "+JSON.stringify(t[e]));const n=t[e],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters),this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,!0,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.inputSpec=[new BE({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return dx(()=>{let e;if(t=OE(t),1===this.rank)throw new YS("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=Fy(t,[0,2,3,1])),e=vw(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=rE(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=Fy(e,[0,3,1,2])),e})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=kE(this.depthwiseInitializer),t.pointwiseInitializer=kE(this.pointwiseInitializer),t.depthwiseRegularizer=wA(this.depthwiseRegularizer),t.pointwiseRegularizer=wA(this.pointwiseRegularizer),t.depthwiseConstraint=C_(this.depthwiseConstraint),t.pointwiseConstraint=C_(this.pointwiseConstraint),t}}VA.className="SeparableConv";class UA extends VA{constructor(t){super(2,t)}}UA.className="SeparableConv2D",u.registerClass(UA);class WA extends LA{constructor(t){super(1,t),WA.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!d_(t.kernelSize,"number",1,1))throw new XS(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}WA.className="Conv1D",u.registerClass(WA);class jA extends HE{constructor(t){super(t),this.cropping="number"==typeof t.cropping?[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return dx(()=>{if(t=OE(t),"channelsLast"===this.dataFormat){const e=K_(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return K_(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=K_(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return K_(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}jA.className="Cropping2D",u.registerClass(jA);class HA extends HE{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],null==t[2]?null:this.size[0]*t[2],null==t[3]?null:this.size[1]*t[3]]:[t[0],null==t[1]?null:this.size[0]*t[1],null==t[2]?null:this.size[1]*t[2],t[3]]}call(t,e){return dx(()=>{let e=OE(t);const n=e.shape;if("channelsFirst"===this.dataFormat){e=Fy(e,[0,2,3,1]);const t=e.resizeNearestNeighbor([this.size[0]*n[2],this.size[1]*n[3]]);return Fy(t,[0,3,1,2])}return e.resizeNearestNeighbor([this.size[0]*n[1],this.size[1]*n[2]])})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}HA.className="UpSampling2D",u.registerClass(HA);class qA extends MA{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=AE(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=__(t.depthwiseConstraint),this.depthwiseRegularizer=SA(t.depthwiseRegularizer)}build(t){if((t=FE(t)).length<4)throw new XS(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new XS(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const n=t[e];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return dx(()=>{let e=function(t,e,n=[1,1],r="valid",s,i){return dx(()=>{null==s&&(s="channelsLast"),T_(s);let o=DA(t,s);if(4!==t.rank)throw new XS("Input for depthwiseConv2d is required to be 4-D, but is instead "+t.rank+"-D");if(4!==e.rank)throw new XS("depthwiseKernel is required to be 4-D, but is instead "+e.rank+"-D");return o=Mx(o,e,n,"same"===r?"same":"valid","NHWC",i),"channelsFirst"===s&&(o=Fy(o,[0,3,1,2])),o})}(t=OE(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=rE(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e})}computeOutputShape(t){t=FE(t);const e="channelsFirst"===this.dataFormat?t[3]:t[2],n="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,r=RA("channelsFirst"===this.dataFormat?t[2]:t[1],this.kernelSize[0],this.padding,this.strides[0]),s=RA(e,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],n,r,s]:[t[0],r,s,n]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=kE(this.depthwiseInitializer),t.depthwiseRegularizer=wA(this.depthwiseRegularizer),t.depthwiseConstraint=C_(this.depthwiseRegularizer),t}}qA.className="DepthwiseConv2D",u.registerClass(qA);class GA extends HE{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?e[r]:this.noiseShape[r]);return n}call(t,e){return dx(()=>{this.invokeCallHook(t,e);const n=OE(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,r=this.getNoiseShape(n);return iE(()=>sE(n,this.rate,r,this.seed),()=>n,t)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}GA.className="Dropout",u.registerClass(GA);class KA extends GA{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}KA.className="SpatialDropout1D",u.registerClass(KA);class XA extends HE{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,p_(this.units,"units"),this.activation=yA(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=AE(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=AE(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=__(t.kernelConstraint),this.biasConstraint=__(t.biasConstraint),this.kernelRegularizer=SA(t.kernelRegularizer),this.biasRegularizer=SA(t.biasRegularizer),this.activityRegularizer=SA(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=FE(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=FE(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return dx(()=>{this.invokeCallHook(t,e);const n=OE(t),r=f_(this.activation.getClassName());let s;return null!=r?s=Q_(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=Q_(n,this.kernel.read()),null!=this.bias&&(s=rE(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s})}getConfig(){const t={units:this.units,activation:mA(this.activation),useBias:this.useBias,kernelInitializer:kE(this.kernelInitializer),biasInitializer:kE(this.biasInitializer),kernelRegularizer:wA(this.kernelRegularizer),biasRegularizer:wA(this.biasRegularizer),activityRegularizer:wA(this.activityRegularizer),kernelConstraint:C_(this.kernelConstraint),biasConstraint:C_(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}XA.className="Dense",u.registerClass(XA);class YA extends HE{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=FE(t);for(const e of t.slice(1))if(null==e)throw new XS(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],z_(t,1)]}call(t,e){return dx(()=>{this.invokeCallHook(t,e);let n=OE(t);if("channelsFirst"===this.dataFormat&&n.rank>1){const t=[0];for(let e=2;e<n.rank;++e)t.push(e);t.push(1),n=n.transpose(t)}return function(t){if(t.rank<=1)throw new XS(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],z_(t.shape,1)];return t.reshape(e)}(n)})}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}YA.className="Flatten",u.registerClass(YA);class ZA extends HE{constructor(t){super(t),this.supportsMasking=!0,this.activation=yA(t.activation)}call(t,e){return dx(()=>{this.invokeCallHook(t,e);const n=OE(t);return this.activation.apply(n)})}getConfig(){const t={activation:mA(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}ZA.className="Activation",u.registerClass(ZA);class JA extends HE{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return dx(()=>{return t=OE(t),e=t,n=this.n,dx(()=>{if(2!==e.shape.length)throw new XS(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return Z_(H_(e,1),[1,n,1])});var e,n})}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}JA.className="RepeatVector",u.registerClass(JA);class QA extends HE{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",r=e.slice();let s=1,i=null;for(let a=0;a<r.length;++a){const t=r[a];if(this.isUnknown(t)){if(null!==i)throw new XS("Can only specifiy one unknown dimension.");i=a}else s*=t}const o=z_(t);if(null!==i){if(0===s||o%s!=0)throw new XS(n);r[i]=o/s}else if(o!==s)throw new XS(n);return r}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return dx(()=>{this.invokeCallHook(t,e);const n=OE(t),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return n.reshape(s)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}QA.className="Reshape",u.registerClass(QA);class tI extends HE{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+t.dims+" instead.");const e=W_(1,t.dims.length+1);if(!r.arraysEqual(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new BE({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=FE(t)).slice();return this.dims.forEach((n,r)=>{e[r+1]=t[n]}),e}call(t,e){return Fy(OE(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}tI.className="Permute",u.registerClass(tI);class eI extends HE{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=OE(t);return pg(tw(n,this.maskValue),-1)}call(t,e){return dx(()=>{this.invokeCallHook(t,e);const n=OE(t),r=pg(tw(n,this.maskValue),-1,!0);return n.mul(r.asType(n.dtype))})}}eI.className="Masking",u.registerClass(eI);class nI extends HE{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=null==t.inputLength?[e,null]:[e].concat(n_(t.inputLength))}this.inputDim=t.inputDim,p_(this.inputDim,"inputDim"),this.outputDim=t.outputDim,p_(this.outputDim,"outputDim"),this.embeddingsInitializer=AE(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=SA(t.embeddingsRegularizer),this.activityRegularizer=SA(t.activityRegularizer),this.embeddingsConstraint=__(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return dx(()=>this.maskZero?(t=OE(t),tw(t,Um(t))):null)}computeOutputShape(t){if(t=FE(t),null==this.inputLength)return[...t,this.outputDim];const e=n_(this.inputLength);if(e.length!==t.length-1)throw new XS(`"inputLength" is ${this.inputLength}, but received input shape has shape `+t);{let n=0;for(let r=0;r<e.length;++r){const s=e[r],i=t[r+1];if(null!=s&&null!=i&&s!==i)throw new XS(`"inputLength" is ${this.inputLength}, but received input shape has shape `+t);null==s&&(e[n]=i),n++}}return[t[0],...e,this.outputDim]}call(t,e){return dx(()=>{this.invokeCallHook(t,e);let n=OE(t);return"int32"!==n.dtype&&(n=j_(n,"int32")),tE(this.embeddings.read(),n.as1D()).reshape(FE(this.computeOutputShape(n.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:kE(this.embeddingsInitializer),embeddingsRegularizer:wA(this.embeddingsRegularizer),activityRegularizer:wA(this.activityRegularizer),embeddingsConstraint:C_(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}nI.className="Embedding",u.registerClass(nI);class rI extends HE{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new YS}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const n=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const s=t[t.length-e.length+r],i=e[r];if(null==s||null==i||s<0||i<0)n.push(null);else if(1===s)n.push(i);else if(1===i)n.push(s);else{if(s!==i)throw new XS("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(s)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[FE(t)]),(t=t).length<2)throw new XS(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const s of t)null!=s&&null!==s[0]&&e.push(s[0]);if(e=u_(e),e.length>1)throw new XS(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=null==t[0]?null:t[0].slice(1);for(let s=1;s<t.length;++s){const e=null==t[s]?null:t[s].slice(1);n=this.computeElementwiseOpOutputShape(n,e)}const r=t.map(t=>t.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==u_(r).length}call(t,e){return dx(()=>{if(t=t,this.reshapeRequired){const e=[],n=t.map(t=>t.rank);if(-1===n.indexOf(null)){const r=U_(n);for(let n of t){const t=n.rank;for(let e=0;e<r-t;++e)n=H_(n,1);e.push(n)}return this.mergeFunction(e)}{let n=!1;for(const i of t){const t=i.rank;if(null==t){const t=i.shape,r=t[0],s=t.slice(1).concat([r]);let o=i.reshape([r].concat(z_(t.slice(1))));o=Fy(o,[1,0]),o=o.reshape(s),e.push(o),n=!0}else if(t>1){const r=W_(1,t).concat([0]);e.push(Fy(i,r)),n=!0}else e.push(i)}let r=this.mergeFunction(e);const s=r.rank;if(n)if(null==s){const t=r.shape,e=t[t.length-1],n=[e].concat(t.slice(0,t.length-1));r=Fy(r.reshape([-1,e]),[1,0]).reshape(n)}else if(s>1){const t=[s-1].concat(W_(0,s-1));r=Fy(r,t)}return r}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==(t=t)[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const n=null==t[r]?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,n)}let n=[];for(const r of t)null!=r&&null!==r[0]&&n.push(r[0]);return n=u_(n),e=1===n.length?n.concat(e):[null].concat(e),e}computeMask(t,e){return dx(()=>{if(null==e)return null;if(!Array.isArray(e))throw new XS("`mask` should be an Array");if(!Array.isArray(t))throw new XS("`inputs` should be an Array");if(e.length!==t.length)throw new XS(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(t=>null==t))return null;let n=(e=e.map(t=>null==t?t:Gm(t,0)))[0];for(let t=1;t<e.length-1;++t)n=db(n,e[t]);return n})}}class sI extends rI{constructor(t){super(t)}mergeFunction(t){return dx(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=wm(e,t[n]);return e})}}sI.className="Add",u.registerClass(sI);class iI extends rI{constructor(t){super(t)}mergeFunction(t){return dx(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=eg(e,t[n]);return e})}}iI.className="Multiply",u.registerClass(iI);class oI extends rI{constructor(t){super(t)}mergeFunction(t){return dx(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=wm(e,t[n]);return eg(1/t.length,e)})}}oI.className="Average",u.registerClass(oI);class aI extends rI{constructor(t){super(t)}mergeFunction(t){return dx(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=jx(e,t[n]);return e})}}aI.className="Maximum",u.registerClass(aI);class lI extends rI{constructor(t){super(t)}mergeFunction(t){return dx(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=Zx(e,t[n]);return e})}}lI.className="Minimum",u.registerClass(lI);class uI extends rI{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new XS("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const r of t)if(null!=r){e=!1;break}if(e)return;const n=[];for(let s=0;s<t.length;++s){const e=t[s].slice();e.splice(this.axis,1);let i=!1;for(const t of n)if(r.arraysEqual(t,e)){i=!0;break}i||n.push(e)}if(n.length>1)throw new XS("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return dx(()=>X_(t,this.axis))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new XS("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const s of e.slice(1)){if(null==n[r]||null==s[r]){n[r]=null;break}n[r]+=s[r]}return n}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new XS("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new XS("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new XS(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return dx(()=>{let n=!0;if(e.forEach(t=>{null==t||(n=!1)}),n)return null;const r=[];for(let i=0;i<t.length;++i)r.push(null==e[i]?Vm(t[i]).asType("bool"):e[i].rank<t[i].rank?Gm(e[i],-1):e[i]);const s=Wm(r,this.axis);return dg(s,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function cI(t,e){for(;t<0;)t+=e;return t}uI.className="Concatenate",u.registerClass(uI);class hI extends rI{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){r.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new YS("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(e,n);if(e[s[0]]!==n[s[1]])throw new XS(`Dimension incompatibility: ${e[s[0]]} !== ${n[s[1]]}`)}mergeFunction(t){if(2!==t.length)throw new XS(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e,n=t[0],s=t[1];return e=Array.isArray(this.axes)?this.axes.map((e,n)=>cI(e,t[n].shape.length)):[cI(this.axes,n.shape.length),cI(this.axes,s.shape.length)],this.normalize&&(n=ik(n,e[0]),s=ik(s,e[1])),function(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new YS("batchDot is not implemented for tensors of 4D or higher rank yet");if(r.assert(t.shape.length>=2,()=>"batchDot requires the rank of x to be >= 2, but got "+t.shape.length),r.assert(t.shape.length>=2,()=>"batchDot requires the rank of y to be >= 2, but got "+e.shape.length),"number"==typeof n&&(n=[n,n]),"complex64"===t.dtype||"complex64"===e.dtype)throw new YS("batchDot is not implemented for complex64-type Tensors yet.");const s=t.shape.length,i=e.shape.length;null==n&&(n=[s-1,i-2]);const o=n;return dx(()=>{let n,r;if(s>i){n=s-i;const t=[];for(let e=0;e<n;++e)t.push(1);e=e.reshape(e.shape.concat(t))}else if(i>s){n=i-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=t.reshape(t.shape.concat(e))}else n=0;if(r=2===t.shape.length&&2===e.shape.length?o[0]===o[1]?t.mul(e).sum(o[0]):t.transpose([1,0]).mul(e).sum(o[1]):t.matMul(e,o[0]!==t.shape.length-1,o[1]===e.shape.length-1),n>0){let t;t=s>i?s+i-3:s-1;const e=[];for(let r=t;r<t+n;++r)e.push(r);r=r.squeeze(e)}return 1===r.shape.length&&(r=r.expandDims(1)),r})}(n,s,e)}interpretAxes(t,e){let n;return n=Array.isArray(this.axes)?this.axes:[cI(this.axes,t.length),cI(this.axes,e.length)],n}computeOutputShape(t){r.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new YS("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(e,n);e.splice(s[0],1),n.splice(s[1],1),n.splice(0,1);const i=e.concat(n);return 1===i.length&&i.push(1),i}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}hI.className="Dot",u.registerClass(hI);class dI extends HE{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return dx(()=>{this.invokeCallHook(t,e);const n=OE(t);return iE(()=>J_(n.shape,0,this.stddev).add(n),()=>n,e.training||!1)})}}dI.className="GaussianNoise",u.registerClass(dI);class pI extends HE{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return dx(()=>{this.invokeCallHook(t,e);const n=OE(t);return this.rate>0&&this.rate<1?iE(()=>{const t=Math.sqrt(this.rate/(1-this.rate));return n.mul(J_(n.shape,1,t))},()=>n,e.training||!1):n})}}pI.className="GaussianDropout",u.registerClass(pI);class fI extends HE{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||OE(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return dx(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t);return iE(()=>{const e=OE(t),r=-1.7580993408473766;let s=Zy(mw(n),this.rate);s=j_(s,"float32");const i=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-i*r*this.rate;return e.mul(s).add(s.add(-1).mul(r)).mul(i).add(o)},()=>OE(t),e.training||!1)}return t})}}function mI(t,e,n,r,s,i=.001){let o;if(2===t.rank)o=Cx(t,e,n,r,s,i);else if(3===t.rank)o=Sx(t,e,n,r,s,i);else{if(4!==t.rank)throw new YS(`batchNormalization is not implemented for array of rank ${t.rank} yet`);o=_x(t,e,n,r,s,i)}return o}fI.className="AlphaDropout",u.registerClass(fI);class gI extends HE{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=AE(t.betaInitializer||"zeros"),this.gammaInitializer=AE(t.gammaInitializer||"ones"),this.movingMeanInitializer=AE(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=AE(t.movingVarianceInitializer||"ones"),this.betaConstraint=__(t.betaConstraint),this.gammaConstraint=__(t.gammaConstraint),this.betaRegularizer=SA(t.betaRegularizer),this.gammaRegularizer=SA(t.gammaRegularizer)}build(t){t=FE(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(null==n)throw new XS(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape `+JSON.stringify(t)+".");this.inputSpec=[new BE({ndim:t.length,axes:{[e]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return dx(()=>{const n=null!=e.training&&e.training,s=OE(t),i=s.shape,o=i.length,a=W_(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const u=JS(1,o);u[l]=i[l];const c=a.slice();c.sort();const h=!r.arraysEqual(c,W_(0,o).slice(0,o-1));if(!n)return(()=>{if(h){const t=this.movingMean.read().reshape(u),e=this.movingVariance.read().reshape(u),n=this.center?this.beta.read().reshape(u):null,r=this.scale?this.gamma.read().reshape(u):null;return mI(s,t,e,n,r,this.epsilon)}return mI(s,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,p,f]=function(t,e,n,s,i=.001){return r.arraysEqual(s.slice().sort(),W_(0,t.rank-1))?function(t,e,n,r,s=.001){return dx(()=>{const i=vg(t,r),o=i.mean,a=i.variance;return[mI(t,o,a,n,e,s),o,a]})}(t,e,n,s,i):function(t,e,n,r,s=.001){return dx(()=>{const i=vg(t,r),o=i.mean,a=i.variance,l=[];for(const e of W_(0,t.rank))-1!==r.indexOf(e)?l.push(1):l.push(t.shape[e]);const u=o.reshape(l),c=a.reshape(l),h=null==e?null:e.reshape(l),d=null==n?null:n.reshape(l);return[mI(t,u,c,d,h,s),o,a]})}(t,e,n,s,i)}(s,this.gamma.read(),this.beta.read(),a,this.epsilon),m=(t,e,n)=>{dx(()=>{const r=1-n,s=t.read(),i=s.sub(e).mul(r);t.write(s.sub(i))})};return(()=>{m(this.movingMean,p,this.momentum),m(this.movingVariance,f,this.momentum)})(),d})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:kE(this.betaInitializer),gammaInitializer:kE(this.gammaInitializer),movingMeanInitializer:kE(this.movingMeanInitializer),movingVarianceInitializer:kE(this.movingVarianceInitializer),betaRegularizer:wA(this.betaRegularizer),gammaRegularizer:wA(this.gammaRegularizer),betaConstraint:C_(this.betaConstraint),gammaConstraint:C_(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}gI.className="BatchNormalization",u.registerClass(gI);class yI extends HE{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received "+this.axis)}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, but received "+JSON.stringify(this.axis));for(const t of this.axis)if(!Number.isInteger(t))throw new Error("Expected axis to be an array of integers, but received "+JSON.stringify(this.axis))}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=AE(t.betaInitializer||"zeros"),this.gammaInitializer=AE(t.gammaInitializer||"ones"),this.betaRegularizer=SA(t.betaRegularizer),this.gammaRegularizer=SA(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=FE(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=e);for(const r of this.axis)if(r<0||r>=e)throw new Error("Invalid axis: "+r);if(this.axis.length!==u_(this.axis).length)throw new Error("Found duplicate axes in: "+this.axis);const n=this.axis.map(e=>t[e]);this.gamma=this.scale?this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(t,e){const n=OE(t),r=n.shape,s=r.length;return dx(()=>{let{mean:t,variance:e}=vg(n,this.axis,!0);const i=JS(1,s);for(const n of this.axis)i[n]=r[n];const o=t=>null!=t&&t.shape.length!==s&&this.axis!==[s-1]?t.reshape(i):t;let a=o(this.gamma.read()),l=o(this.beta.read());const u=[],c=[];for(let n=0;n<s;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),c.push(1)):(u.push(1),c.push(r[n]));return t=t.tile(u),e=e.tile(u),a=a.tile(c),l=l.tile(c),mI(n,t,e,l,a,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:kE(this.betaInitializer),gammaInitializer:kE(this.gammaInitializer),betaRegularizer:wA(this.betaRegularizer),gammaRegularizer:wA(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}yI.className="LayerNormalization",u.registerClass(yI);class bI extends HE{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new XS(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if("number"==typeof t.padding[0])e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new XS(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],2!==t.padding[1].length)throw new XS(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new BE({ndim:4})]}computeOutputShape(t){let e,n;return t=FE(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])}call(t,e){return dx(()=>{return e=OE(t),n=this.padding,r=this.dataFormat,dx(()=>{if(4!==e.rank)throw new XS("temporalPadding expects input tensor to be 4-D, but received a "+e.rank+"-D tensor.");if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new XS("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new XS(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let t;return t="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],$b(e,t)});var e,n,r})}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}function vI(t,e,n,r,s,i){return dx(()=>{let o;T_(s),$_(i),R_(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),t=DA(t,s);const a="same"===r?"same":"valid";return o="max"===i?Kx(t,e,n,a):bx(t,e,n,a),"channelsFirst"===s&&(o=Fy(o,[0,3,1,2])),o})}function xI(t,e,n,r,s,i){return dx(()=>{let o;T_(s),$_(i),R_(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),t=OA(t,s);const a="same"===r?"same":"valid";return o="max"===i?Xx(t,e,n,a):vx(t,e,n,a),"channelsFirst"===s&&(o=Fy(o,[0,4,1,2,3])),o})}bI.className="ZeroPadding2D",u.registerClass(bI);class wI extends HE{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new XS("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(t.poolSize));this.poolSize=t.poolSize}if(p_(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new XS("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(t.strides));this.strides=t.strides}p_(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,R_(this.padding),this.inputSpec=[new BE({ndim:3})]}computeOutputShape(t){const e=RA((t=FE(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return dx(()=>{this.invokeCallHook(t,e),t=H_(OE(t),2);const n=this.poolingFunction(OE(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Xm(n,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class CI extends wI{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return T_(s),R_(r),vI(t,e,n,r,s,"max")}}CI.className="MaxPooling1D",u.registerClass(CI);class SI extends wI{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return T_(s),R_(r),vI(t,e,n,r,s,"avg")}}SI.className="AveragePooling1D",u.registerClass(SI);class _I extends HE{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new XS("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+t.strides.length+".");this.strides=t.strides}else this.strides=[t.strides,t.strides];p_(this.poolSize,"poolSize"),p_(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,T_(this.dataFormat),R_(this.padding),this.inputSpec=[new BE({ndim:4})]}computeOutputShape(t){t=FE(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=RA(e,this.poolSize[0],this.padding,this.strides[0]),n=RA(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return dx(()=>(this.invokeCallHook(t,e),this.poolingFunction(OE(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class EI extends _I{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return T_(s),R_(r),vI(t,e,n,r,s,"max")}}EI.className="MaxPooling2D",u.registerClass(EI);class kI extends _I{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return T_(s),R_(r),vI(t,e,n,r,s,"avg")}}kI.className="AveragePooling2D",u.registerClass(kI);class AI extends HE{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new XS("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+t.strides.length+".");this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];p_(this.poolSize,"poolSize"),p_(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,T_(this.dataFormat),R_(this.padding),this.inputSpec=[new BE({ndim:5})]}computeOutputShape(t){t=FE(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[4]:t[3];return e=RA(e,this.poolSize[0],this.padding,this.strides[0]),n=RA(n,this.poolSize[1],this.padding,this.strides[1]),r=RA(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,r]:[t[0],e,n,r,t[4]]}call(t,e){return dx(()=>(this.invokeCallHook(t,e),this.poolingFunction(OE(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class II extends AI{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return T_(s),R_(r),xI(t,e,n,r,s,"max")}}II.className="MaxPooling3D",u.registerClass(II);class NI extends AI{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return T_(s),R_(r),xI(t,e,n,r,s,"avg")}}NI.className="AveragePooling3D",u.registerClass(NI);class TI extends HE{constructor(t){super(t),this.inputSpec=[new BE({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new YS}}class RI extends TI{constructor(t){super(t||{})}call(t,e){return dx(()=>{const e=OE(t);return yg(e,1)})}}RI.className="GlobalAveragePooling1D",u.registerClass(RI);class $I extends TI{constructor(t){super(t||{})}call(t,e){return dx(()=>{const e=OE(t);return Gx(e,1)})}}$I.className="GlobalMaxPooling1D",u.registerClass($I);class DI extends HE{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,T_(this.dataFormat),this.inputSpec=[new BE({ndim:4})]}computeOutputShape(t){return t=t,"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new YS}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class OI extends DI{call(t,e){return dx(()=>{const e=OE(t);return yg(e,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}OI.className="GlobalAveragePooling2D",u.registerClass(OI);class FI extends DI{call(t,e){return dx(()=>{const e=OE(t);return Gx(e,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}function MI(t,e,n,r){if(Array.isArray(t)){if(null!=e||null!=n)throw new XS("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function s(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=s(e),constants:n=s(n)}}function LI(t,e,n,r=!1,s,i,o=!1,a=!1){return dx(()=>{const l=e.shape.length;if(l<3)throw new XS(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(W_(2,l));if(e=Fy(e,u),null!=i)throw new YS("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=s.asType("bool").asType("float32")).rank===l-1&&(s=Gm(s,-1)),s=Fy(s,u)),r&&(e=$w(e,0),null!=s&&(s=$w(s,0)));const c=[];let h,d=n;const p=e.shape[0],f=Zm(e);let m,g;null!=s&&(m=Zm(s));for(let e=0;e<p;++e){const n=f[e],r=dx(()=>t(n,d));if(null==s)h=r[0],d=r[1];else{const t=dx(()=>{const t=m[e],n=Vm(t).sub(t);return{output:r[0].mul(t).add(d[0].mul(n)),newStates:d.map((e,s)=>r[1][s].mul(t).add(e.mul(n)))}});h=t.output,d=t.newStates}a&&c.push(h)}return a&&(g=Ym(c,1)),[h,g,d]})}FI.className="GlobalMaxPooling2D",u.registerClass(FI);class PI extends HE{constructor(t){let e;if(super(t),null==t.cell)throw new XS("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new qI({cells:t.cell}):t.cell,null==e.stateSize)throw new XS("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new BE({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?W_(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(t=>null):this.states_}setStates(t){this.states_=t}computeOutputShape(t){$E(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let r;if(r=this.returnSequences?[t[0],t[1],n]:[t[0],n],this.returnState){const n=[];for(const r of e)n.push([t[0],r]);return[r].concat(n)}return r}computeMask(t,e){return dx(()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map(t=>null);return[t].concat(e)}return t})}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new YS("Constants support is not implemented in RNN yet.");$E(t)&&(t=t[0]),t=t,this.inputSpec[0]=new BE({shape:[this.stateful?t[0]:null,null,t[t.length-1]]});const e=[t[0]].concat(t.slice(2));let n;if(this.cell.build(e),n=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!r.arraysEqual(this.stateSpec.map(t=>t.shape[t.shape.length-1]),n))throw new XS(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is `+this.cell.stateSize)}else this.stateSpec=n.map(t=>new BE({shape:[null,t]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){dx(()=>{if(!this.stateful)throw new GS("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new XS("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(t=>Pm([n,t])):[Pm([n,this.cell.stateSize])];else if(null==t)px(this.states_),null!=this.keptStates&&(px(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(t=>Pm([n,t])):this.states_[0]=Pm([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new XS(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: `+t);!0===e?this.keptStates.push(this.states_.slice()):px(this.states_);for(let e=0;e<this.states_.length;++e){const s=t[e],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,o=[n,i];if(!r.arraysEqual(s.shape,o))throw new XS(`State ${e} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[e]=s}}this.states_=this.states_.map(t=>fx(t.clone()))})}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const s=MI(t,n,r,this.numConstants);t=s.inputs,n=s.initialState,r=s.constants;let i=[],o=[];if(null!=n){e.initialState=n,i=i.concat(n),this.stateSpec=[];for(const t of n)this.stateSpec.push(new BE({shape:t.shape}));o=o.concat(this.stateSpec)}if(null!=r&&(e.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof VE){const n=[t].concat(i),r=this.inputSpec.concat(o),s=this.inputSpec;this.inputSpec=r;const a=super.apply(n,e);return this.inputSpec=s,a}return super.apply(t,e)}call(t,e){return dx(()=>{const n=null==e?null:e.mask,r=null==e?null:e.training;let s=null==e?null:e.initialState;t=OE(t),null==s&&(s=this.stateful?this.states_:this.getInitialState(t));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new XS(`RNN Layer has ${i} state(s) but was passed `+s.length+" initial state(s).");this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},a=LI((t,e)=>{const n=this.cell.call([t].concat(e),o);return[n[0],n.slice(1)]},t,s,this.goBackwards,n,null,this.unroll,this.returnSequences),l=a[0],u=a[1],c=a[2];this.stateful&&this.resetStates(c,r);const h=this.returnSequences?u:l;return this.returnState?[h].concat(c):h})}getInitialState(t){return dx(()=>{let e=Pm(t.shape);return e=xg(e,[1,2]),e=H_(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(t=>t>1?Z_(e,[1,t]):e):this.cell.stateSize>1?[Z_(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const e=this.cell.getConfig();t.cell={className:this.cell.getClassName(),config:e};const n=super.getConfig();return Object.assign(t,n),t}static fromConfig(t,e,n={}){const r=sk(e.cell,n);return new t(Object.assign(e,{cell:r}))}}PI.className="RNN",u.registerClass(PI);class zI extends HE{}class BI extends zI{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,p_(this.units,"units"),this.activation=yA(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=AE(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=AE(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=AE(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=SA(t.kernelRegularizer),this.recurrentRegularizer=SA(t.recurrentRegularizer),this.biasRegularizer=SA(t.biasRegularizer),this.kernelConstraint=__(t.kernelConstraint),this.recurrentConstraint=__(t.recurrentConstraint),this.biasConstraint=__(t.biasConstraint),this.dropout=V_([1,U_([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=V_([1,U_([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=FE(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return dx(()=>{if(2!==(t=t).length)throw new XS(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];const r=null!=e.training&&e.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=GI(()=>Vm(t),this.dropout,r)),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=GI(()=>Vm(n),this.recurrentDropout,r));const i=this.dropoutMask,o=this.recurrentDropoutMask;s=Q_(null!=i?eg(t,i):t,this.kernel.read()),null!=this.bias&&(s=rE(s,this.bias.read())),null!=o&&(n=eg(n,o));let a=wm(s,Q_(n,this.recurrentKernel.read()));return null!=this.activation&&(a=this.activation.apply(a)),[a,a]})}getConfig(){const t={units:this.units,activation:mA(this.activation),useBias:this.useBias,kernelInitializer:kE(this.kernelInitializer),recurrentInitializer:kE(this.recurrentInitializer),biasInitializer:kE(this.biasInitializer),kernelRegularizer:wA(this.kernelRegularizer),recurrentRegularizer:wA(this.recurrentRegularizer),biasRegularizer:wA(this.biasRegularizer),activityRegularizer:wA(this.activityRegularizer),kernelConstraint:C_(this.kernelConstraint),recurrentConstraint:C_(this.recurrentConstraint),biasConstraint:C_(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout},e=super.getConfig();return Object.assign(t,e),t}}BI.className="SimpleRNNCell",u.registerClass(BI);class VI extends PI{constructor(t){t.cell=new BI(t),super(t)}call(t,e){return dx(()=>(null!=this.cell.dropoutMask&&(px(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(px(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}get units(){return this.cell.units}get activation(){return this.cell.activation}get useBias(){return this.cell.useBias}get kernelInitializer(){return this.cell.kernelInitializer}get recurrentInitializer(){return this.cell.recurrentInitializer}get biasInitializer(){return this.cell.biasInitializer}get kernelRegularizer(){return this.cell.kernelRegularizer}get recurrentRegularizer(){return this.cell.recurrentRegularizer}get biasRegularizer(){return this.cell.biasRegularizer}get kernelConstraint(){return this.cell.kernelConstraint}get recurrentConstraint(){return this.cell.recurrentConstraint}get biasConstraint(){return this.cell.biasConstraint}get dropout(){return this.cell.dropout}get recurrentDropout(){return this.cell.recurrentDropout}getConfig(){const t={units:this.units,activation:mA(this.activation),useBias:this.useBias,kernelInitializer:kE(this.kernelInitializer),recurrentInitializer:kE(this.recurrentInitializer),biasInitializer:kE(this.biasInitializer),kernelRegularizer:wA(this.kernelRegularizer),recurrentRegularizer:wA(this.recurrentRegularizer),biasRegularizer:wA(this.biasRegularizer),activityRegularizer:wA(this.activityRegularizer),kernelConstraint:C_(this.kernelConstraint),recurrentConstraint:C_(this.recurrentConstraint),biasConstraint:C_(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout},e=super.getConfig();return delete e.cell,Object.assign(t,e),t}static fromConfig(t,e){return new t(e)}}VI.className="SimpleRNN",u.registerClass(VI);class UI extends zI{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new XS("GRUCell does not support reset_after parameter set to true.");this.units=t.units,p_(this.units,"units"),this.activation=yA(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=yA(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=AE(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=AE(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=AE(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=SA(t.kernelRegularizer),this.recurrentRegularizer=SA(t.recurrentRegularizer),this.biasRegularizer=SA(t.biasRegularizer),this.kernelConstraint=__(t.kernelConstraint),this.recurrentConstraint=__(t.recurrentConstraint),this.biasConstraint=__(t.biasConstraint),this.dropout=V_([1,U_([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=V_([1,U_([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=FE(t),this.kernel=this.addWeight("kernel",[t[t.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return dx(()=>{if(2!==(t=t).length)throw new XS("GRUCell expects 2 input Tensors (inputs, h, c), got "+t.length+".");const n=null!=e.training&&e.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=GI(()=>Vm(t),this.dropout,n,3)),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=GI(()=>Vm(r),this.recurrentDropout,n,3));const s=this.recurrentDropoutMask;let i,o,a;0<this.dropout&&this.dropout<1&&(t=eg(t,this.dropoutMask[0]));let l=Q_(t,this.kernel.read());this.useBias&&(l=rE(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=eg(r,s[0]));const u=this.recurrentKernel.read(),[c,h]=Ey(u,[2*this.units,this.units],u.rank-1),d=Q_(r,c),[p,f,m]=Ey(l,3,l.rank-1),[g,y]=Ey(d,2,d.rank-1);i=this.recurrentActivation.apply(wm(p,g)),o=this.recurrentActivation.apply(wm(f,y));const b=Q_(eg(o,r),h);a=this.activation.apply(wm(m,b));const v=wm(eg(i,r),eg(wm(1,Vg(i)),a));return[v,v]})}getConfig(){const t={units:this.units,activation:mA(this.activation),recurrentActivation:mA(this.recurrentActivation),useBias:this.useBias,kernelInitializer:kE(this.kernelInitializer),recurrentInitializer:kE(this.recurrentInitializer),biasInitializer:kE(this.biasInitializer),kernelRegularizer:wA(this.kernelRegularizer),recurrentRegularizer:wA(this.recurrentRegularizer),biasRegularizer:wA(this.biasRegularizer),activityRegularizer:wA(this.activityRegularizer),kernelConstraint:C_(this.kernelConstraint),recurrentConstraint:C_(this.recurrentConstraint),biasConstraint:C_(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1},e=super.getConfig();return Object.assign(t,e),t}}UI.className="GRUCell",u.registerClass(UI);class WI extends PI{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new UI(t),super(t)}call(t,e){return dx(()=>(null!=this.cell.dropoutMask&&(px(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(px(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}get units(){return this.cell.units}get activation(){return this.cell.activation}get recurrentActivation(){return this.cell.recurrentActivation}get useBias(){return this.cell.useBias}get kernelInitializer(){return this.cell.kernelInitializer}get recurrentInitializer(){return this.cell.recurrentInitializer}get biasInitializer(){return this.cell.biasInitializer}get kernelRegularizer(){return this.cell.kernelRegularizer}get recurrentRegularizer(){return this.cell.recurrentRegularizer}get biasRegularizer(){return this.cell.biasRegularizer}get kernelConstraint(){return this.cell.kernelConstraint}get recurrentConstraint(){return this.cell.recurrentConstraint}get biasConstraint(){return this.cell.biasConstraint}get dropout(){return this.cell.dropout}get recurrentDropout(){return this.cell.recurrentDropout}get implementation(){return this.cell.implementation}getConfig(){const t={units:this.units,activation:mA(this.activation),recurrentActivation:mA(this.recurrentActivation),useBias:this.useBias,kernelInitializer:kE(this.kernelInitializer),recurrentInitializer:kE(this.recurrentInitializer),biasInitializer:kE(this.biasInitializer),kernelRegularizer:wA(this.kernelRegularizer),recurrentRegularizer:wA(this.recurrentRegularizer),biasRegularizer:wA(this.biasRegularizer),activityRegularizer:wA(this.activityRegularizer),kernelConstraint:C_(this.kernelConstraint),recurrentConstraint:C_(this.recurrentConstraint),biasConstraint:C_(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1},e=super.getConfig();return delete e.cell,Object.assign(t,e),t}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}WI.className="GRU",u.registerClass(WI);class jI extends zI{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,p_(this.units,"units"),this.activation=yA(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=yA(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=AE(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=AE(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=AE(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=SA(t.kernelRegularizer),this.recurrentRegularizer=SA(t.recurrentRegularizer),this.biasRegularizer=SA(t.biasRegularizer),this.kernelConstraint=__(t.kernelConstraint),this.recurrentConstraint=__(t.recurrentConstraint),this.biasConstraint=__(t.biasConstraint),this.dropout=V_([1,U_([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=V_([1,U_([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;let n;if(t=FE(t),this.kernel=this.addWeight("kernel",[t[t.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,r=this.units;n=new((e=class extends lE{apply(e,n){const s=t.apply([r]),i=(new cE).apply([r]),o=t.apply([2*r]);return Y_(Y_(s,i),o)}}).className="CustomInit",e)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return dx(()=>{const n=null!=e.training&&e.training;if(3!==(t=t).length)throw new XS("LSTMCell expects 3 input Tensors (inputs, h, c), got "+t.length+".");let r=t[1];const s=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=GI(()=>Vm(t),this.dropout,n,4)),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=GI(()=>Vm(r),this.recurrentDropout,n,4));const i=this.recurrentDropoutMask;let o,a,l,u;0<this.dropout&&this.dropout<1&&(t=eg(t,this.dropoutMask[0]));let c=Q_(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=eg(r,i[0])),c=wm(c,Q_(r,this.recurrentKernel.read())),this.useBias&&(c=rE(c,this.bias.read()));const[h,d,p,f]=Ey(c,4,c.rank-1);o=this.recurrentActivation.apply(h),a=this.recurrentActivation.apply(d),l=wm(eg(a,s),eg(o,this.activation.apply(p))),u=this.recurrentActivation.apply(f);const m=eg(u,this.activation.apply(l));return[m,m,l]})}getConfig(){const t={units:this.units,activation:mA(this.activation),recurrentActivation:mA(this.recurrentActivation),useBias:this.useBias,kernelInitializer:kE(this.kernelInitializer),recurrentInitializer:kE(this.recurrentInitializer),biasInitializer:kE(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:wA(this.kernelRegularizer),recurrentRegularizer:wA(this.recurrentRegularizer),biasRegularizer:wA(this.biasRegularizer),activityRegularizer:wA(this.activityRegularizer),kernelConstraint:C_(this.kernelConstraint),recurrentConstraint:C_(this.recurrentConstraint),biasConstraint:C_(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},e=super.getConfig();return Object.assign(t,e),t}}jI.className="LSTMCell",u.registerClass(jI);class HI extends PI{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new jI(t),super(t)}call(t,e){return dx(()=>(null!=this.cell.dropoutMask&&(px(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(px(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}get units(){return this.cell.units}get activation(){return this.cell.activation}get recurrentActivation(){return this.cell.recurrentActivation}get useBias(){return this.cell.useBias}get kernelInitializer(){return this.cell.kernelInitializer}get recurrentInitializer(){return this.cell.recurrentInitializer}get biasInitializer(){return this.cell.biasInitializer}get unitForgetBias(){return this.cell.unitForgetBias}get kernelRegularizer(){return this.cell.kernelRegularizer}get recurrentRegularizer(){return this.cell.recurrentRegularizer}get biasRegularizer(){return this.cell.biasRegularizer}get kernelConstraint(){return this.cell.kernelConstraint}get recurrentConstraint(){return this.cell.recurrentConstraint}get biasConstraint(){return this.cell.biasConstraint}get dropout(){return this.cell.dropout}get recurrentDropout(){return this.cell.recurrentDropout}get implementation(){return this.cell.implementation}getConfig(){const t={units:this.units,activation:mA(this.activation),recurrentActivation:mA(this.recurrentActivation),useBias:this.useBias,kernelInitializer:kE(this.kernelInitializer),recurrentInitializer:kE(this.recurrentInitializer),biasInitializer:kE(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:wA(this.kernelRegularizer),recurrentRegularizer:wA(this.recurrentRegularizer),biasRegularizer:wA(this.biasRegularizer),activityRegularizer:wA(this.activityRegularizer),kernelConstraint:C_(this.kernelConstraint),recurrentConstraint:C_(this.recurrentConstraint),biasConstraint:C_(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},e=super.getConfig();return delete e.cell,Object.assign(t,e),t}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}HI.className="LSTM",u.registerClass(HI);class qI extends zI{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return dx(()=>{let n=(t=t).slice(1);const r=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?r.push(n.splice(0,t.stateSize.length)):r.push(n.splice(0,1));r.reverse();const s=[];let i;for(let o=0;o<this.cells.length;++o){const a=this.cells[o];n=r[o],i=0===o?[t[0]].concat(n):[i[0]].concat(n),i=a.call(i,e),s.push(i.slice(1))}n=[];for(const t of s.slice().reverse())n.push(...t);return[i[0]].concat(n)})}build(t){let e;$E(t)&&(t=t[0]),t=t,this.cells.forEach((n,r)=>{O_("RNNCell_"+r,()=>{n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=[];for(const r of this.cells)t.push({className:r.getClassName(),config:r.getConfig()});const e={cells:t},n=super.getConfig();return Object.assign(e,n),e}static fromConfig(t,e,n={}){const r=[];for(const s of e.cells)r.push(sk(s,n));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return PE(t)}setWeights(t){const e=[];for(const n of this.cells){const r=t.splice(n.weights.length);for(let t=0;t<n.weights.length;++t)e.push([n.weights[t],r[t]])}zE(e)}}function GI(t,e,n=null,r=1){function s(){return sE(t(),e)}if(r>1){const e=[];for(let i=0;i<r;i++)e.push(iE(s,t,n));return e.map(t=>fx(t.clone()))}return fx(iE(s,t,n).clone())}qI.className="StackedRNNCells",u.registerClass(qI);class KI extends HE{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){const r=sk(e.layer,n);delete e.layer;const s={layer:r};return Object.assign(s,e),new t(s)}}class XI extends KI{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=FE(t)).length<3)throw new XS("TimeDistributed layer expects an input shape >= 3D, but received input shape "+JSON.stringify(t));this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=FE(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e);return[n[0],t[1]].concat(n.slice(1))}call(t,e){return dx(()=>LI((t,n)=>[OE(this.layer.call(t,e)),[]],t=OE(t),[],!1,null,null,!1,!0)[1])}}XI.className="TimeDistributed",u.registerClass(XI);class YI extends KI{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=sk(n),e.goBackwards=!0!==e.goBackwards;const r={};if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=sk(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,h_(I_,"BidirectionalMergeMode",this.mergeMode),t.weights)throw new YS("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=Math.floor(t.length/2);this.forwardLayer.setWeights(t.slice(0,e)),this.backwardLayer.setWeights(t.slice(e))}computeOutputShape(t){let e,n,r,s=this.forwardLayer.computeOutputShape(t);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),s=s,this.returnState?(r=s.slice(1),e=s[0]):e=s[0],e=e,"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[e].concat(r).concat(r.slice()):e_(n)}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const s=MI(t,n,r,this.numConstants);if(t=s.inputs,n=s.initialState,r=s.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(null==n||0===n.length)&&null==r)return super.apply(t,e);const i=[],o=[];if(null!=n){const t=n.length;if(t%2>0)throw new XS("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,i.push(...n);const r=n.map(t=>new BE({shape:t.shape}));this.forwardLayer.stateSpec=r.slice(0,t/2),this.backwardLayer.stateSpec=r.slice(t/2),o.push(...r)}if(null!=r)throw new YS("Support for constants in Bidirectional layers is not implemented yet.");const a=i[0]instanceof VE;for(const l of i)if(l instanceof VE!==a)throw new XS("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(a){const n=[t].concat(i),r=this.inputSpec.concat(o),s=this.inputSpec;this.inputSpec=r;const a=super.apply(n,e);return this.inputSpec=s,a}return super.apply(t,e)}call(t,e){return dx(()=>{const n=e.initialState;let r,s,i,o;if(null==n)r=this.forwardLayer.call(t,e),s=this.backwardLayer.call(t,e);else{const i=n.slice(0,n.length/2),o=n.slice(n.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:i})),s=this.backwardLayer.call(t,Object.assign(e,{initialState:o}))}return this.returnState&&(Array.isArray(r)&&(i=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=$w(s,1)),"concat"===this.mergeMode?o=X_([r,s]):"sum"===this.mergeMode?o=wm(r,s):"ave"===this.mergeMode?o=eg(.5,wm(r,s)):"mul"===this.mergeMode?o=eg(r,s):null==this.mergeMode&&(o=[r,s]),this.returnState?null==this.mergeMode?o.concat(i):[o].concat(i):o})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){O_(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),O_(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){let n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map(t=>null);return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=sk(e.layer);if(delete e.layer,null!=e.numConstants)throw new YS("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=e;return r.layer=n,new t(r)}}var ZI,JI;YI.className="Bidirectional",u.registerClass(YI),function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(ZI||(ZI={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(JI||(JI={}));const QI=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],tN=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"clip_value_min",name:"clipValueMin",type:"number"},{tfName:"clip_value_max",name:"clipValueMax",type:"number"}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"clipValueMin",name:"clipValueMin",type:"number",defaultValue:0},{tfName:"clipValueMax",name:"clipValueMax",type:"number",defaultValue:6}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],eN=[{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]}],nN=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]}],rN=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],sN=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],iN=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]}],oN=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],aN=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],lN=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],uN=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],cN=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],hN=[{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],dN=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool",notSupported:!0}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],pN=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],fN=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];function mN(t,e,n=""){r.assert(function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(-1!==t[n]&&-1!==e[n]&&t[n]!==e[n])return!1;return!0}(t,e),()=>n+` Shapes ${t} and ${e} must match`)}class gN{constructor(t,e,n,r,s,i,o){this.name=t,this.dtype=e,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=i,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.id=gN.nextId++}get closed(){return this.closed_}clearAndClose(){this.tensors.forEach(t=>t.tensor.dispose()),this.tensors=[],this.closed_=!0}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(t=>this.read(t))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=e.shape),mN(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),n&&n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(n&&n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);n.tensor=e,n.written=!0,this.tensors[t]=n}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((t,n)=>this.write(t,e[n]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let e=0;e<this.size();e++)t.push(e)}if(0===t.length)return Am([],[0].concat(this.elementShape));const n=this.readMany(t);return mN(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Ym(n,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return Am([],[0].concat(this.elementShape));const e=[];for(let r=0;r<this.size();r++)e.push(r);const n=this.readMany(e);return mN(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Wm(n,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const n=Math.max(...t);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(t,Zm(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let n=0;const r=t.map(t=>(n+=t,n));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===n?0:e.size/n,i=[];dx(()=>{e=e.reshape([1,n,s]);for(let n=0;n<t.length;++n)i[n]=jb(e,[0,0===n?0:r[n-1],0],[1,t[n],s]).reshape(this.elementShape);return i});const o=[];for(let a=0;a<t.length;a++)o[a]=a;this.writeMany(o,i)}}function yN(t){return null===t?null:bN(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function bN(t){return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"==typeof t&&!(t instanceof qf))}function vN(t){return t instanceof qf?{value:t.clone(),recurse:!1}:bN(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}gN.nextId=0;class xN{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}}class wN extends xN{constructor(){super(wN.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=new Array(t),n=this.length();for(let r=0;r<n;r++)e[r]=this.get(this.wrap(this.begin+r));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}wN.INITIAL_CAPACITY=32;class CN{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new RN(this,t)}filter(t){return new NN(this,t)}map(t){return new TN(this,t)}mapAsync(t){return new $N(this,t)}serialMapAsync(t){return new $N(this,t).serial()}flatmap(t){return new ON(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(t=>!0===t)}rowMajorBatch(t,e=!0){return new IN(this,t,e)}columnMajorBatch(t,e=!0,n=yN){return this.rowMajorBatch(t,e).map(t=>function(t,e=yN){return function t(e,n,r=new Set){const s=e[0];if(r.has(s))throw new Error("Circular references are not supported.");const i=n(e);if(i.recurse&&null!==i.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(i.recurse){if(bN(s)){const i=Array.isArray(s)?[]:{};r.add(s);for(const o in s){const s=t(e.map(t=>t[o]),n,r);i[o]=s}return r.delete(s),i}throw new Error("Can't recurse into non-iterable type: "+s)}return i.value}(t,e)}(t,n))}concatenate(t,e){return new FN(new SN([this,t]),e)}take(t){return t<0||null==t?this:new AN(this,t)}skip(t){return t<0||null==t?this:new kN(this,t)}prefetch(t){return new LN(this,t)}shuffle(t,e){return new PN(this,t,e)}serial(){return new EN(this)}}class SN extends CN{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:(e=t,function t(e,n,r=new Map,s=new Set){if(null==e)return null;if(s.has(e))throw new Error("Circular references are not supported.");if(r.has(e))return r.get(e);const i=n(e);if(i.recurse&&null!==i.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(i.recurse){if(bN(e)){const i=Array.isArray(e)?[]:{};s.add(e);for(const o in e){const a=t(e[o],n,r,s);i[o]=a}return s.delete(e),i}throw new Error("Can't recurse into non-iterable type: "+e)}return r.set(e,i.value),i.value}(e,vN)),done:!1};var e}}class _N extends CN{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message="Error thrown while iterating through a dataset: "+t.message,t}}}class EN extends CN{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return this.upstream.summary()+" -> Serial"}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class kN extends CN{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return this.upstream.summary()+" -> Skip"}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;px(t.value)}return this.upstream.next()}}class AN extends CN{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return this.upstream.summary()+" -> Take"}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class IN extends CN{constructor(t,e,n=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return this.upstream.summary()+" -> RowMajorBatch"}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class NN extends CN{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return this.upstream.summary()+" -> Filter"}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;px(t.value)}}}class TN extends CN{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return this.upstream.summary()+" -> Map"}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=s.getTensorsInContainer(t.value),n=this.transform(t.value),r=s.getTensorsInContainer(n);for(const i of e)s.isTensorInList(i,r)||i.dispose();return{value:n,done:!1}}}class RN extends CN{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return this.upstream.summary()+" -> handleErrors"}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}}class $N extends CN{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return this.upstream.summary()+" -> AsyncMap"}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=s.getTensorsInContainer(t.value),n=await this.transform(t.value),r=s.getTensorsInContainer(n);for(const i of e)s.isTensorInList(i,r)||i.dispose();return{value:n,done:!1}}}class DN extends CN{constructor(){super(),this.outputQueue=new wN,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!(await this.pump()))return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class ON extends DN{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return this.upstream.summary()+" -> Flatmap"}async pump(){const t=await this.upstream.next();if(t.done)return!1;const e=s.getTensorsInContainer(t.value),n=this.transform(t.value),r=s.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(const i of e)s.isTensorInList(i,r)||i.dispose();return!0}}class FN extends CN{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}var MN;!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(MN||(MN={}));class LN extends CN{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new xN(e)}summary(){return this.upstream.summary()+" -> Prefetch"}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class PN extends LN{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=uw.alea(n||r.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(!e.done)return this.refill(),e;this.upstreamExhausted=!0}return{value:null,done:!0}}}class zN{constructor(){this.size=null}batch(t,e=!0){const n=this;let s;return r.assert(t>0,()=>"batchSize needs to be positive, but it is\n      "+t),s=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),BN(async()=>(await n.iterator()).columnMajorBatch(t,e,VN),s)}concatenate(t){const e=this;let n;return n=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,BN(async()=>(await e.iterator()).concatenate(await t.iterator()),n)}filter(t){const e=this;let n;return n=this.size===1/0?1/0:null,BN(async()=>(await e.iterator()).filter(e=>dx(()=>t(e))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return BN(async()=>(await e.iterator()).map(e=>dx(()=>t(e))),this.size)}mapAsync(t){const e=this;return BN(async()=>(await e.iterator()).mapAsync(t),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return BN(async()=>(await e.iterator()).prefetch(t),this.size)}repeat(t){const e=this;let n;return n=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,BN(async()=>{return n=(r=async()=>({value:await e.iterator(),done:!1}),new _N(r)).take(t),new FN(n,void 0);var n,r},n)}skip(t){const e=this;let n;return n=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,BN(async()=>(await e.iterator()).skip(t),n)}shuffle(t,e,n=!0){if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const s=this,i=uw.alea(e||r.now().toString());return BN(async()=>{let e=i.int32();return n&&(e+=i.int32()),(await s.iterator()).shuffle(t,e.toString())},this.size)}take(t){const e=this;let n;return n=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,BN(async()=>(await e.iterator()).take(t),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function BN(t,e=null){return new class extends zN{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function VN(t){return null===t?null:null==(e=t[0])||null===(n=e)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(e)||"object"==typeof e&&e instanceof qf||r.isTypedArray(e)?{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof qf?Ym(t):Am(t)}(t),recurse:!1}:{value:null,recurse:!0};var e,n}function UN(t,e,n,s){const i=r.getTypedArrayFromDType(s,r.sizeFromShape(n));for(let r=0;r<i.length;++r){const n=r*e;let s=t[n];for(let r=0;r<e;++r){const e=t[n+r];e>s&&(s=e)}i[r]=s}return i}function WN(t,e,n,s,i){const o=e.length,a=r.sizeFromShape(e),l=r.computeStrides(e),u=r.computeStrides(i),c=r.getTypedArrayFromDType(n,r.sizeFromShape(i));for(let h=0;h<a;++h){const e=r.indexToLoc(h,o,l),n=new Array(e.length);for(let t=0;t<n.length;t++)n[t]=e[s[t]];c[r.locToIndex(n,o,u)]=t[h]}return c}function jN(t,e){Array.isArray(t)||(t=[t]),t.forEach(t=>{null!=t&&r.assert("complex64"!==t.dtype,()=>e+" does not support complex64 tensors in the CPU backend.")})}function HN(t,e,n,r,s,i){const o=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,h=s.effectiveFilterWidth,d=s.padInfo.top,p=s.padInfo.left,f="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=jm(s.outShape,n),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],v=s.outShape[3];for(let x=0;x<s.batchSize;++x){const e=x*y,n=x*r[0];for(let m=0;m<s.inChannels;++m)for(let y=0;y<s.outHeight;++y){const x=y*o-d,w=Math.max(0,x),C=Math.min(s.inHeight,c+x),S=e+y*b;for(let e=0;e<s.outWidth;++e){const o=e*a-p,c=Math.max(0,o),d=Math.min(s.inWidth,h+o);let y=f,b=0,x=0;for(let e=w;e<C;e+=l){const s=n+e*r[1];for(let e=c;e<d;e+=u){const n=t[s+e*r[2]+m];"max"===i&&n>y?y=n:"avg"===i&&(b+=n,x++)}if(isNaN(y))break}g[S+e*v+m]="avg"===i?b/x:y}}}return m}function qN(t,e,n,r,s=!1,i=!1){const o=jm(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=jm(e,n,t);for(let g=0;g<r.batchSize;++g)for(let t=0;t<r.inChannels;++t)for(let e=0;e<r.outHeight;++e){const n=e*a-p;let y=n;for(;y<0;)y+=u;const b=Math.min(r.inHeight,h+n);for(let a=0;a<r.outWidth;++a){const h=a*l-f;let p=h;for(;p<0;)p+=c;const v=Math.min(r.inWidth,d+h);let x=Number.NEGATIVE_INFINITY,w=-1;for(let e=y;e<b;e+=u){const o=e-n;for(let n=p;n<v;n+=c){const a=n-h,l=m.get(g,e,n,t);l>x&&(x=l,w=s?i?((g*r.inHeight+e)*r.inWidth+n)*r.inChannels+t:(e*r.inWidth+n)*r.inChannels+t:o*d+a)}}o.set(w,g,e,a,t)}}return o}zN.MAX_BUFFER_SIZE=1e4,Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const GN=v.nonMaxSuppressionV3,KN=v.split,XN=v.tile,YN=v.topkImpl,ZN=v.whereImpl;function JN(t,e,n,r){if("linear"===n)return t.linear(e);if("relu"===n)return t.relu(e);if("elu"===n)return t.elu(e);if("relu6"===n)return t.relu6(e);if("prelu"===n)return t.prelu(e,r);throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}class QN extends WS{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new US(this,cx())}write(t,e,n){this.firstUse&&(this.firstUse=!1,Np().get("IS_NODE")&&b.warn("\n============================\nHi there \ud83d\udc4b. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const r={};return this.data.set(r,{values:t,dtype:n}),r}move(t,e,n,r){this.data.set(t,{values:e,dtype:r})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensors:n}=this.data.get(t);if("complex64"===e){const t=this.readSync(n.real.dataId),e=this.readSync(n.imag.dataId);return b.mergeRealAndImagArrays(t,e)}return this.data.get(t).values}bufferSync(t){const e=this.readSync(t.dataId);let n=e;if("string"===t.dtype)try{n=e.map(t=>r.decodeString(t))}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return jm(t.shape,t.dtype,n)}makeOutput(t,e,n){const r=this.write(t,e,n);return cx().makeTensorFromDataId(r,e,n,this)}disposeData(t){if(this.data.has(t)){const{complexTensors:e}=this.data.get(t);null!=e&&(e.real.dispose(),e.imag.dispose()),this.data.delete(t)}}async time(t){const e=r.now();return t(),{kernelMs:r.now()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}complex(t,e){const n=this.makeOutput(null,t.shape,"complex64");return this.data.get(n.dataId).complexTensors={real:cx().keep(t.clone()),imag:cx().keep(e.clone())},n}real(t){return this.data.get(t.dataId).complexTensors.real.clone()}imag(t){return this.data.get(t.dataId).complexTensors.imag.clone()}slice(t,e,n){if(jN(t,"slice"),o.isSliceContinous(t.shape,e,n)){const s=o.computeFlatOffset(e,t.strides),i=r.sizeFromShape(n);return Am(this.readSync(t.dataId).subarray(s,s+i),n,t.dtype)}const s=jm(n,t.dtype),i=this.bufferSync(t);for(let r=0;r<s.size;++r){const t=s.indexToLoc(r).map((t,n)=>t+e[n]);s.values[r]=i.get(...t)}return s.toTensor()}stridedSlice(t,e,n,r){jN(t,"stridedSlice");const s=o.computeOutShape(e,n,r);if(s.some(t=>0===t))return Am([],s);const i=jm(s,t.dtype),a=this.bufferSync(t);for(let o=0;o<i.size;o++){const t=i.indexToLoc(o),n=new Array(t.length);for(let s=0;s<n.length;s++)n[s]=t[s]*r[s]+e[s];i.set(a.get(...n),...t)}return i.toTensor()}diag(t){const e=this.readSync(t.dataId),n=jm([t.size,t.size],t.dtype),r=n.values;for(let s=0;s<e.length;s++)r[s*t.size+s]=e[s];return n.toTensor()}unstack(t,e){const n=t.shape[e],r=new Array(t.rank-1);let s=0;for(let l=0;l<t.rank;l++)l!==e&&(r[s++]=t.shape[l]);const i=new Array(t.rank).fill(0),o=t.shape.slice();o[e]=1;const a=new Array(n);for(let l=0;l<a.length;l++)i[e]=l,a[l]=this.slice(t,i,o).reshape(r);return a}reverse(t,e){jN(t,"reverse");const n=jm(t.shape,t.dtype),r=this.bufferSync(t);for(let s=0;s<n.size;s++){const i=n.indexToLoc(s),o=i.slice();e.forEach(e=>o[e]=t.shape[e]-1-o[e]),n.set(r.get(...o),...i)}return n.toTensor()}concat(t,e){if("complex64"===t[0].dtype){const n=t.map(t=>km(t)),r=t.map(t=>Em(t));return _m(this.concat(n,e),this.concat(r,e))}const n=t.map(t=>{const n=r.sizeFromShape(t.shape.slice(e));return t.as2D(-1,n)}),s=b.computeOutShape(n.map(t=>t.shape),1),i=jm(s,t[0].dtype).values;if(1===n[0].shape[0]){let t=0;n.forEach(e=>{i.set(this.readSync(e.dataId),t),t+=e.size})}else{let t=0;n.forEach(e=>{const n=this.readSync(e.dataId);let r=0;for(let o=0;o<e.shape[0];++o){const a=o*s[1]+t;for(let t=0;t<e.shape[1];++t)i[a+t]=n[r++]}t+=e.shape[1]})}const o=b.computeOutShape(t.map(t=>t.shape),e);return Am(i,o,t[0].dtype)}neg(t){return jN(t,"neg"),this.multiply(Nm(-1),t)}add(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(t,e,n,r)=>({real:t+n,imag:e+r})):this.broadcastedBinaryOp(t,e,tm(t.dtype,e.dtype),(t,e)=>t+e)}addN(t){jN(t,"addN");const e=t.map(t=>this.readSync(t.dataId)),n=jm(t[0].shape,t[0].dtype),r=n.values;for(let s=0;s<t.length;s++){const t=e[s];for(let e=0;e<r.length;e++)r[e]+=t[e]}return n.toTensor()}softmax(t,e){const n=r.parseAxisParam([e],t.shape),s=Gx(t,n),i=b.expandShapeToKeepDim(s.shape,n),o=this.subtract(t,s.reshape(i)),a=this.exp(o),l=this.sum(a,n).reshape(i);return tg(a,l)}subtract(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(t,e,n,r)=>({real:t-n,imag:e-r})):this.broadcastedBinaryOp(t,e,tm(t.dtype,e.dtype),(t,e)=>t-e)}pow(t,e){return jN([t,e],"pow"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.pow(t,e))}batchMatMul(t,e,n,r){jN([t,e],"matMul");const s=n?t.shape[1]:t.shape[2],i=n?t.shape[2]:t.shape[1],o=r?e.shape[1]:e.shape[2],a=t.shape[0],l=this.readSync(t.dataId),u=this.readSync(e.dataId),[c,h,d]=n?[t.strides[0],1,t.strides[1]]:[t.strides[0],t.strides[1],1],[p,f,m]=r?[1,e.strides[1],e.strides[0]]:[e.strides[1],1,e.strides[0]],g=i*o,y=jm([a,i,o],t.dtype),b=y.values,v=this.blockSize;for(let x=0;x<a;x++)for(let t=0;t<i;t+=v)for(let e=0;e<o;e+=v)for(let n=0;n<s;n+=v){const r=Math.min(t+v,i),a=Math.min(e+v,o),y=Math.min(n+v,s);for(let s=t;s<r;s++)for(let t=e;t<a;t++){let e=0;for(let r=n;r<y;r++)e+=l[x*c+s*h+r*d]*u[r*p+t*f+x*m];b[x*g+(s*o+t)]+=e}}return y.toTensor()}fusedBatchMatMul({a:t,b:e,transposeA:n,transposeB:r,bias:s,activation:i,preluActivationWeights:o}){let a=this.batchMatMul(t,e,n,r);return s&&(a=this.add(a,s)),i&&(a=JN(this,a,i,o)),a}multiply(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(t,e,n,r)=>({real:t*n-e*r,imag:t*r+e*n})):this.broadcastedBinaryOp(t,e,tm(t.dtype,e.dtype),(t,e)=>t*e)}floorDiv(t,e){return jN([t,e],"floorDiv"),this.broadcastedBinaryOp(t,e,"int32",(t,e)=>Math.floor(t/e))}sum(t,e){jN(t,"sum"),b.assertAxesAreInnerMostDims("sum",e,t.rank);const[n,s]=b.computeOutAndReduceShapes(t.shape,e),i=Pm(n,tm(t.dtype,"int32")),o=r.sizeFromShape(s),a=this.readSync(i.dataId),l=this.readSync(t.dataId);for(let r=0;r<a.length;++r){const t=r*o;let e=0;for(let n=0;n<o;++n)e+=l[t+n];a[r]=e}return i}prod(t,e){jN(t,"sum");const[n,s]=b.computeOutAndReduceShapes(t.shape,e),i=Pm(n,tm(t.dtype,"int32")),o=r.sizeFromShape(s),a=this.readSync(i.dataId),l=this.readSync(t.dataId);for(let r=0;r<a.length;++r){const t=r*o;let e=1;for(let n=0;n<o;++n)e*=l[t+n];a[r]=e}return i}unsortedSegmentSum(t,e,n){jN(t,"unsortedSegmentSum");const r=[],s=t.rank-e.rank;for(let i=0;i<s;++i)e=e.expandDims(i+1);for(let i=0;i<n;++i){const n=Nm(i,"int32"),s=Vx(n,e).asType("float32").mul(t).sum(0);r.push(s)}return Ym(r)}argMin(t,e){jN(t,"argMin");const n=[e];b.assertAxesAreInnerMostDims("argMin",n,t.rank);const[s,i]=b.computeOutAndReduceShapes(t.shape,n),o=Pm(s,"int32"),a=r.sizeFromShape(i),l=this.readSync(o.dataId),u=this.readSync(t.dataId);for(let r=0;r<l.length;++r){const t=r*a;let e=u[t],n=0;for(let r=0;r<a;++r){const s=u[t+r];s<e&&(e=s,n=r)}l[r]=n}return o}argMax(t,e){jN(t,"argMax");const n=[e];b.assertAxesAreInnerMostDims("argMax",n,t.rank);const[s,i]=b.computeOutAndReduceShapes(t.shape,n),o=Pm(s,"int32"),a=r.sizeFromShape(i),l=this.readSync(o.dataId),u=this.readSync(t.dataId);for(let r=0;r<l.length;++r){const t=r*a;let e=u[t],n=0;for(let r=0;r<a;++r){const s=u[t+r];s>e&&(e=s,n=r)}l[r]=n}return o}cumsum(t,e,n,r){if(jN(t,"cumsum"),e!==t.rank-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${t.rank-1} but got axis=`+e);const s=tm(t.dtype,"int32"),i=Pm(t.shape,s),o=this.readSync(i.dataId),a=this.readSync(t.dataId),l=t.shape[t.rank-1],u=r?(t,e)=>t+l-e-1:(t,e)=>t+e;for(let c=0;c<a.length;c+=l)for(let t=0;t<l;t++){const e=u(c,t);if(0===t)o[e]=n?0:a[e];else{const r=u(c,t-1);o[e]=n?a[r]+o[r]:a[e]+o[r]}}return i}equal(t,e){return jN([t,e],"equal"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t===e?1:0)}notEqual(t,e){return jN([t,e],"notEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t!==e?1:0)}less(t,e){return jN([t,e],"less"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t<e?1:0)}lessEqual(t,e){return jN([t,e],"lessEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t<=e?1:0)}greater(t,e){return jN([t,e],"greater"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t>e?1:0)}greaterEqual(t,e){return jN([t,e],"greaterEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t>=e?1:0)}logicalNot(t){jN(t,"logicalNot");const e=this.readSync(t.dataId),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n[r]=e[r]?0:1;return this.makeOutput(n,t.shape,"bool")}logicalAnd(t,e){return jN([t,e],"logicalAnd"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t&&e)}logicalOr(t,e){return jN([t,e],"logicalOr"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t||e)}select(t,e,n){jN([t,e,n],"select");const s=this.readSync(t.dataId),i=this.readSync(e.dataId),o=this.readSync(n.dataId),a=Pm(e.shape,tm(e.dtype,n.dtype)),l=this.readSync(a.dataId);let u=0;const c=0===t.rank||t.rank>1||1===e.rank?1:r.sizeFromShape(e.shape.slice(1));for(let r=0;r<s.length;r++)for(let t=0;t<c;t++)l[u++]=1===s[r]?i[r]:o[r];return a}where(t){jN([t],"where");const e=this.readSync(t.dataId);return ZN(t.shape,e)}topk(t,e,n){jN(t,"topk");const r=this.readSync(t.dataId);return YN(r,t.shape,t.dtype,e,n)}min(t,e){jN(t,"min"),b.assertAxesAreInnerMostDims("min",e,t.rank);const[n,s]=b.computeOutAndReduceShapes(t.shape,e),i=Pm(n,t.dtype),o=r.sizeFromShape(s),a=this.readSync(i.dataId),l=this.readSync(t.dataId);for(let r=0;r<a.length;++r){const t=r*o;let e=l[t];for(let n=0;n<o;++n){const r=l[t+n];r<e&&(e=r)}a[r]=e}return i}minimum(t,e){return jN([t,e],"minimum"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.min(t,e))}mod(t,e){return jN([t,e],"mod"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e})}maximum(t,e){return jN([t,e],"maximum"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.max(t,e))}all(t,e){jN(t,"all"),b.assertAxesAreInnerMostDims("all",e,t.rank);const[n,s]=b.computeOutAndReduceShapes(t.shape,e),i=Pm(n,t.dtype),o=r.sizeFromShape(s),a=this.readSync(i.dataId),l=this.readSync(t.dataId);for(let r=0;r<a.length;++r){const t=r*o;let e=l[t];for(let n=0;n<o;++n){const r=l[t+n];e=e&&r}a[r]=e}return i}any(t,e){jN(t,"any"),b.assertAxesAreInnerMostDims("any",e,t.rank);const[n,s]=b.computeOutAndReduceShapes(t.shape,e),i=Pm(n,t.dtype),o=r.sizeFromShape(s),a=this.readSync(i.dataId),l=this.readSync(t.dataId);for(let r=0;r<a.length;++r){const t=r*o;let e=l[t];for(let n=0;n<o;++n){const r=l[t+n];e=e||r}a[r]=e}return i}squaredDifference(t,e){return jN([t,e],"squaredDifference"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>{const n=t-e;return n*n})}ceil(t){jN(t,"ceil");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.ceil(e[r]);return this.makeOutput(n,t.shape,"float32")}floor(t){jN(t,"floor");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.floor(e[r]);return this.makeOutput(n,t.shape,"float32")}sign(t){jN(t,"x");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=e[r]<0?-1:e[r]>0?1:0;return this.makeOutput(n,t.shape,"float32")}isNaN(t){jN(t,"x");const e=this.readSync(t.dataId),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)Number.isNaN(e[r])&&(n[r]=1);return this.makeOutput(n,t.shape,"bool")}isInf(t){jN(t,"x");const e=this.readSync(t.dataId),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)Math.abs(e[r])===1/0&&(n[r]=1);return this.makeOutput(n,t.shape,"bool")}isFinite(t){jN(t,"x");const e=this.readSync(t.dataId),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)Number.isFinite(e[r])&&(n[r]=1);return this.makeOutput(n,t.shape,"bool")}round(t){jN(t,"round");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r){const t=Math.floor(e[r]);n[r]=e[r]-t<.5?Math.floor(e[r]):e[r]-t>.5?Math.ceil(e[r]):t%2==0?t:t+1}return this.makeOutput(n,t.shape,"float32")}exp(t){jN(t,"exp");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.exp(e[r]);return this.makeOutput(n,t.shape,"float32")}expm1(t){jN(t,"expm1");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.expm1(e[r]);return this.makeOutput(n,t.shape,"float32")}log(t){jN(t,"log");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.log(e[r]);return this.makeOutput(n,t.shape,"float32")}log1p(t){jN(t,"log1p");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.log1p(e[r]);return this.makeOutput(n,t.shape,"float32")}sqrt(t){jN(t,"sqrt");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.sqrt(e[r]);return this.makeOutput(n,t.shape,"float32")}rsqrt(t){jN(t,"rsqrt");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=1/Math.sqrt(e[r]);return this.makeOutput(n,t.shape,"float32")}reciprocal(t){jN(t,"reciprocal");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=1/e[r];return this.makeOutput(n,t.shape,"float32")}linear(t){return t}relu(t){jN(t,"relu");const e=Pm(t.shape,t.dtype),n=this.readSync(e.dataId),r=this.readSync(t.dataId);for(let s=0;s<r.length;++s)n[s]=Math.max(0,r[s]);return e}relu6(t){jN(t,"relu");const e=Pm(t.shape,t.dtype),n=this.readSync(e.dataId),r=this.readSync(t.dataId);for(let s=0;s<r.length;++s)n[s]=Math.min(Math.max(0,r[s]),6);return e}prelu(t,e){return jN([t,e],"prelu"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>t<0?e*t:t)}elu(t){jN(t,"elu");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r){const t=n[r];e[r]=t>=0?t:Math.exp(t)-1}return this.makeOutput(e,t.shape,"float32")}eluDer(t,e){jN([t,e],"eluDer");const n=new Float32Array(e.size),r=this.readSync(e.dataId),s=this.readSync(t.dataId);for(let i=0;i<r.length;++i){const t=r[i];n[i]=t>=1?s[i]:s[i]*(t+1)}return this.makeOutput(n,e.shape,"float32")}selu(t){jN(t,"selu");const e=b.SELU_SCALEALPHA,n=b.SELU_SCALE,r=new Float32Array(t.size),s=this.readSync(t.dataId);for(let i=0;i<s.length;++i){const t=s[i];r[i]=t>=0?n*t:e*(Math.exp(t)-1)}return this.makeOutput(r,t.shape,"float32")}clip(t,e,n){jN(t,"clip");const r=new Float32Array(t.size),s=this.readSync(t.dataId);for(let i=0;i<s.length;++i){const t=s[i];r[i]=t>n?n:t<e?e:t}return this.makeOutput(r,t.shape,"float32")}abs(t){const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.abs(n[r]);return this.makeOutput(e,t.shape,"float32")}complexAbs(t){const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<t.size;++r)e[r]=Math.hypot(n[2*r],n[2*r+1]);return this.makeOutput(e,t.shape,"float32")}int(t){jN(t,"int");const e=new Int32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=n[r];return this.makeOutput(e,t.shape,"int32")}sigmoid(t){jN(t,"sigmoid");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=1/(1+Math.exp(-n[r]));return this.makeOutput(e,t.shape,"float32")}softplus(t){jN(t,"softplus");const e=Math.log(1.1920928955078125e-7)+2,n=new Float32Array(t.size),r=this.readSync(t.dataId);for(let s=0;s<r.length;++s){const t=r[s]>-e,i=r[s]<e,o=Math.exp(r[s]);let a;a=i?o:t?r[s]:Math.log(1+o),n[s]=a}return this.makeOutput(n,t.shape,"float32")}sin(t){jN(t,"sin");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.sin(n[r]);return this.makeOutput(e,t.shape,"float32")}cos(t){jN(t,"cos");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.cos(n[r]);return this.makeOutput(e,t.shape,"float32")}tan(t){jN(t,"tan");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.tan(n[r]);return this.makeOutput(e,t.shape,"float32")}asin(t){jN(t,"asin");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.asin(n[r]);return this.makeOutput(e,t.shape,"float32")}acos(t){jN(t,"acos");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.acos(n[r]);return this.makeOutput(e,t.shape,"float32")}atan(t){jN(t,"atan");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.atan(n[r]);return this.makeOutput(e,t.shape,"float32")}atan2(t,e){return jN([t,e],"atan2"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.atan2(t,e))}sinh(t){jN(t,"sinh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.sinh(n[r]);return this.makeOutput(e,t.shape,"float32")}cosh(t){jN(t,"cosh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.cosh(n[r]);return this.makeOutput(e,t.shape,"float32")}tanh(t){jN(t,"tanh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let s=0;s<n.length;++s)e[s]=r.tanh(n[s]);return this.makeOutput(e,t.shape,"float32")}asinh(t){jN(t,"asinh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.asinh(n[r]);return this.makeOutput(e,t.shape,"float32")}acosh(t){jN(t,"acosh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.acosh(n[r]);return this.makeOutput(e,t.shape,"float32")}atanh(t){jN(t,"atanh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.atanh(n[r]);return this.makeOutput(e,t.shape,"float32")}erf(t){jN(t,"erf");const e=new Float32Array(t.size),n=this.readSync(t.dataId),r=b.ERF_P,s=b.ERF_A1,i=b.ERF_A2,o=b.ERF_A3,a=b.ERF_A4,l=b.ERF_A5;for(let u=0;u<n.length;++u){const t=Math.sign(n[u]),c=Math.abs(n[u]),h=1/(1+r*c);e[u]=t*(1-((((l*h+a)*h+o)*h+i)*h+s)*h*Math.exp(-c*c))}return this.makeOutput(e,t.shape,"float32")}step(t,e=0){jN(t,"step");const n=new Float32Array(t.size),r=this.readSync(t.dataId);for(let s=0;s<r.length;++s){const t=r[s];n[s]=isNaN(t)?NaN:t>0?1:e}return this.makeOutput(n,t.shape,"float32")}fusedConv2d({input:t,filter:e,convInfo:n,bias:r,activation:s,preluActivationWeights:i}){let o=this.conv2d(t,e,n);return r&&(o=this.add(o,r)),s&&(o=JN(this,o,s,i)),o}conv2d(t,e,n){jN([t,e],"conv2d");const r=n.filterHeight,s=n.filterWidth,i=n.dilationHeight,o=n.dilationWidth,a=n.padInfo.left,l=n.padInfo.top,u="channelsLast"===n.dataFormat,c=jm(n.outShape,t.dtype),h=t.strides[0],d=u?t.strides[1]:t.strides[2],p=u?t.strides[2]:1,f=u?1:t.strides[1],m=c.strides[0],g=u?c.strides[1]:c.strides[2],y=u?c.strides[2]:1,b=u?1:c.strides[1],v=this.readSync(t.dataId),x=this.readSync(e.dataId),w=c.values;for(let C=0;C<n.batchSize;++C){const t=C*h,u=C*m;for(let c=0;c<n.outHeight;++c){const h=u+c*g,m=c*n.strideHeight-l;for(let l=0;l<r;l++){const r=m+l*i;if(r<0||r>=n.inHeight)continue;const u=l*e.strides[0],c=t+r*d;for(let t=0;t<n.outWidth;++t){const r=h+t*y,i=t*n.strideWidth-a;for(let t=0;t<s;t++){const s=i+t*o;if(s<0||s>=n.inWidth)continue;const a=c+s*p;let l=u+t*e.strides[1];for(let t=0;t<n.inChannels;++t){const e=v[a+t*f];for(let t=0;t<n.outChannels;++t)w[r+t*b]+=e*x[l+t];l+=n.outChannels}}}}}}return c.toTensor()}conv3d(t,e,n){const r=n.filterDepth,s=n.filterHeight,i=n.filterWidth,o=n.dilationDepth,a=n.dilationHeight,l=n.dilationWidth,u=n.padInfo.front,c=n.padInfo.left,h=n.padInfo.top,d=jm(n.outShape,t.dtype),p=this.readSync(t.dataId),f=this.readSync(e.dataId),m=d.values;for(let g=0;g<n.batchSize;++g){const y=g*t.strides[0],b=g*d.strides[0];for(let g=0;g<n.outDepth;++g){const v=b+g*d.strides[1],x=g*n.strideDepth-u;for(let u=0;u<r;u++){const r=x+u*o;if(r<0||r>=n.inDepth)continue;const g=u*e.strides[0],b=y+r*t.strides[1];for(let o=0;o<n.outHeight;++o){const r=v+o*d.strides[2],u=o*n.strideHeight-h;for(let o=0;o<s;o++){const s=u+o*a;if(s<0||s>=n.inHeight)continue;const h=g+o*e.strides[1],d=b+s*t.strides[2];for(let t=0;t<n.outWidth;++t){const s=r+t*n.outChannels,o=t*n.strideWidth-c;for(let t=0;t<i;t++){const r=o+t*l;if(r<0||r>=n.inWidth)continue;const i=d+r*n.inChannels;let a=h+t*e.strides[2];for(let t=0;t<n.inChannels;++t){const e=p[i+t];for(let t=0;t<n.outChannels;++t)m[s+t]+=e*f[a+t];a+=n.outChannels}}}}}}}}return d.toTensor()}conv2dDerInput(t,e,n){jN([t,e],"conv2dDerInput");const r=jm(n.inShape,"float32"),s=r.values,i=this.readSync(t.dataId),o=this.readSync(e.dataId),[a,l,u]=e.strides,{batchSize:c,filterHeight:h,filterWidth:d,inChannels:p,inHeight:f,inWidth:m,outChannels:g,outHeight:y,outWidth:b,strideHeight:v,strideWidth:x,dataFormat:w}=n,C=h-1-n.padInfo.top,S=d-1-n.padInfo.left,_="channelsLast"===w,E=r.strides[0],k=_?r.strides[1]:r.strides[2],A=_?r.strides[2]:1,I=_?1:r.strides[1],N=t.strides[0],T=_?t.strides[1]:t.strides[2],R=_?t.strides[2]:1,$=_?1:t.strides[1];for(let D=0;D<c;++D)for(let t=0;t<p;++t)for(let e=0;e<f;++e){const n=e-C,r=Math.max(0,Math.ceil(n/v)),c=Math.min(y,(h+n)/v);for(let p=0;p<m;++p){const f=p-S,m=Math.max(0,Math.ceil(f/x)),y=Math.min(b,(d+f)/x);let w=0;for(let e=r;e<c;++e){const r=e*v-n;for(let n=m;n<y;++n){const s=N*D+T*e+R*n,c=a*(h-1-r)+l*(d-1-(n*x-f))+u*t;for(let t=0;t<g;++t)w+=i[s+$*t]*o[c+t]}}s[E*D+k*e+A*p+I*t]=w}}return r.toTensor()}conv3dDerInput(t,e,n){const r=jm(n.inShape,"float32"),s=r.values,[i,o,a,l]=r.strides,u=this.readSync(t.dataId),[c,h,d,p]=t.strides,f=this.readSync(e.dataId),[m,g,y,b]=e.strides,{batchSize:v,filterDepth:x,filterHeight:w,filterWidth:C,inChannels:S,inDepth:_,inHeight:E,inWidth:k,outChannels:A,outDepth:I,outHeight:N,outWidth:T,strideDepth:R,strideHeight:$,strideWidth:D}=n,O=x-1-n.padInfo.front,F=w-1-n.padInfo.top,M=C-1-n.padInfo.left;for(let L=0;L<v;++L)for(let t=0;t<S;++t)for(let e=0;e<_;++e){const n=e-O,r=Math.max(0,Math.ceil(n/R)),v=Math.min(I,(x+n)/R);for(let S=0;S<E;++S){const _=S-F,E=Math.max(0,Math.ceil(_/$)),I=Math.min(N,(w+_)/$);for(let N=0;N<k;++N){const k=N-M,O=Math.max(0,Math.ceil(k/D)),F=Math.min(T,(C+k)/D);let P=0;for(let e=r;e<v;++e){const r=e*R-n;for(let n=E;n<I;++n){const s=n*$-_;for(let i=O;i<F;++i){const o=c*L+h*e+d*n+p*i,a=m*(x-1-r)+g*(w-1-s)+y*(C-1-(i*D-k))+b*t;for(let t=0;t<A;++t)P+=u[o+t]*f[a+t]}}}s[i*L+o*e+a*S+l*N+t]=P}}}return r.toTensor()}conv2dDerFilter(t,e,n){jN([t,e],"conv2dDerFilter");const r=n.strideHeight,s=n.strideWidth,i=n.filterHeight,o=n.filterWidth,a="channelsLast"===n.dataFormat,l=jm(n.filterShape,"float32"),u=n.padInfo.left,c=n.padInfo.top,h=this.bufferSync(t),d=this.bufferSync(e);for(let p=0;p<i;++p){const t=Math.max(0,Math.ceil((c-p)/r)),e=Math.min(n.outHeight,(n.inHeight+c-p)/r);for(let i=0;i<o;++i){const o=Math.max(0,Math.ceil((u-i)/s)),f=Math.min(n.outWidth,(n.inWidth+u-i)/s);for(let m=0;m<n.inChannels;++m)for(let g=0;g<n.outChannels;++g){let y=0;for(let l=0;l<n.batchSize;++l)for(let n=t;n<e;++n){const t=p+n*r-c;for(let e=o;e<f;++e){const r=i+e*s-u;y+=a?h.get(l,t,r,m)*d.get(l,n,e,g):h.get(l,m,t,r)*d.get(l,g,n,e)}}l.set(y,p,i,m,g)}}}return l.toTensor()}conv3dDerFilter(t,e,n){const r=n.strideDepth,s=n.strideHeight,i=n.strideWidth,o=n.filterDepth,a=n.filterHeight,l=n.filterWidth,u=jm(n.filterShape,"float32"),c=u.values,[h,d,p,f]=u.strides,m=this.readSync(e.dataId),[g,y,b,v]=e.strides,x=this.readSync(t.dataId),[w,C,S,_]=t.strides,E=n.padInfo.front,k=n.padInfo.left,A=n.padInfo.top;for(let I=0;I<o;++I){const t=Math.max(0,Math.ceil((E-I)/r)),e=Math.min(n.outDepth,(n.inDepth+E-I)/r),o=I*h;for(let u=0;u<a;++u){const a=Math.max(0,Math.ceil((A-u)/s)),h=Math.min(n.outHeight,(n.inHeight+A-u)/s),N=u*d+o;for(let o=0;o<l;++o){const l=Math.max(0,Math.ceil((k-o)/i)),d=Math.min(n.outWidth,(n.inWidth+k-o)/i),T=o*p+N;for(let p=0;p<n.inChannels;++p){const N=p*f+T;for(let f=0;f<n.outChannels;++f){let T=0;for(let c=0;c<n.batchSize;++c){const n=c*w,N=c*g;for(let c=t;c<e;++c){const t=(I+c*r-E)*C+n,e=c*y+N;for(let n=a;n<h;++n){const r=(u+n*s-A)*S+t,a=n*b+e;for(let t=l;t<d;++t)T+=x[(o+t*i-k)*_+r+p]*m[t*v+a+f]}}}c[N+f]=T}}}}}return u.toTensor()}fusedDepthwiseConv2D({input:t,filter:e,convInfo:n,bias:r,activation:s,preluActivationWeights:i}){let o=this.depthwiseConv2D(t,e,n);return r&&(o=this.add(o,r)),s&&(o=JN(this,o,s,i)),o}depthwiseConv2D(t,e,n){jN([t,e],"depthwiseConv2D");const r=n.filterHeight,s=n.filterWidth,i=n.dilationHeight,o=n.dilationWidth,a=n.padInfo.left,l=n.padInfo.top,u=n.outChannels/n.inChannels,c=jm(n.outShape,t.dtype),h=this.readSync(t.dataId),d=this.readSync(e.dataId),p=c.values;for(let f=0;f<n.batchSize;++f){const m=f*t.strides[0],g=f*c.strides[0];for(let f=0;f<n.outHeight;++f){const y=g+f*c.strides[1],b=f*n.strideHeight-a;for(let a=0;a<r;++a){const r=b+a*i;if(r<0||r>=n.inHeight)continue;const f=a*e.strides[0],g=m+r*t.strides[1];for(let t=0;t<n.outWidth;++t){const r=y+t*c.strides[2],i=t*n.strideWidth-l;for(let t=0;t<s;++t){const s=i+t*o;if(s<0||s>=n.inWidth)continue;const a=g+s*n.inChannels;let l=r,c=f+t*e.strides[1];for(let t=0;t<n.inChannels;++t){const e=h[a+t];for(let t=0;t<u;++t)p[l+t]+=e*d[c+t];l+=u,c+=u}}}}}}return c.toTensor()}depthwiseConv2DDerInput(t,e,n){jN([t,e],"depthwiseConv2DDerInput");const r=jm(n.inShape,"float32"),s=r.values,[i,o,a]=r.strides,l=this.readSync(t.dataId),[u,c,h]=t.strides,d=this.readSync(e.dataId),[p,f,m]=e.strides,{batchSize:g,filterHeight:y,filterWidth:b,inChannels:v,inHeight:x,inWidth:w,outChannels:C,outHeight:S,outWidth:_,strideHeight:E,strideWidth:k}=n,A=y-1-n.padInfo.top,I=b-1-n.padInfo.left,N=C/v;for(let T=0;T<g;++T)for(let t=0;t<v;++t)for(let e=0;e<x;++e){const n=e-A,r=Math.max(0,Math.ceil(n/E)),g=Math.min(S,(y+n)/E);for(let v=0;v<w;++v){const x=v-I,w=Math.max(0,Math.ceil(x/k)),C=Math.min(_,(b+x)/k);let S=0;for(let e=r;e<g;++e){const r=e*E-n;for(let n=w;n<C;++n){const s=u*T+c*e+h*n,i=p*(y-1-r)+f*(b-1-(n*k-x))+m*t;for(let e=0;e<N;++e)S+=l[s+(t*N+e)]*d[i+e]}}s[i*T+o*e+a*v+t]=S}}return r.toTensor()}depthwiseConv2DDerFilter(t,e,n){jN([t,e],"depthwiseConv2DDerFilter");const r=n.strideHeight,s=n.strideWidth,i=n.filterHeight,o=n.filterWidth,a=jm(n.filterShape,"float32"),l=n.padInfo.left,u=n.padInfo.top,c=n.outChannels/n.inChannels,h=this.bufferSync(t),d=this.bufferSync(e);for(let p=0;p<i;++p){const t=Math.max(0,Math.ceil((u-p)/r)),e=Math.min(n.outHeight,(n.inHeight+u-p)/r);for(let i=0;i<o;++i){const o=Math.max(0,Math.ceil((l-i)/s)),f=Math.min(n.outWidth,(n.inWidth+l-i)/s);for(let m=0;m<n.outChannels;++m){const g=Math.trunc(m/c),y=m%c;let b=0;for(let a=0;a<n.batchSize;++a)for(let n=t;n<e;++n){const t=p+n*r-u;for(let e=o;e<f;++e)b+=h.get(a,t,i+e*s-l,g)*d.get(a,n,e,m)}a.set(b,p,i,g,y)}}}return a.toTensor()}tile(t,e){return jN(t,"tile"),XN(this.bufferSync(t),e)}pad(t,e,n){jN(t,"pad");const r=e.map((e,n)=>e[0]+t.shape[n]+e[1]),s=e.map(t=>t[0]),i=this.bufferSync(t),o=jm(r,t.dtype);0!==n&&o.values.fill(n);for(let a=0;a<t.size;a++){const t=i.indexToLoc(a),e=t.map((t,e)=>t+s[e]);o.set(i.get(...t),...e)}return o.toTensor()}gather(t,e,n){jN([t,e],"gather");const r=t.shape.slice(),s=this.readSync(e.dataId);r[n]=s.length;const i=jm(r,t.dtype),o=this.bufferSync(t);for(let a=0;a<i.size;++a){const t=i.indexToLoc(a),e=t.slice();e[n]=s[t[n]];const r=o.locToIndex(e);i.values[a]=o.values[r]}return i.toTensor()}batchToSpaceND(t,e,n){jN([t],"batchToSpaceND");const r=e.reduce((t,e)=>t*e),s=b.getReshaped(t.shape,e,r),i=b.getPermuted(s.length,e.length),o=b.getReshapedPermuted(t.shape,e,r),a=b.getSliceBeginCoords(n,e.length),l=b.getSliceSize(o,n,e.length);return Fy(t.reshape(s),i).reshape(o).slice(a,l)}spaceToBatchND(t,e,n){jN([t],"spaceToBatchND");const r=e.reduce((t,e)=>t*e),s=[[0,0]];s.push(...n);for(let u=1+e.length;u<t.shape.length;++u)s.push([0,0]);const i=t.pad(s),o=b.getReshaped(i.shape,e,r,!1),a=b.getPermuted(o.length,e.length,!1),l=b.getReshapedPermuted(i.shape,e,r,!1);return Fy(i.reshape(o),a).reshape(l)}maxPool(t,e){return jN(t,"maxPool"),HN(this.readSync(t.dataId),0,t.dtype,t.strides,e,"max").toTensor()}maxPoolBackprop(t,e,n,r){jN([e,n],"maxPoolBackprop");const s=this.readSync(e.dataId),i=jm(r.outShape,e.dtype,qN(s,e.shape,e.dtype,r).values),o=r.strideHeight,a=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=h-1-r.padInfo.left,p=c-1-r.padInfo.top,f=jm(e.shape,"float32"),m=this.bufferSync(t);for(let g=0;g<r.batchSize;++g)for(let t=0;t<r.inChannels;++t)for(let e=0;e<r.inHeight;++e)for(let n=0;n<r.inWidth;++n){const s=e-p,y=n-d;let b=0;for(let e=0;e<c;e+=l){const n=(s+e)/o;if(!(n<0||n>=r.outHeight||Math.floor(n)!==n))for(let s=0;s<h;s+=u){const o=(y+s)/a;if(o<0||o>=r.outWidth||Math.floor(o)!==o)continue;const l=c*h-1-i.get(g,n,o,t)===e*h+s?1:0;0!==l&&(b+=m.get(g,n,o,t)*l)}}f.set(b,g,e,n,t)}return f.toTensor()}avgPoolBackprop(t,e,n){jN([t,e],"avgPoolBackprop");const r=n.strideHeight,s=n.strideWidth,i=n.filterHeight,o=n.filterWidth,a=n.dilationHeight,l=n.dilationWidth,u=n.effectiveFilterHeight,c=n.effectiveFilterWidth,h=c-1-n.padInfo.left,d=u-1-n.padInfo.top,p=jm(e.shape,"float32"),f=1/(i*o),m=this.bufferSync(t);for(let g=0;g<n.batchSize;++g)for(let t=0;t<n.inChannels;++t)for(let e=0;e<n.inHeight;++e)for(let i=0;i<n.inWidth;++i){const o=e-d,y=i-h;let b=0;for(let e=0;e<u;e+=a){const i=(o+e)/r;if(!(i<0||i>=n.outHeight||Math.floor(i)!==i))for(let e=0;e<c;e+=l){const r=(y+e)/s;r<0||r>=n.outWidth||Math.floor(r)!==r||(b+=m.get(g,i,r,t))}}p.set(b*f,g,e,i,t)}return p.toTensor()}pool3d(t,e,n){jN(t,"pool3d");const r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left,m="max"===n?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=this.readSync(t.dataId),y=jm(e.outShape,t.dtype),b=y.values,v=e.outShape[1]*e.outShape[2]*e.outShape[3]*e.outShape[4],x=e.outShape[2]*e.outShape[3]*e.outShape[4],w=e.outShape[3]*e.outShape[4],C=e.outShape[4];for(let S=0;S<e.batchSize;++S){const y=S*v,_=S*t.strides[0];for(let v=0;v<e.inChannels;++v)for(let S=0;S<e.outDepth;++S){const E=S*r-d;let k=E;for(;k<0;)k+=o;const A=Math.min(e.inDepth,u+E),I=y+S*x;for(let r=0;r<e.outHeight;++r){const u=r*s-p;let d=u;for(;d<0;)d+=a;const y=Math.min(e.inHeight,c+u),x=I+r*w;for(let r=0;r<e.outWidth;++r){const s=r*i-f;let u=s;for(;u<0;)u+=l;const c=Math.min(e.inWidth,h+s),p=x+r*C;let w=m,S=0,E=0;for(let e=k;e<A;e+=o){const r=_+e*t.strides[1];for(let e=d;e<y;e+=a){const s=r+e*t.strides[2];for(let e=u;e<c;e+=l){const r=g[s+e*t.strides[3]+v];if("max"===n&&r>w?w=r:"avg"===n&&(S+=r,E++),isNaN(w))break}if(isNaN(w))break}if(isNaN(w))break}b[p+v]="avg"===n?S/E:w}}}}return y.toTensor()}avgPool3d(t,e){return jN(t,"avgPool3d"),this.pool3d(t,e,"avg").toFloat()}avgPool3dBackprop(t,e,n){jN([t,e],"avgPool3dBackprop");const r=n.strideDepth,s=n.strideHeight,i=n.strideWidth,o=n.filterDepth,a=n.filterHeight,l=n.filterWidth,u=n.dilationDepth,c=n.dilationHeight,h=n.dilationWidth,d=n.effectiveFilterDepth,p=n.effectiveFilterHeight,f=n.effectiveFilterWidth,m=d-1-n.padInfo.front,g=f-1-n.padInfo.left,y=p-1-n.padInfo.top,b=jm(e.shape,"float32"),v=1/(o*a*l),x=this.bufferSync(t);for(let w=0;w<n.batchSize;++w)for(let t=0;t<n.inChannels;++t)for(let e=0;e<n.inDepth;++e)for(let o=0;o<n.inHeight;++o)for(let a=0;a<n.inWidth;++a){const l=e-m,C=o-y,S=a-g;let _=0;for(let e=0;e<d;e+=u){const o=(l+e)/r;if(!(o<0||o>=n.outDepth||Math.floor(o)!==o))for(let e=0;e<p;e+=c){const r=(C+e)/s;if(!(r<0||r>=n.outHeight||Math.floor(r)!==r))for(let e=0;e<f;e+=h){const s=(S+e)/i;s<0||s>=n.outWidth||Math.floor(s)!==s||(_+=x.get(w,o,r,s,t))}}}b.set(_*v,w,e,o,a,t)}return b.toTensor()}maxPool3d(t,e){return jN(t,"maxPool3d"),this.pool3d(t,e,"max").toFloat()}maxPool3dPositions(t,e){const n=jm(e.outShape,"int32"),r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left,m=this.bufferSync(t);for(let g=0;g<e.batchSize;++g)for(let t=0;t<e.inChannels;++t)for(let y=0;y<e.outDepth;++y){const b=y*r-d;let v=b;for(;v<0;)v+=o;const x=Math.min(e.inDepth,u+b);for(let r=0;r<e.outHeight;++r){const u=r*s-p;let d=u;for(;d<0;)d+=a;const w=Math.min(e.inHeight,c+u);for(let s=0;s<e.outWidth;++s){const p=s*i-f;let C=p;for(;C<0;)C+=l;const S=Math.min(e.inWidth,h+p);let _=Number.NEGATIVE_INFINITY,E=-1;for(let e=v;e<x;e+=o){const n=e-b;for(let r=d;r<w;r+=a){const s=r-u;for(let i=C;i<S;i+=l){const o=i-p,a=m.get(g,e,r,i,t);a>=_&&(_=a,E=n*c*h+s*c+o)}}}n.set(E,g,y,r,s,t)}}}return n.toTensor()}maxPool3dBackprop(t,e,n,r){jN([e,n],"maxPool3dBackprop");const s=this.maxPool3dPositions(e,r),i=r.strideDepth,o=r.strideHeight,a=r.strideWidth,l=r.dilationDepth,u=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterDepth,d=r.effectiveFilterHeight,p=r.effectiveFilterWidth,f=h-1-r.padInfo.front,m=p-1-r.padInfo.left,g=d-1-r.padInfo.top,y=jm(e.shape,"float32"),b=this.bufferSync(s),v=this.bufferSync(t);for(let x=0;x<r.batchSize;++x)for(let t=0;t<r.inChannels;++t)for(let e=0;e<r.inDepth;++e)for(let n=0;n<r.inHeight;++n)for(let s=0;s<r.inWidth;++s){const w=e-f,C=n-g,S=s-m;let _=0;for(let e=0;e<h;e+=l){const n=(w+e)/i;if(!(n<0||n>=r.outDepth||Math.floor(n)!==n))for(let s=0;s<d;s+=u){const i=(C+s)/o;if(!(i<0||i>=r.outHeight||Math.floor(i)!==i))for(let o=0;o<p;o+=c){const l=(S+o)/a;if(l<0||l>=r.outWidth||Math.floor(l)!==l)continue;const u=h*d*p-1-b.get(x,n,i,l,t)===e*d*p+s*p+o?1:0;0!==u&&(_+=v.get(x,n,i,l,t)*u)}}}y.set(_,x,e,n,s,t)}return y.toTensor()}cast(t,e){return b.castTensor(t,e,this)}reshape(t,e){return b.reshapeTensor(t,e)}avgPool(t,e){return jN(t,"avgPool"),jN(t,"maxPool"),HN(this.readSync(t.dataId),0,t.dtype,t.strides,e,"avg").toTensor().toFloat()}resizeBilinear(t,e,n,s){jN(t,"resizeBilinear");const[i,o,a,l]=t.shape,u=this.readSync(t.dataId),c=new Float32Array(r.sizeFromShape([i,e,n,l])),h=[s&&e>1?o-1:o,s&&n>1?a-1:a],d=[s&&e>1?e-1:e,s&&n>1?n-1:n];let p=0;const f=h[0]/d[0],m=h[1]/d[1];for(let r=0;r<i;r++)for(let s=0;s<e;s++){const e=f*s,i=Math.floor(e),h=e-i,d=Math.min(o-1,Math.ceil(e)),g=r*t.strides[0]+i*t.strides[1],y=r*t.strides[0]+d*t.strides[1];for(let r=0;r<n;r++){const e=m*r,n=Math.floor(e),s=e-n,i=Math.min(a-1,Math.ceil(e)),o=g+n*t.strides[2],d=y+n*t.strides[2],f=g+i*t.strides[2],b=y+i*t.strides[2];for(let t=0;t<l;t++){const e=u[o+t],n=u[d+t],r=e+(u[f+t]-e)*s;c[p++]=r+(n+(u[b+t]-n)*s-r)*h}}}return Am(c,[i,e,n,l])}resizeBilinearBackprop(t,e,n){jN([t,e],"resizeBilinearBackprop");const[r,s,i,o]=e.shape,[,a,l]=t.shape,u=new Float32Array(r*s*i*o),c=[n&&a>1?s-1:s,n&&l>1?i-1:i],h=[n&&a>1?a-1:a,n&&l>1?l-1:l],d=c[0]/h[0],p=c[1]/h[1],f=this.readSync(t.dataId);let m=0;for(let g=0;g<r;g++){const t=g*e.strides[0];for(let n=0;n<a;n++){const r=n*d,a=Math.floor(r),c=Math.min(Math.ceil(r),s-1),h=t+a*e.strides[1],g=t+c*e.strides[1],y=r-a,b=1-y;for(let t=0;t<l;t++){const n=t*p,r=Math.floor(n),s=Math.min(Math.ceil(n),i-1),a=n-r,l=1-a,c=h+r*e.strides[2],d=h+s*e.strides[2],v=g+r*e.strides[2],x=g+s*e.strides[2],w=b*l,C=b*a,S=y*l,_=y*a;for(let t=0;t<o;t++){const e=f[m++];u[c+t]+=e*w,u[d+t]+=e*C,u[v+t]+=e*S,u[x+t]+=e*_}}}}return Dm(u,[r,i,s,o],e.dtype)}resizeNearestNeighbor(t,e,n,r){jN(t,"resizeNearestNeighbor");const[s,i,o,a]=t.shape,l=this.readSync(t.dataId),u=new Float32Array(s*e*n*a),c=[r&&e>1?i-1:i,r&&n>1?o-1:o],h=[r&&e>1?e-1:e,r&&n>1?n-1:n],d=c[0]/h[0],p=c[1]/h[1];let f=0;for(let m=0;m<s;m++){const s=m*t.strides[0];for(let c=0;c<e;c++){const e=d*c,h=s+Math.min(i-1,r?Math.round(e):Math.floor(e))*t.strides[1];for(let s=0;s<n;s++){const e=p*s,n=h+Math.min(o-1,r?Math.round(e):Math.floor(e))*t.strides[2];for(let t=0;t<a;t++)u[f++]=l[n+t]}}}return Am(u,[s,e,n,a],t.dtype)}resizeNearestNeighborBackprop(t,e,n){jN([t,e],"resizeNearestNeighborBackprop");const[r,s,i,o]=e.shape,[,a,l]=t.shape,u=new Float32Array(r*s*i*o),c=this.readSync(t.dataId),h=[n&&a>1?s-1:s,n&&l>1?i-1:i],d=[n&&a>1?a-1:a,n&&l>1?l-1:l],p=h[0]/d[0],f=h[1]/d[1],m=1/p,g=1/f,y=2*Math.ceil(m)+2,b=2*Math.ceil(g)+2;for(let v=0;v<r;v++){const r=v*e.strides[0];for(let h=0;h<s;h++){const d=r+h*e.strides[1],v=Math.floor(h*m),x=Math.floor(v-y/2);for(let m=0;m<i;m++){const v=d+m*e.strides[2],w=Math.floor(m*g),C=Math.floor(w-b/2);for(let e=0;e<o;e++){let o=0;for(let u=0;u<y;u++){const d=u+x;if(d<0||d>=a)continue;const g=r+d*t.strides[1],y=d*p;if(h===Math.min(s-1,n?Math.round(y):Math.floor(y)))for(let r=0;r<b;r++){const s=r+C;if(s<0||s>=l)continue;const a=g+s*t.strides[2],u=s*f;m===Math.min(i-1,n?Math.round(u):Math.floor(u))&&(o+=c[a+e])}}u[v+e]=o}}}}return Dm(u,e.shape,e.dtype)}batchNorm(t,e,n,r,s,i){jN([t,e,n,s,r],"batchNorm");const o=this.readSync(t.dataId),a=this.readSync(e.dataId),l=this.readSync(n.dataId),u=s?this.readSync(s.dataId):new Float32Array([1]),c=r?this.readSync(r.dataId):new Float32Array([0]),h=new Float32Array(o.length),d=c.length,p=u.length,f=l.length,m=a.length;let g=0,y=0,b=0,v=0;for(let x=0;x<o.length;++x)h[x]=c[g++]+(o[x]-a[y++])*u[b++]/Math.sqrt(l[v++]+i),g>=d&&(g=0),y>=m&&(y=0),b>=p&&(b=0),v>=f&&(v=0);return Dm(h,t.shape)}localResponseNormalization4D(t,e,n,r,s){jN(t,"localResponseNormalization4D");const i=t.shape[3],o=i-1,a=this.readSync(t.dataId),l=t.size,u=new Float32Array(l);function c(t){const n=t%i;let r=t-n+Math.max(0,n-e);const s=t-n+Math.min(n+e,o);let l=0;for(;r<=s;r++){const t=a[r];l+=t*t}return l}for(let h=0;h<l;h++){const t=c(h),e=a[h]*Math.pow(n+r*t,-s);u[h]=e}return Dm(u,t.shape)}LRNGrad(t,e,n,r,s,i,o){jN(t,"LRNGrad");const a=t.shape[3],l=this.readSync(t.dataId),u=this.readSync(e.dataId),c=this.readSync(n.dataId),h=new Float32Array(t.size),d=t.size;for(let p=0;p<d;p++){const t=p%a,e=p-t+Math.max(0,t-r),n=p-t+Math.min(a,t+r+1);let d=0;for(let r=e;r<n;r++)d+=Math.pow(u[r],2);d=i*d+s;for(let r=e;r<n;r++){let t=-2*i*o*u[r]*c[p]/d;p===r&&(t+=Math.pow(d,-o)),t*=l[p],h[r]+=t}}return Dm(h,t.shape)}multinomial(t,e,n,r){jN(t,"multinomial");const s=e?t:Jw(t),i=s.shape[0],o=s.shape[1],a=Pm([i,n],"int32"),l=this.readSync(a.dataId),u=this.readSync(s.dataId);for(let c=0;c<i;++c){const t=c*o,e=new Float32Array(o-1);e[0]=u[t];for(let n=1;n<e.length;++n)e[n]=e[n-1]+u[t+n];const s=uw.alea(r.toString()),i=c*n;for(let r=0;r<n;++r){const t=s();l[i+r]=e.length;for(let n=0;n<e.length;n++)if(t<e[n]){l[i+r]=n;break}}}return a}oneHot(t,e,n,r){jN(t,"oneHot");const s=new Float32Array(t.size*e);s.fill(r);const i=this.readSync(t.dataId);for(let o=0;o<t.size;++o)i[o]>=0&&i[o]<e&&(s[o*e+i[o]]=n);return Rm(s,[t.size,e],"int32")}nonMaxSuppression(t,e,n,r,s){jN(t,"nonMaxSuppression");const i=this.readSync(t.dataId),o=this.readSync(e.dataId);return GN(i,o,n,r,s)}fft(t){return this.fftBatch(t,!1)}ifft(t){return this.fftBatch(t,!0)}fftBatch(t,e){const n=t.shape[0],r=t.shape[1],s=jm(t.shape,"float32"),i=jm(t.shape,"float32"),o=km(t).as2D(n,r),a=Em(t).as2D(n,r);for(let l=0;l<n;l++){const t=o.slice([l,0],[1,r]),n=a.slice([l,0],[1,r]),u=_m(t,n),c=this.readSync(this.fftImpl(u,e).dataId);for(let e=0;e<r;e++){const t=b.getComplexWithIndex(c,e);s.values[l*r+e]=t.real,i.values[l*r+e]=t.imag}}return _m(s.toTensor(),i.toTensor()).as2D(n,r)}fftImpl(t,e){const n=t.as1D(),r=n.size;if(this.isExponentOf2(r)){let s=this.fftRadix2(n,r,e).as2D(t.shape[0],t.shape[1]);return e&&(s=_m(km(s).div(Nm(r)),Em(s).div(Nm(r)))),s}{const n=this.readSync(t.dataId),s=this.fourierTransformByMatmul(n,r,e),i=b.splitRealAndImagArrays(s);return _m(i.real,i.imag).as2D(t.shape[0],t.shape[1])}}isExponentOf2(t){return 0==(t&t-1)}fftRadix2(t,e,n){if(1===e)return t;const r=this.readSync(t.dataId),s=e/2,i=b.complexWithEvenIndex(r);let o=_m(i.real,i.imag).as1D();const a=b.complexWithOddIndex(r);let l=_m(a.real,a.imag).as1D();o=this.fftRadix2(o,s,n),l=this.fftRadix2(l,s,n);const u=b.exponents(e,n),c=_m(u.real,u.imag).mul(l),h=o.add(c),d=o.sub(c),p=km(h).concat(km(d)),f=Em(h).concat(Em(d));return _m(p,f).as1D()}fourierTransformByMatmul(t,e,n){const r=new Float32Array(2*e);for(let s=0;s<e;s++){let i=0,o=0;for(let r=0;r<e;r++){const a=b.exponent(s*r,e,n),l=b.getComplexWithIndex(t,r);i+=l.real*a.real-l.imag*a.imag,o+=l.real*a.imag+l.imag*a.real}n&&(i/=e,o/=e),b.assignToTypedArray(r,i,o,s)}return r}depthToSpace(t,e,n){r.assert("NHWC"===n,()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+n),r.assert(e>1,()=>"blockSize should be > 1 for depthToSpace, but was: "+e);const s=t.shape[0],i=t.shape[1],o=t.shape[2],a=t.shape[3],l=i*e,u=o*e,c=a/(e*e),h=this.readSync(t.dataId),d=new Float32Array(s*l*u*c);let p=0;for(let r=0;r<s;++r)for(let t=0;t<l;++t){const n=Math.floor(t/e),s=t%e;for(let t=0;t<u;++t){const l=Math.floor(t/e),u=(s*e+t%e)*c;for(let t=0;t<c;++t)d[p++]=h[t+u+a*(l+o*(n+i*r))]}}return Dm(d,[s,l,u,c])}broadcastedBinaryOp(t,e,n,r){const s=b.assertAndGetBroadcastShape(t.shape,e.shape),i=jm(s,n),o=this.readSync(t.dataId),a=this.readSync(e.dataId),l=b.getBroadcastDims(t.shape,s),u=b.getBroadcastDims(e.shape,s),c=i.values;if(l.length+u.length===0)for(let h=0;h<c.length;++h)c[h]=r(o[h%o.length],a[h%a.length]);else{const n=this.bufferSync(t),s=this.bufferSync(e);for(let h=0;h<c.length;++h){const d=i.indexToLoc(h),p=d.slice(-t.rank);l.forEach(t=>p[t]=0);const f=n.locToIndex(p),m=d.slice(-e.rank);u.forEach(t=>m[t]=0);const g=s.locToIndex(m);c[h]=r(o[f],a[g])}}return i.toTensor()}broadcastedBinaryComplexOp(t,e,n){const r=b.assertAndGetBroadcastShape(t.shape,e.shape),s=jm(r,"float32"),i=jm(r,"float32"),o=this.readSync(t.dataId),a=this.readSync(e.dataId),l=b.getBroadcastDims(t.shape,r),u=b.getBroadcastDims(e.shape,r),c=s.values,h=i.values;if(l.length+u.length===0)for(let d=0;d<c.length;d++){const t=d%o.length,e=d%a.length,r=n(o[2*t],o[2*t+1],a[2*e],a[2*e+1]);c[d]=r.real,h[d]=r.imag}else{const r=this.bufferSync(this.data.get(t.dataId).complexTensors.real),i=this.bufferSync(this.data.get(e.dataId).complexTensors.real);for(let d=0;d<c.length;d++){const p=s.indexToLoc(d),f=p.slice(-t.rank);l.forEach(t=>f[t]=0);const m=r.locToIndex(f),g=p.slice(-e.rank);u.forEach(t=>g[t]=0);const y=i.locToIndex(g),b=n(o[2*m],o[2*m+1],a[2*y],a[2*y+1]);c[d]=b.real,h[d]=b.imag}}return this.complex(s.toTensor(),i.toTensor())}split(t,e,n){return KN(t,e,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}cropAndResize(t,e,n,r,s,i){const[o,a,l,u]=t.shape,c=e.shape[0],[h,d]=r,p=jm([c,h,d,u],"float32"),f=this.readSync(e.dataId),m=this.readSync(n.dataId),g=this.readSync(t.dataId),y=t.strides,b=p.strides;for(let v=0;v<c;v++){const t=4*v,e=f[t],n=f[t+1],r=f[t+2],c=f[t+3],x=m[v];if(x>=o)continue;const w=h>1?(r-e)*(a-1)/(h-1):0,C=d>1?(c-n)*(l-1)/(d-1):0;for(let o=0;o<h;o++){const t=h>1?e*(a-1)+o*w:.5*(e+r)*(a-1);if(t<0||t>a-1)for(let e=0;e<d;e++)for(let t=0;t<u;t++)p.values[t+e*b[2]+o*b[1]+v*b[0]]=i;else if("bilinear"===s){const e=Math.floor(t),r=Math.ceil(t),s=t-e;for(let t=0;t<d;t++){const a=d>1?n*(l-1)+t*C:.5*(n+c)*(l-1);if(a<0||a>l-1){for(let e=0;e<u;e++)p.values[e+t*b[2]+o*b[1]+v*b[0]]=i;continue}const h=Math.floor(a),f=Math.ceil(a),m=a-h;for(let n=0;n<u;n++){let i=n+h*y[2]+e*y[1]+x*y[0];const a=g[i];i=n+f*y[2]+e*y[1]+x*y[0];const l=g[i];i=n+h*y[2]+r*y[1]+x*y[0];const u=g[i];i=n+f*y[2]+r*y[1]+x*y[0];const c=g[i],d=a+(l-a)*m;i=n+t*b[2]+o*b[1]+v*b[0],p.values[i]=d+(u+(c-u)*m-d)*s}}}else for(let e=0;e<d;++e){const r=d>1?n*(l-1)+e*C:.5*(n+c)*(l-1);if(r<0||r>l-1){for(let t=0;t<u;t++)p.values[t+e*b[2]+o*b[1]+v*b[0]]=i;continue}const s=Math.round(r),a=Math.round(t);for(let t=0;t<u;t++)p.values[t+e*b[2]+o*b[1]+v*b[0]]=g[t+s*y[2]+a*y[1]+x*y[0]]}}}return p.toTensor()}sparseToDense(t,e,n,r){const{sliceRank:s,numUpdates:i,sliceSize:o,strides:a,outputSize:l}=b.calculateShapes(e,t,n);return this.scatter(t,e,n,l,o,i,s,a,r,!1)}gatherND(t,e){const n=e.shape,r=n[n.length-1],[s,i,o,a]=b.prepareAndValidate(t,e);if(0===i)return Am([],s,t.dtype);const l=new Uf([i,o],t.dtype),u=this.readSync(e.dataId),c=this.readSync(t.dataId);for(let h=0;h<i;h++){const e=[];let n=0;for(let t=0;t<r;t++){const s=u[h*r+t];n+=s*a[t],e.push(s)}if(n<0||n>=t.size/o)throw new Error(`Invalid indices: ${e} does not index into ${t.shape}`);for(let t=0;t<o;t++)l.values[h*o+t]=c[n*o+t]}return l.toTensor().reshape(s)}scatterND(t,e,n){const{sliceRank:r,numUpdates:s,sliceSize:i,strides:o,outputSize:a}=b.calculateShapes(e,t,n),l=Nm(0);return this.scatter(t,e,n,a,i,s,r,o,l,!0)}fill(t,e,n){n=n||r.inferDtype(e);const s=r.getArrayFromDType(n,r.sizeFromShape(t));return s.fill(e),cx().makeTensor(s,t,n,this)}onesLike(t){if("string"===t.dtype)throw new Error("onesLike is not supported for string tensors");return this.fill(t.shape,1,t.dtype)}zerosLike(t){const e=r.getArrayFromDType(t.dtype,r.sizeFromShape(t.shape));return this.makeOutput(e,t.shape,t.dtype)}linspace(t,e,n){return b.linspaceImpl(t,e,n)}scatter(t,e,n,r,s,i,o,a,l,u){const c=[r/s,s],h=this.readSync(t.dataId),d=this.readSync(e.dataId);if(0===r)return Am([],n,e.dtype);const p=new Uf(c,e.dtype);p.values.fill(this.readSync(l.dataId)[0]);for(let f=0;f<i;f++){const t=[];let i=0;for(let e=0;e<o;e++){const n=h[f*o+e];t.push(n),i+=n*a[e]}if(i<0||i>=r/s)throw new Error(`Invalid indices: ${t} does not index into ${n}`);for(let n=0;n<s;n++)u?p.values[i*s+n]+=d[f*s+n]:p.values[i*s+n]=0===e.rank?d[0]:d[f*s+n]}return p.toTensor().reshape(n)}}function tT(t,e){return{kernelName:t,backendName:"cpu",kernelFunc:({inputs:n,backend:r})=>{const{a:s,b:i}=n,o=r;jN([s,i],t);const a=o.data.get(s.dataId).values,l=o.data.get(i.dataId).values,[u,c]=e(s.shape,i.shape,a,l,s.dtype);return{dataId:o.write(u,c,s.dtype),shape:c,dtype:s.dtype}}}}function eT(t){return(e,n,s,i,o)=>{const a=b.assertAndGetBroadcastShape(e,n),l=a.length,u=r.computeStrides(a),c=r.sizeFromShape(a),h=r.getTypedArrayFromDType(o,c),d=e.length,p=n.length,f=r.computeStrides(e),m=r.computeStrides(n),g=b.getBroadcastDims(e,a),y=b.getBroadcastDims(n,a);if(g.length+y.length===0)for(let r=0;r<h.length;++r)h[r]=t(s[r%s.length],i[r%i.length]);else for(let b=0;b<h.length;++b){const e=r.indexToLoc(b,l,u),n=e.slice(-d);g.forEach(t=>n[t]=0);const o=r.locToIndex(n,d,f),a=e.slice(-p);y.forEach(t=>a[t]=0);const c=r.locToIndex(a,p,m);h[b]=t(s[o],i[c])}return[h,a]}}const nT=tT("Div",eT((t,e)=>t/e)),rT={kernelName:"Max",backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{reductionIndices:i}=e,o=n;let a=s.shape;const l=a.length;let u=r.parseAxisParam(i,a);const c=b.getAxesPermutation(u,l);let h=o.data.get(s.dataId).values;if(null!=c){const t=new Array(l);for(let e=0;e<t.length;e++)t[e]=a[c[e]];h=WN(h,a,s.dtype,c,t),u=b.getInnerMostAxes(u.length,l),a=t}jN(s,"max"),b.assertAxesAreInnerMostDims("max",u,l);const[d,p]=b.computeOutAndReduceShapes(a,u),f=UN(h,r.sizeFromShape(p),d,s.dtype);return{dataId:o.write(f,d,s.dtype),shape:d,dtype:s.dtype}}},sT={kernelName:"MaxPoolWithArgmax",backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:i,strides:o,pad:a,includeBatchInIndex:l}=e,u=n;jN(s,"MaxPoolWithArgmax");const c=u.data.get(s.dataId).values,h=b.computePool2DInfo(s.shape,i,o,[1,1],a),[d,p]=function(t,e,n,s,i){const o=HN(t,0,n,r.computeStrides(e),i,"max"),a=qN(t,e,n,i,!0,s);return[o.values,a.values]}(c,s.shape,s.dtype,l,h),f=u.write(d,h.outShape,s.dtype),m=u.write(p,h.outShape,s.dtype);return[{dataId:f,shape:h.outShape,dtype:s.dtype},{dataId:m,shape:h.outShape,dtype:"int32"}]}},iT=v.nonMaxSuppressionV5,oT=[{kernelName:"NonMaxSuppressionV5",backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}=n,u=e;jN(r,"NonMaxSuppressionWithScore");const c=u.data.get(r.dataId).values,h=u.data.get(s.dataId).values,d=i,p=o,f=a,m=l,{selectedIndices:g,selectedScores:y}=iT(c,h,d,p,f,m);return[g,y]}},{kernelName:"Square",backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e;jN(n,"square");const s=r.data.get(n.dataId).values,i=new Float32Array(s.length);for(let o=0;o<s.length;++o){const t=s[o];i[o]=t*t}return{dataId:r.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},tT("SquaredDifference",eT((t,e)=>{const n=t-e;return n*n})),nT,{kernelName:"Transpose",backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{perm:s}=e,i=n;jN(r,"transpose");const o=new Array(r.shape.length);for(let l=0;l<o.length;l++)o[l]=r.shape[s[l]];const a=WN(i.data.get(r.dataId).values,r.shape,r.dtype,s,o);return{dataId:i.write(a,o,r.dtype),shape:o,dtype:r.dtype}}},sT,rT];for(const CF of oT)zp(CF);mx("cpu",()=>new QN,1);const aT={},lT={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function uT(t){t in aT||(aT[t]=function(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=function(t){if("undefined"!=typeof OffscreenCanvas&&2===t)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);return e.addEventListener("webglcontextlost",e=>{e.preventDefault(),delete aT[t]},!1),1===t?e.getContext("webgl",lT)||e.getContext("experimental-webgl",lT):e.getContext("webgl2",lT)}(t));const e=aT[t];return e.isContextLost()?(delete aT[t],uT(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),aT[t])}var cT,hT,dT;function pT(t,e){return[e,t]}function fT(t){const e=r.sizeFromShape(t),n=Math.ceil(e/4);return r.sizeToSquarishShape(n)}function mT(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function gT(t,e){const n=t;let r,s,i,o,a,l,u,c,h,d;return 2===Np().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,i=n.RGBA16F,o=n.RGBA32F,a=n.RED,u=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT):(r=t.RGBA,s=t.RGBA,i=t.RGBA,o=n.RGBA,a=t.RGBA,u=4,c=4,h=null!=e?e.HALF_FLOAT_OES:null,d=t.FLOAT),l=t.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function yT(t,e,n){const r=n();return e&&function(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+function(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+e}}(t,e))}(t),r}function bT(t){return!!(Np().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function vT(t,e,n){return kT(t,e,()=>t.getExtension(n),'Extension "'+n+'" not supported on this browser.')}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(cT||(cT={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(hT||(hT={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(dT||(dT={}));const xT=/ERROR: [0-9]+:([0-9]+):/g;function wT(t,e,n){if(yT(t,e,()=>t.validateProgram(n)),!1===t.getProgramParameter(n,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function CT(t,e,n,r,s,i,o,a){const l=t.getAttribLocation(n,r);return-1!==l&&(yT(t,e,()=>t.bindBuffer(t.ARRAY_BUFFER,s)),yT(t,e,()=>t.vertexAttribPointer(l,i,t.FLOAT,!1,o,a)),yT(t,e,()=>t.enableVertexAttribArray(l)),!0)}function ST(t,e,n,r){yT(t,e,()=>t.bindFramebuffer(t.FRAMEBUFFER,r)),yT(t,e,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0))}function _T(t,e,n){yT(t,e,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),yT(t,e,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function ET(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+e}}(t,e))}function kT(t,e,n,r){const s=yT(t,e,()=>n());if(null==s)throw new Error(r);return s}function AT(t,e=2){return r.sizeFromShape(t.slice(0,t.length-e))}function IT(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function NT(t){let e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[AT(t),...IT(t)]),e}function TT(t){return t%2==0}function RT(t,e){if(t=t.slice(-2),e=e.slice(-2),r.arraysEqual(t,e))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){const n=t.slice(-1)[0],r=e.slice(-1)[0];if(n===r)return!0;if(TT(n)&&TT(r)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&TT(t[0])&&TT(e[0])}let $T,DT;function OT(t,e){return null!=t.getExtension(e)}function FT(t){try{if(null!=uT(t))return!0}catch(e){return!1}return!1}function MT(t){const e=gT(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const s=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(r),s}const LT=Np();LT.registerFlag("HAS_WEBGL",()=>LT.getNumber("WEBGL_VERSION")>0),LT.registerFlag("WEBGL_VERSION",()=>FT(2)?2:FT(1)?1:0),LT.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===LT.get("WEBGL_VERSION")),LT.registerFlag("WEBGL_CPU_FORWARD",()=>!0),LT.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),LT.registerFlag("WEBGL_PACK",()=>LT.getBool("HAS_WEBGL")),LT.registerFlag("WEBGL_PACK_NORMALIZATION",()=>LT.getBool("WEBGL_PACK")),LT.registerFlag("WEBGL_PACK_CLIP",()=>LT.getBool("WEBGL_PACK")),LT.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>!1),LT.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>LT.getBool("WEBGL_PACK")),LT.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>LT.getBool("WEBGL_PACK")),LT.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>LT.getBool("WEBGL_PACK")),LT.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>LT.getBool("WEBGL_PACK")),LT.registerFlag("WEBGL_PACK_REDUCE",()=>LT.getBool("WEBGL_PACK")),LT.registerFlag("WEBGL_LAZILY_UNPACK",()=>LT.getBool("WEBGL_PACK")),LT.registerFlag("WEBGL_CONV_IM2COL",()=>LT.getBool("WEBGL_PACK")),LT.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(t){if(null==$T){const e=uT(t);$T=e.getParameter(e.MAX_TEXTURE_SIZE)}return $T}(LT.getNumber("WEBGL_VERSION"))),LT.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(t){if(null==DT){const e=uT(t);DT=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,DT)}(LT.getNumber("WEBGL_VERSION"))),LT.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=LT.getNumber("WEBGL_VERSION");return 0===t?0:function(t){if(0===t)return 0;let e;const n=uT(t);return e=OT(n,"EXT_disjoint_timer_query_webgl2")&&2===t?2:OT(n,"EXT_disjoint_timer_query")?1:0,e}(t)}),LT.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>LT.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!i.isMobile()),LT.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(t){if(0===t)return!1;const e=uT(t);if(1===t){if(!OT(e,"OES_texture_float"))return!1}else if(!OT(e,"EXT_color_buffer_float"))return!1;return MT(e)}(LT.getNumber("WEBGL_VERSION"))),LT.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!LT.getBool("WEBGL_FORCE_F16_TEXTURES")&&LT.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),LT.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function(t){if(0===t)return!1;const e=uT(t);if(1!==t){if(OT(e,"EXT_color_buffer_float"))return MT(e);const t="EXT_color_buffer_half_float";if(OT(e,t)){const n=e.getExtension(t);return function(t,e){const n=gT(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(s),i}(e,n)}return!1}return!!OT(e,"OES_texture_float")&&!!OT(e,"WEBGL_color_buffer_float")&&MT(e)}(LT.getNumber("WEBGL_VERSION"))),LT.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(t=LT.getNumber("WEBGL_VERSION"))&&null!=uT(t).fenceSync;var t}),LT.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>LT.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);class PT{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((t,e)=>"T"+e);const n=[];this.variableNames.forEach(t=>{n.push(`float v${t} = get${t}AtOutCoords();`)});const r=this.variableNames.map(t=>"v"+t).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class zT{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((t,e)=>"T"+e);const n=[];this.variableNames.forEach(t=>{n.push(`vec4 v${t} = get${t}AtOutCoords();`)});const r=this.variableNames.map(t=>"v"+t).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}class BT{constructor(t,e,n){this.variableNames=["A"];const r=t.windowSize,s=t.batchSize,i=Math.ceil(t.inSize/r);n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}function VT(t,e){return["x","y","z","w","u","v"].slice(0,e).map(e=>`${t}.${e}`)}function UT(t,e){return 1===e?[t]:VT(t,e)}function WT(){let t,e,n,r,s,i,o,a,l,u;return 2===Np().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",r="in",s="texture",i="outputColor",o="out vec4 outputColor;",a="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",r="varying",s="texture2D",i="gl_FragColor",o="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:s,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}function jT(t,e,n="index"){const s=r.computeStrides(e);return s.map((e,r)=>`int ${t[r]} = ${n} / ${e}; ${r===s.length-1?`int ${t[r+1]} = ${n} - ${t[r]} * ${e}`:`index -= ${t[r]} * ${e}`};`).join("")}function HT(t){const e=r.computeStrides(t).map(t=>t.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;\n  }\n`}const qT="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:GT}=b;const KT="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",XT="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",YT="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",ZT="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function JT(t){return"offset"+t}function QT(t){const e=t.name,n=r.sizeFromShape(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${e}[i];\n      }\n    }\n  `}function tR(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function eR(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function nR(t,e){return e.map(e=>t[e]).join(", ")}class rR{constructor(t,e,n,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,r.assert(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const i=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const o=this.outputShape,a=o.length,l=tR(a),u=UT("coords",a);let c,h;if(1===i){h=a+1;const t=tR(h);c=`\n        ${t} sourceLocR = ${t}(${u.join()}, 0);\n        ++${u[a-1]};\n        ${t} sourceLocG = ${t}(${u.join()}, 0);\n        ++${u[a-2]};\n        ${t} sourceLocA = ${t}(${u.join()}, 0);\n        --${u[a-1]};\n        ${t} sourceLocB = ${t}(${u.join()}, 0);\n        --${u[a-2]};`}else h=a,c=`\n        ${l} sourceLocR = coords;\n        ++${u[a-1]};\n        ${l} sourceLocG = coords;\n        ++${u[a-2]};\n        ${l} sourceLocA = coords;\n        --${u[a-1]};\n        ${l} sourceLocB = coords;\n        --${u[a-2]};`;const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map(t=>"int "+t),m=UT("sourceLocR",h-1).concat("inIdx.r"),g=UT("sourceLocG",h-1).concat("inIdx.g"),y=UT("sourceLocB",h-1).concat("inIdx.b"),b=UT("sourceLocA",h-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,C=s?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${C}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[a-1]} < ${o[a-1]-1};\n        bool hasNextRow = ${u[a-2]} < ${o[a-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}class sR{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.effectiveFilterHeight,n=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class iR{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.effectiveFilterDepth,n=t.effectiveFilterHeight,r=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${e};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${r};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class oR{constructor(t,e,n,r,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],b.assertAndGetBroadcastShape(t,e),b.assertAndGetBroadcastShape(t,n);let o="0.0";null!=r&&(b.assertAndGetBroadcastShape(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let a="1.0";null!=s&&(b.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${a};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class aR{constructor(t,e,n,r,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],b.assertAndGetBroadcastShape(t,e),b.assertAndGetBroadcastShape(t,n);let o="vec4(0.0)";null!=r&&(b.assertAndGetBroadcastShape(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let a="vec4(1.0)";null!=s&&(b.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${a};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}class lR{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=b.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const uR="return a + b;",cR="return a - b;",hR="return a * b;",dR="return (a < 0.) ? b * a : a;";class pR{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=b.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const fR="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";class mR{constructor(t,e,n,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=b.assertAndGetBroadcastShape(e,n);const i=this.outputShape.length;let o="";if(s)if(0===i||1===r.sizeFromShape(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(o=`\n          ${tR(i)} coords = getOutputCoords();\n        `,1===i)o+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const t=UT("coords",i);o+=`\n            bool nextRowOutOfBounds =\n              (${t[i-2]} + 1) >= ${this.outputShape[i-2]};\n            bool nextColOutOfBounds =\n              (${t[i-1]} + 1) >= ${this.outputShape[i-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${o}\n\n        setOutput(result);\n      }\n    `}}class gR{constructor(t){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(t,e){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}class yR{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(t,e){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}class bR{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}class vR{constructor(t){this.outputShape=[],this.outputShape=b.computeOutShape(t,1),this.variableNames=t.map((t,e)=>"T"+e);const e=new Array(t.length-1);e[0]=t[0][1];for(let r=1;r<e.length;r++)e[r]=e[r-1]+t[r][1];const n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let r=1;r<e.length;r++)n.push(`else if (yC < ${e[r]}) setOutput(getT${r}(yR, yC-${e[r-1]}));`);n.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class xR{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=b.computeOutShape(t,e);const n=this.outputShape,r=n.length,s=tR(r),i=UT("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((t,e)=>"T"+e);const a=new Array(t.length-1);a[0]=t[0][e];for(let p=1;p<a.length;p++)a[p]=a[p-1]+t[p][e];const l=o[e],u=o.slice(-2),c=o.join();let h=`if (${l} < ${a[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let p=1;p<a.length;p++){const t=a[p-1];h+=`\n        if (${l} < ${a[p]}  && ${l} >= ${a[p-1]}) {\n          return getChannel(\n            getT${p}(${wR(o,l,t)}),\n            vec2(${wR(u,l,t)}));\n        }`}const d=a[a.length-1];h+=`\n        return getChannel(\n          getT${a.length}(${wR(o,l,d)}),\n          vec2(${wR(u,l,d)}));`,this.userCode=`\n      float getValue(${o.map(t=>"int "+t)}) {\n        ${h}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[r-1]} = ${i[r-1]} + 1;\n        if (${i[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[r-2]} = ${i[r-2]} + 1;\n        if (${i[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[r-1]} = ${i[r-1]} - 1;\n        if (${i[r-2]} < ${n[r-2]} &&\n            ${i[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function wR(t,e,n){const r=t.indexOf(e);return t.map((t,e)=>e===r?`${t} - ${n}`:t).join()}class CR{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===t.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class SR{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${r?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${r?1:2}], coords[${r?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${r}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class _R{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ER{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class kR{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class AR{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${r}; dm++) {\n              int d2 = d1 * ${r} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class IR{constructor(t,e=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const s=t.padInfo.top,i=t.padInfo.left,o=t.strideHeight,a=t.strideWidth,l=t.dilationHeight,u=t.dilationWidth,c=t.filterHeight,h=t.filterWidth,d=4*Math.floor(t.inChannels/4),p=t.inChannels%4,f="channelsLast"===t.dataFormat,m=f?1:2,g=f?2:3,y=f?3:1;let b="",v="";n&&(b=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,v="result = activation(result);");const x=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${b}\n\n      const ivec2 strides = ivec2(${o}, ${a});\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${m}], coords[${g}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${c}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${u};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${d}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${f}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===p}) {\n\n              if (${f}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${d}) *\n                    getW(wR, wC, ${d}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${d}, xR, xC) *\n                    getW(wR, wC, ${d}, d2);\n              }\n\n            } else if (${2===p}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2)\n              );\n\n              if (${f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===p}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2),\n                getW(wR, wC, ${d} + 2, d2)\n              );\n\n              if (${f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1),\n                  getX(batch, xR, xC, ${d} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC),\n                  getX(batch, ${d} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${x}\n        ${v}\n        setOutput(result);\n      }\n    `}}class NR{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,s=t.strideDepth,i=t.strideHeight,o=t.strideWidth,a=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,c=t.filterDepth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${i}, ${o});\n      const ivec3 pads = ivec3(${e}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${a};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class TR{constructor(t,e=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const s=t.inHeight,i=t.inWidth,o=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,h=t.dilationWidth,d=t.filterHeight,p=t.filterWidth,f=t.outChannels/t.inChannels;let m="",g="";n&&(m=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,g="result = activation(result);");const y=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${m}\n\n      const ivec2 strides = ivec2(${l}, ${u});\n      const ivec2 pads = ivec2(${o}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${f};\n        int q = d2 - d1 * ${f};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${s}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${h};\n\n            if (xC < 0 || xC >= ${i}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${y}\n        ${g}\n        setOutput(result);\n      }\n    `}}class RR{constructor(t,e=!1,n=null,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.outShape;const i=t.inHeight,o=t.inWidth,a=t.padInfo.top,l=t.padInfo.left,u=t.strideHeight,c=t.strideWidth,h=t.dilationHeight,d=t.dilationWidth,p=t.filterHeight,f=t.filterWidth,m=f;let g="int xR; int xC; int xCOffset;";for(let r=0;r<p;r++)for(let t=0;t<f;t++)g+=`\n          vec4 xTexelR${r}C${2*t} = vec4(0.);\n          vec4 wR${r}C${t} = vec4(0.);\n          vec4 xR${r}C${t} = vec4(0.);`;for(let x=0;x<p;x++)for(let t=0;t<m;t++){const e=2*t;if(g+=`\n          xR = xRCorner + ${x*h};\n          xC = xCCorner + ${e*d};\n        `,1===c){if(e<f&&(g+=l%2==1?`\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${i} && xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${x}C${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${o}) {\n                    xTexelR${x}C${e}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${x}C${e} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${i} && xCOffset >= 0 && xCOffset < ${o}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${o}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${x}C${e} = vec4(previous.zw, xTexelR${x}C${e}.xy);\n                } else {\n                  xR${x}C${e} = vec4(0, 0, xTexelR${x}C${e}.xy);\n                }\n              `:`\n                if(xR >= 0 && xR < ${i} && xC >= 0 && xC < ${o}) {\n                  xTexelR${x}C${e} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${x}C${e} = vec4(0.);\n                }\n\n                xR${x}C${e} = xTexelR${x}C${e};\n              `,e+1<f)){const t=l%2==0?r.nearestLargerEven(d):d;d%2==0&&l%2==1||d%2!=0&&l%2!=1?(g+=`\n                  xCOffset = xC + ${l%2} + ${t};\n\n                  if(xR >= 0 && xR < ${i} &&\n                    xCOffset >= 0 && xCOffset < ${o}) {\n                    xTexelR${x}C${e+2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `,d>1&&(g+=`\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${i} &&\n                      xCOffset >= 0 && xCOffset < ${o}) {\n                      xTexelR${x}C${e} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${x}C${e} = vec4(0.);\n                    }\n                  `),g+=`\n                  xR${x}C${e+1} = vec4(\n                    xTexelR${x}C${e}.zw, xTexelR${x}C${e+2}.xy);\n                `):g+=`\n                  xCOffset = xC + ${t};\n\n                  if(xR >= 0 && xR < ${i} &&\n                    xCOffset >= 0 && xCOffset < ${o}) {\n                    xTexelR${x}C${e+2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${x}C${e+1} = xTexelR${x}C${e+2};\n                `}}else e<f&&(g+=`\n              if(xR >= 0 && xR < ${i}) {\n            `,l%2==1?(g+=`\n                xCOffset = xC + 1 - ${c};\n                if(xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${x}C${e} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${x}C${e} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${o}) {\n                  xTexelR${x}C${e+2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${x}C${e+2} = vec4(0.);\n                }\n\n                xR${x}C${e} = vec4(\n                  xTexelR${x}C${e}.zw, xTexelR${x}C${e+2}.zw);\n              `,e+1<f&&(g+=`\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${c};\n                  if(xCOffset >= 0 && xCOffset < ${o}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${x}C${e+1} = vec4(xTexelR${x}C${e+2}.xy, final.xy);\n                `)):(g+=`\n                if(xC >= 0 && xC < ${o}) {\n                  xTexelR${x}C${e} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${x}C${e} = vec4(0.);\n                }\n\n                xCOffset = xC + ${c};\n                if(xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${x}C${e+2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${x}C${e+2} = vec4(0.);\n                }\n\n                xR${x}C${e} = vec4(\n                  xTexelR${x}C${e}.xy, xTexelR${x}C${e+2}.xy);\n              `,e+1<f&&(g+=`\n                  xR${x}C${e+1} = vec4(\n                    xTexelR${x}C${e}.zw, xTexelR${x}C${e+2}.zw);\n                `)),g+="}");e<f&&(g+=`\n            vec4 wTexelR${x}C${e} = getW(${x}, ${e}, d1, q);\n            wR${x}C${e} = vec4(wTexelR${x}C${e}.xz, wTexelR${x}C${e}.xz);\n          `,e+1<f&&(g+=`\n              vec4 wTexelR${x}C${e+1} = getW(${x}, ${e+1}, d1, q);\n              wR${x}C${e+1} =\n                vec4(wTexelR${x}C${e+1}.xz, wTexelR${x}C${e+1}.xz);`))}for(let r=0;r<p;r++)for(let t=0;t<f;t++)g+=`dotProd += xR${r}C${t} * wR${r}C${t};`;let y="",b="";n&&(y=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,b="result = activation(result);");const v=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${y}\n\n      const ivec2 strides = ivec2(${u}, ${c});\n      const ivec2 pads = ivec2(${a}, ${l});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${g}\n\n        vec4 result = dotProd;\n        ${v}\n        ${b}\n        setOutput(result);\n      }\n    `}}class $R{constructor(t,e,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,o,a,l]=t,[u]=e,[c,h]=n;this.outputShape=[u,c,h,l];const d="bilinear"===r?1:0,[p,f]=[o-1+".0",a-1+".0"],[m,g,y]=c>1?[""+(o-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0","0.5 * (y1+y2) * "+p],[b,v,x]=h>1?[""+(a-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0","0.5 * (x1+x2) * "+f];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}class DR{constructor(t,e,n){this.variableNames=["x"],this.outputShape=t;const r=t.length,s=t[t.length-1],i=n?"<":">";this.userCode=`\n      int getIndex(int i) {\n        ${n?`return ${s} -i - 1;`:"return i;"}\n      }\n\n      void main() {\n        ${tR(r)} coords = getOutputCoords();\n        int end = ${OR(r,"coords")};\n        float val = 0.0;\n        for (int i = ${s} - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx ${i} end) {\n            continue;\n          }\n          if (idx == end && ${e}) {\n            continue;\n          }\n          ${OR(r,"coords")} = idx;\n          val += getX(${function(t,e){if(1===t)return""+e;if(2===t)return`${e}.x, ${e}.y`;if(3===t)return`${e}.x, ${e}.y, ${e}.z`;if(4===t)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}(r,"coords")});\n        }\n        setOutput(val);\n      }\n    `}}function OR(t,e){if(1===t)return""+e;if(2===t)return e+".y";if(3===t)return e+".z";if(4===t)return e+".w";throw Error(`Cumulative sum for rank ${t} is not yet supported`)}class FR{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=cT.DENSE;const e=fT(t),n=WT();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${jT(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class MR{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=cT.DENSE;const e=fT(t),n=WT();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${jT(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class LR{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}class PR{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}class zR{constructor(t){this.variableNames=["A"],this.outTexUsage=hT.DOWNLOAD;const e=WT();this.outputShape=t,this.userCode=`\n      ${qT}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class BR{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=hT.DOWNLOAD;const e=WT();this.outputShape=t,this.userCode=`\n      ${qT}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class VR{constructor(t,e,n=!1){this.variableNames=["A"];const r=WT(),[s,i]=e;this.outputShape=t;let o="result";n&&(o="floor(result * 255. + 0.5)"),this.userCode=`\n      ${HT(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / ${i};\n        int c = imod(flatIndex, ${i});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${s}.0);\n        vec4 values = ${r.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${r.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}class UR{constructor(t,e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const r=WT(),[s,i]=e;this.outputShape=t;let o="",a="result";n&&(a="floor(result * 255. + 0.5)");for(let l=0;l<=1;l++)for(let e=0;e<=1;e++){const n=2*l+e;o+=`\n          localCoords = coords;\n          if(localCoords[2] + ${e} < ${t[2]}) {\n            localCoords[2] += ${e};\n            if(localCoords[1] + ${l} < ${t[1]}) {\n              localCoords[1] += ${l};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${i};\n              c = imod(flatIndex, ${i});\n              uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${s}.0);\n              values = ${r.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${n}] = values[0];\n              } else if(offset == 1) {\n                result[${n}] = values[1];\n              } else if(offset == 2) {\n                result[${n}] = values[2];\n              } else {\n                result[${n}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${HT(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${o}\n\n        ${r.output} = ${a};\n      }\n    `}}class WR{constructor(t,e,n){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const s=n?"2.0 * "+Math.PI:"-2.0 * "+Math.PI;this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${t}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${n?r+".0":"1.0"};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}class jR{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}class HR{constructor(t,e,n){this.variableNames=["A","indices"];const r=t.slice();r[n]=e,this.outputShape=r,this.rank=r.length;const s=tR(this.rank),i=function(t,e){const n=t.length;if(n>4)throw Error(`Gather for rank ${n} is not yet supported`);if(1===n)return"int(getIndices(resRC))";const r=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let i=0;i<t.length;i++)s.push(i===e?`int(getIndices(${r[i]}))`:""+r[i]);return s.join()}(t,n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}class qR{constructor(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;const r=tR(e.length),s=tR(n.length);this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}function GR(t,e,n,r,s,i,o){!function(t,e){const n=Np().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0)throw new Error(`Requested texture size [${t}x${e}] is invalid.`);if(t>n||e>n)throw new Error(`Requested texture size [${t}x${e}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(n,r);const a=function(t,e){return kT(t,e,()=>t.createTexture(),"Unable to create WebGLTexture.")}(t,e),l=t.TEXTURE_2D;return yT(t,e,()=>t.bindTexture(l,a)),yT(t,e,()=>t.texParameteri(l,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),yT(t,e,()=>t.texParameteri(l,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),yT(t,e,()=>t.texParameteri(l,t.TEXTURE_MIN_FILTER,t.NEAREST)),yT(t,e,()=>t.texParameteri(l,t.TEXTURE_MAG_FILTER,t.NEAREST)),yT(t,e,()=>t.texImage2D(l,0,s,n,r,0,i,o,null)),yT(t,e,()=>t.bindTexture(t.TEXTURE_2D,null)),a}class KR{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=Np().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,function(t,e){aT[t]=e}(e,t)):this.gl=uT(e);let n="WEBGL_color_buffer_float";if(1===Np().getNumber("WEBGL_VERSION")){const t="OES_texture_half_float";if(this.textureFloatExtension=vT(this.gl,this.debug,"OES_texture_float"),OT(this.gl,t))this.textureHalfFloatExtension=vT(this.gl,this.debug,t);else if(Np().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),OT(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=vT(this.gl,this.debug,"EXT_color_buffer_half_float");else if(Np().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",OT(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!OT(this.gl,"EXT_color_buffer_half_float"))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float")}this.vertexBuffer=function(t,e){return function(t,e,n){const r=kT(t,e,()=>t.createBuffer(),"Unable to create WebGLBuffer");return yT(t,e,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),yT(t,e,()=>t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)),r}(t,e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl,this.debug),this.indexBuffer=function(t,e){return function(t,e,n){const r=kT(t,e,()=>t.createBuffer(),"Unable to create WebGLBuffer");return yT(t,e,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,r)),yT(t,e,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)),r}(t,e,new Uint16Array([0,1,2,2,1,3]))}(this.gl,this.debug),this.framebuffer=function(t,e){return kT(t,e,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl,this.debug),this.textureConfig=gT(this.gl,this.textureHalfFloatExtension)}get debug(){return Np().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;yT(t,this.debug,()=>t.finish()),yT(t,this.debug,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),yT(t,this.debug,()=>t.deleteFramebuffer(this.framebuffer)),yT(t,this.debug,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),yT(t,this.debug,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),yT(t,this.debug,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r,s){const[i,o]=pT(n,r);return GR(t,e,i,o,s.internalFormatFloat,s.textureFormatFloat,t.FLOAT)}(this.gl,this.debug,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r,s){const[i,o]=pT(n,r);return GR(t,e,i,o,s.internalFormatHalfFloat,s.textureFormatFloat,s.textureTypeHalfFloat)}(this.gl,this.debug,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r,s){const[i,o]=pT(n,r);return GR(t,e,i,o,t.RGBA,t.RGBA,t.UNSIGNED_BYTE)}(this.gl,this.debug,t,e)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function(t,e,n,r){yT(t,e,()=>t.bindTexture(t.TEXTURE_2D,n)),r.data instanceof Uint8Array?yT(t,e,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,r.width,r.height,0,t.RGBA,t.UNSIGNED_BYTE,r.data)):yT(t,e,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,r)),yT(t,e,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,this.debug,t,e)}uploadDenseMatrixToTexture(t,e,n,r){this.throwIfDisposed(),function(t,e,n,r,s,i,o){let a,l,u;yT(t,e,()=>t.bindTexture(t.TEXTURE_2D,n)),i instanceof Uint8Array?(a=new Uint8Array(r*s*4),l=t.UNSIGNED_BYTE,u=t.RGBA):(a=new Float32Array(r*s*4),l=t.FLOAT,u=o.internalFormatPackedFloat),a.set(i),yT(t,e,()=>t.texImage2D(t.TEXTURE_2D,0,u,r,s,0,t.RGBA,l,a)),yT(t,e,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,this.debug,t,e,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r,s){const[i,o]=mT(n,r);return GR(t,e,i,o,s.internalFormatPackedHalfFloat,t.RGBA,s.textureTypeHalfFloat)}(this.gl,this.debug,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r,s){const[i,o]=mT(n,r);return GR(t,e,i,o,s.internalFormatPackedFloat,t.RGBA,t.FLOAT)}(this.gl,this.debug,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(_T(this.gl,this.debug,this.framebuffer),this.outputTexture=null),yT(this.gl,this.debug,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n,r,s){const[i,o]=pT(n,r),a=new Uint8Array(n*r*4);return yT(t,e,()=>t.readPixels(0,0,i,o,s.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,this.debug,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,r,s,i){return function(t,e,n,r,s,i,o,a){const l=t,u=new Float32Array(function(t,e){const[n,r]=mT(t,e);return n*r*4}(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,t,0,0,0,s,i)}downloadFloat32MatrixFromBuffer(t,e){return function(t,e,n){const r=t,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const r=function(t,e,n,r,s){const i=t.createBuffer();yT(t,e,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,i));const o=16*n*r;return yT(t,e,()=>t.bufferData(t.PIXEL_PACK_BUFFER,o,t.STREAM_READ)),yT(t,e,()=>t.readPixels(0,0,r,n,t.RGBA,t.FLOAT,0)),yT(t,e,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),i}(this.gl,this.debug,e,n);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(Np().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=r.clientWaitSync(s,0,0);return t===r.ALREADY_SIGNALED||t===r.CONDITION_SATISFIED},e=s}else Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n,r){const s=new Float32Array(n*r*4);return yT(t,e,()=>t.readPixels(0,0,r,n,t.RGBA,t.FLOAT,s)),s}(this.gl,this.debug,e,n))}createProgram(t){this.throwIfDisposed();const e=this.gl,n=function(t,e,n){const s=kT(t,e,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(yT(t,e,()=>t.shaderSource(s,n)),yT(t,e,()=>t.compileShader(s)),!1===t.getShaderParameter(s,t.COMPILE_STATUS))throw function(t,e){const n=xT.exec(e);if(null==n)return console.log("Couldn't parse line number in error: "+e),void console.log(t);const s=+n[1],i=t.split("\n"),o=i.length.toString().length+2,a=i.map((t,e)=>r.rightPad((e+1).toString(),o)+t);let l=0;for(let r=0;r<a.length;r++)l=Math.max(a[r].length,l);const u=a.slice(0,s-1),c=a.slice(s-1,s),h=a.slice(s);console.log(u.join("\n")),console.log(e.split("\n")[0]),console.log("%c "+r.rightPad(c[0],l),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join("\n"))}(n,t.getShaderInfoLog(s)),new Error("Failed to compile fragment shader.");return s}(e,this.debug,t),s=function(t,e){const n=WT();return function(t,e,n){const r=kT(t,e,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(yT(t,e,()=>t.shaderSource(r,n)),yT(t,e,()=>t.compileShader(r)),!1===t.getShaderParameter(r,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(r)),new Error("Failed to compile vertex shader.");return r}(t,e,`${n.version}\n    precision highp float;\n    ${n.attribute} vec3 clipSpacePos;\n    ${n.attribute} vec2 uv;\n    ${n.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e,this.debug),i=function(t,e){return kT(t,e,()=>t.createProgram(),"Unable to create WebGLProgram.")}(e,this.debug);return yT(e,this.debug,()=>e.attachShader(i,s)),yT(e,this.debug,()=>e.attachShader(i,n)),function(t,e,n){if(yT(t,e,()=>t.linkProgram(n)),!1===t.getProgramParameter(n,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}(e,this.debug,i),this.debug&&wT(e,this.debug,i),this.vertexAttrsAreBound||(this.setProgram(i),this.vertexAttrsAreBound=function(t,e,n,r){return yT(t,e,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),CT(t,e,n,"clipSpacePos",r,3,20,0)&&CT(t,e,n,"uv",r,2,20,12)}(e,this.debug,this.program,this.vertexBuffer)),i}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&yT(this.gl,this.debug,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&wT(this.gl,this.debug,this.program),yT(this.gl,this.debug,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?function(t,e,n,r){return kT(t,e,()=>t.getUniformLocation(n,r),'uniform "'+r+'" not present in program.')}(this.gl,this.debug,t,e):function(t,e,n){return t.getUniformLocation(e,n)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),yT(this.gl,this.debug,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(t,e,n,r,s,i){yT(t,e,()=>function(t,e,n,r){(function(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(t,r),yT(t,e,()=>t.activeTexture(t.TEXTURE0+r)),yT(t,e,()=>t.bindTexture(t.TEXTURE_2D,n))}(t,e,r,i)),yT(t,e,()=>t.uniform1i(s,i))}(this.gl,this.debug,0,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[r,s]=mT(e,n);this.setOutputMatrixTextureDriver(t,r,s)}setOutputMatrixWriteRegion(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&wT(this.gl,this.debug,this.program),ET(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),yT(t,this.debug,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),yT(this.gl,this.debug,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=vT(this.gl,this.debug,2===Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await r.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}(this.itemsToPoll.map(t=>t.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||r.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),ST(this.gl,this.debug,t,this.framebuffer),this.debug&&ET(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(ST(this.gl,this.debug,this.outputTexture,this.framebuffer),this.debug&&ET(this.gl)):_T(this.gl,this.debug,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const r=this.gl;ST(r,this.debug,t,this.framebuffer),this.debug&&ET(r),this.outputTexture=t,yT(r,this.debug,()=>r.viewport(0,0,e,n)),yT(r,this.debug,()=>r.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,r){this.throwIfDisposed(),yT(this.gl,this.debug,()=>this.gl.scissor(t,e,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function XR(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((t,n)=>{const s=t.logicalShape,i=e[n],o=i.shape;if(!r.arraysEqual(s,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${o} must match`);if(t.isUniform&&i.isUniform)return;const a=t.texShape,l=i.isUniform?null:i.texData.texShape;if(!r.arraysEqual(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}class YR{constructor(t,e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;const{filterWidth:r,inChannels:s,strideWidth:i,strideHeight:o,padInfo:a,outWidth:l,dilationWidth:u,dilationHeight:c,dataFormat:h}=n,{left:d,top:p}=a,f=s*r,m=WT(),g="channelsLast"===h,y=g?0:1,b=g?1:2;let v="";for(let x=0;x<=1;x++)for(let n=0;n<=1;n++)v+=`\n          blockIndex = rc.y + ${n};\n          pos = rc.x + ${x};\n\n          if(blockIndex < ${t[1]} && pos < ${t[0]}) {\n            offsetY = int(blockIndex / (${l})) * ${o} - ${p};\n            d0 = offsetY + ${c} * (pos / ${f});\n\n            if(d0 < ${e[y]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${l}.) * ${i}. - ${d}.);\n              d1 = offsetX + ${u} * (int(mod(float(pos), ${f}.) / ${s}.));\n\n              if(d1 < ${e[b]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${s}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*x+n}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*x+n}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${v}\n\n        ${m.output} = result;\n      }\n    `}}class ZR{constructor(t,e,n,r,s){this.variableNames=["x"],this.outputShape=[];const i=e,o=t[3]-1;let a;this.outputShape=t;const l=`float(${n}) + float(${r}) * sum`;a=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${o}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${a};\n        setOutput(val);\n      }\n    `}}class JR{constructor(t,e,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}class QR{constructor(t,e,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e,o=t[3]-1;let a;this.outputShape=t;const l=`float(${n}) + float(${r}) * sum`;a=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${a};\n        setOutput(result);\n      }\n    `}}class t${constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.effectiveFilterHeight,n=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${e*n-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${n} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class e${constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.effectiveFilterDepth,n=t.effectiveFilterHeight,r=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${e};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${r};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${e*n*r-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${n} * ${r} +\n                  wR * ${r} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class n${constructor(t,e,n=!1,r=!1,s=!1,i=null,o=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const a=Math.ceil((n?t[1]:t[2])/2),l=n?"i * 2, rc.y":"rc.y, i * 2",u=r?"rc.z, i * 2":"i * 2, rc.z",c=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let d="",p="";i&&(d=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,p="result = activation(result);");const f=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${d}\n\n      const float sharedDimension = ${a}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${a}; i++) {\n          vec4 a = getMatrixA(rc.x, ${l});\n          vec4 b = getMatrixB(rc.x, ${u});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${c[0]} * ${h[0]});\n          result += (${c[1]} * ${h[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${f}\n\n        ${p}\n\n        setOutput(result);\n      }\n    `}}class r${constructor(t,e,n){this.variableNames=["probs"],this.outputShape=[t,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.seedLoc&&(this.seedLoc=e.getUniformLocation(n,"seed")),e.gl.uniform1f(this.seedLoc,t)}}}class s${constructor(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}class i${constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t;const e=t.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=UT("rc",e),r=tR(e),s=function(t,e,n){if(1===t)return"rc > "+e[0];let r="";for(let s=t-2;s<t;s++)r+=`${n[s]} >= ${e[s]}`,s<t-1&&(r+="||");return r}(e,t,n),i=function(t,e,n,r){if(1===t)return"";const s=r.slice(-2);return`\n    int r = ${s[0]};\n    int c = ${s[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${e};\n    bool rEdge = rp1 >= ${n};\n  `}(e,t[t.length-1],t[t.length-2],n),o=function(t,e){const n=t.length,r=function(t,e){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let i=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let n=2;n<t;n++)i=e[e.length-1-n]+","+i;n.push(i)}return n}(n,e);return 1===n?`getA(rc),\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}(t,n);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}}class o${constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const r=t.length,s=tR(r),i=e.map(t=>t[0]).join(","),o=e.map((e,n)=>e[0]+t[n]).join(","),a=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${i});\n      ${s} end = ${s}(${o});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(${n}));\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${a}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(${n}));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class a${constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const r=t.length,s=tR(r),i=e.map(t=>t[0]).join(","),o=e.map((e,n)=>e[0]+t[n]).join(","),a=UT("rc",r),l=UT("source",r),u=`${a[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,h=[s+" rc = outputLoc;",`${a[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${a[r-2]} += 1;\n       if(${a[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${a[r-1]} += 1;\n         if(${u}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(${n});\n        } else {\n          ${s} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${i});\n      const ${s} end = ${s}(${o});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}class l${constructor(t,e,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideHeight,a=t.strideWidth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const f="avg"===e;let m="0.0";if(f||(m="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec2 strides = ivec2(${o}, ${a});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let g=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(g="avgValue / count");const y=4*Math.floor(i/4),b=i%4,v=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${a});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${m};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${m});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${y}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${v}\n          }\n\n          int xC = xCCorner + ${y};\n          if (${1===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${2===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${3===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${v}\n          }\n        }\n        setOutput(${g});\n      }\n    `}}class u${constructor(t,e,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideDepth,a=t.strideHeight,l=t.strideWidth,u=t.dilationDepth,c=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=t.padInfo.front,g=t.padInfo.top,y=t.padInfo.left;this.outputShape=t.outShape;const b="avg"===e;let v="0.0";if(b||(v="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${o}, ${a}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let x=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(x="avgValue / count");const w=4*Math.floor(i/4),C=i%4,S=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${o}, ${a}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===C}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===C}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===C}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n          setOutput(${x});\n        }\n      }\n    `}}class c${constructor(t,e){this.variableNames=["x"];const n=t.windowSize,r=t.batchSize,s=t.inSize,i=Math.ceil(s/n);this.outputShape=[r,i];let o="0.0",a="";"prod"===e?o="1.0":"min"===e?(o="1.0 / 1e-20",a="min"):"max"===e&&(o="-1.0 / 1e-20",a="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?l="sumValue":"prod"===e?l="prodValue":"all"===e?l="allValue":"any"===e&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${a}(values, minMaxValue);\n      }\n    `,d="vec4";"all"===e?(o="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===e&&(o="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}}class h${constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;let n="";for(let s=0;s<4;s++){let t="thisRC = rc;";s%2==1&&(t+="thisRC.z += 1;"),s>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}var r;this.userCode=`\n      ${r=e,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${jT(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${HT(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${t[1]};\n        int cols = ${t[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class d${constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;const[,r,s]=e.shape,[,i,o]=t.shape,a=[n&&i>1?r-1:r,n&&o>1?s-1:s],l=[n&&i>1?i-1:i,n&&o>1?o-1:o],u=a[0]/l[0],c=a[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class p${constructor(t,e,n,r){this.variableNames=["A"],this.outputShape=[];const[s,i,o,a]=t;this.outputShape=[s,e,n,a];const l=[r&&e>1?i-1:i,r&&n>1?o-1:o],u=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/u[0]},\n          ${l[1]/u[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class f${constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,i,o,a]=t;this.outputShape=[s,e,n,a];const l=[r&&e>1?i-1:i,r&&n>1?o-1:o],u=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/u[0]},\n          ${l[1]/u[1]},\n          ${l[1]/u[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${a-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}class m${constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;const[,r,s]=e.shape,[,i,o]=t.shape,a=[n&&i>1?r-1:r,n&&o>1?s-1:s],l=[n&&i>1?i-1:i,n&&o>1?o-1:o],u=a[0]/l[0],c=a[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${a[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${a[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class g${constructor(t,e,n,r){this.variableNames=["A"],this.outputShape=[];const[s,i,o,a]=t;this.outputShape=[s,e,n,a];const l=[r&&e>1?i-1:i,r&&n>1?o-1:o],u=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/u[0]},\n          ${l[1]/u[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class y${constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const r=t.map((n,r)=>(n=>-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - coords[${n}] - 1`:`coords[${n}]`)(r)).join(","),s=tR(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class b${constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;const r=UT("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,o=tR(n);function a(n){const r=t.map((r,s)=>function(n,r){return-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - ${r[n]} - 1`:""+r[n]}(s,n));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${o} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(t){return a(t)}(r.slice())};\n          if(${s}){\n            result.g = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",a(t)}(r.slice())};\n          }\n          if(${i}) {\n            result.b = ${function(t){return t[n-2]="("+t[n-2]+" + 1)",a(t)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",a(t)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}class v${constructor(t,e,n,r,s,i,o=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const a=tR(s.length),l=tR(i.length);let u="";1===n?u="i":2===n&&(u="i, j");let c="";1===r?c="i":2===r&&(c="i, coords[1]"),this.userCode=`\n        ${a} strides = ${a}(${s});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${u}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${c});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}class x${constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,r=t.batchSize,s=t.inSize,i=t.numSegments,o=i*Math.ceil(s/n);this.outputShape=[r,o];const a=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let h="";s%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class w${constructor(t,e,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],o=[];for(let r=0;r<e.length;r++)o.push(""+n[r]),r<t&&i.push(""+n[r]);r=i.join(),s=o.join()}const i=tR(n);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}class C${constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=tR(this.rank),n=`uniform int start[${this.rank}];`,r=function(t){if(1===t)return"sourceLoc";if(t<=6)return S$.slice(0,t).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let s;s=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((t,e)=>`sourceLoc.${S$[e]} = start[${e}] + coords.${S$[e]};`).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}const S$=["x","y","z","w","u","v"];class _${constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length;const e=tR(this.rank),n=UT("coords",this.rank),r=UT("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,i=`getChannel(getSource(${r.join()}), ${s})`,o=`\n      result.x = ${i};\n      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${i};\n        --${r[this.rank-1]};\n      }\n    `,a=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${i};\n        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((t,e)=>`start[${e}]`).join()});`:t.map((t,e)=>`${r[e]} = ${n[e]} + start[${e}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${o}\n        ${a}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}class E${constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=tR(n.length),i=tR(n.length);let o="";if(1===r)o="coords * strides + begin";else{let t=0;o=n.map((e,r)=>(t++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${t-1}] * strides[${r}] + begin[${r}]`)).join(",")}this.userCode=`\n      ${s} begin = ${s}(${t});\n      ${s} strides = ${s}(${e});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}class k${constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){const r=A$(e,n),s=I$(t,r,n);if(s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]),this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this.log();const t=this.freeTextures[s].shift();return this.usedTextures[s].push(t),t}let i;return this.numUsedTextures++,this.log(),r===dT.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===dT.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===dT.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===dT.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===dT.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(i),i}releaseTexture(t,e,n,r){if(null==this.freeTextures)return;const s=I$(e,A$(n,r),r);s in this.freeTextures||(this.freeTextures[s]=[]),this.freeTextures[s].push(t),this.numFreeTextures++,this.numUsedTextures--;const i=this.usedTextures[s],o=i.indexOf(t);if(o<0)throw new Error("Cannot release a texture that was never provided by this texture manager");i.splice(o,1),this.log()}log(){this.logEnabled&&console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`)}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(const t in this.usedTextures)this.usedTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0}}}function A$(t,e){if(t===hT.UPLOAD)return dT.PACKED_2X2_FLOAT32;if(t===hT.RENDER||null==t)return function(t){return Np().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?dT.PACKED_2X2_FLOAT32:dT.UNPACKED_FLOAT32:t?dT.PACKED_2X2_FLOAT16:dT.UNPACKED_FLOAT16}(e);if(t===hT.DOWNLOAD||t===hT.PIXELS)return dT.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+t)}function I$(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}class N${constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[i]*e[i];this.outputShape=n,this.rank=n.length;const r=tR(this.rank),s=function(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<t.length;s++)r.push(`imod(${n[s]}, ${t[s]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}class T${constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const R$="return abs(x);",$$="if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",D$="if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",O$=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${b.SELU_SCALEALPHA};\n  float scale = ${b.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`,F$="return -x;",M$="return ceil(x);",L$="return floor(x);",P$="return exp(x);",z$="return exp(x) - 1.0;",B$=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${b.ERF_P};\n  float a1 = ${b.ERF_A1};\n  float a2 = ${b.ERF_A2};\n  float a3 = ${b.ERF_A3};\n  float a4 = ${b.ERF_A4};\n  float a5 = ${b.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`,V$="return x;",U$="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",W$="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",j$="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n";class H${constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class q${constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t;const e=t.length,n=UT("rc",e),r=tR(e),s=function(t,e){if(1===t)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}(e,n),i=n.slice(-2),o=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `}}const{segment_util:G$}=b,K$=v.split,X$=v.tile,Y$=v.topkImpl,Z$=v.whereImpl,J$={};function Q$(t,e=!1){if("linear"===t)return"return x;";if("relu"===t)return e?U$:$$;if("elu"===t)return e?j$:"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===t)return e?W$:D$;if("prelu"===t)return e?fR:dR;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class tD extends WS{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Np().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==t){const t=uT(Np().getNumber("WEBGL_VERSION"));this.binaryCache=((e=Np().getNumber("WEBGL_VERSION"))in J$||(J$[e]={}),J$[e]),this.gpgpu=new KR(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=t,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;var e;this.textureManager=new k$(this.gpgpu),this.numMBBeforeWarning=null==Np().global.screen?1024:Np().global.screen.height*Np().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new US(this,cx())}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(t,e,n){if(Np().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={};return this.texData.set(r,{shape:e,dtype:n,values:t,usage:hT.UPLOAD}),r}move(t,e,n,r){if(Np().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:r,values:e,usage:hT.UPLOAD})}readSync(t){const e=this.texData.get(t),{values:n,dtype:s,complexTensors:i,slice:o,shape:a,isPacked:l}=e;if(null!=o){let e;e=l?new H$(a,V$):new T$(a,V$);const n=this.runWebGLProgram(e,[{dataId:t,shape:a,dtype:s}],s),r=this.readSync(n.dataId);return this.disposeData(n.dataId),r}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===s)return n;const u=null!=this.activeTimers;let c,h;if(u&&(c=r.now()),"complex64"===s){const t=i.real.dataSync(),e=i.imag.dataSync();h=b.mergeRealAndImagArrays(t,e)}else h=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=r.now()-c),this.convertAndCacheOnCPU(t,h)}async read(t){if(this.pendingRead.has(t)){const e=this.pendingRead.get(t);return new Promise(t=>e.push(t))}const e=this.texData.get(t),{values:n,shape:s,slice:i,dtype:o,complexTensors:a,isPacked:l}=e;if(null!=i){let e;e=l?new H$(s,V$):new T$(s,V$);const n=this.runWebGLProgram(e,[{dataId:t,shape:s,dtype:o}],o),r=this.read(n.dataId);return this.disposeData(n.dataId),r}if(null!=n)return this.convertAndCacheOnCPU(t);if(!Np().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Np().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u,c,h=null;if("complex64"!==o&&Np().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(t);const e=this.texData.get(u.dataId);h=this.gpgpu.createBufferFromTexture(e.texture,...fT(s))}if(this.pendingRead.set(t,[]),"complex64"!==o&&await this.gpgpu.createAndWaitForFence(),"complex64"===o){const t=await Promise.all([a.real.data(),a.imag.data()]);c=b.mergeRealAndImagArrays(t[0],t[1])}else if(null==h)c=this.getValuesFromTexture(t);else{const t=r.sizeFromShape(s);c=this.gpgpu.downloadFloat32MatrixFromBuffer(h,t)}null!=u&&this.disposeData(u.dataId);const d=this.convertAndCacheOnCPU(t,c),p=this.pendingRead.get(t);return this.pendingRead.delete(t),p.forEach(t=>t(d)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t),this.pendingDeletes--),d}checkNumericalProblems(t){if(null!=t)for(let e=0;e<t.length;e++){const n=t[e];if(!bT(n)){if(Np().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:s}=this.texData.get(t),i=r.sizeFromShape(e);if(Np().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture,...fT(e)).subarray(0,i);return this.disposeData(n.dataId),s}const o=Np().getBool("WEBGL_PACK")&&!0===s,a=o?NT(e):e,l=o?new BR(a):new zR(a),u=this.runWebGLProgram(l,[{shape:a,dtype:n,dataId:t}],"float32"),c=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture,c.texShape[0],c.texShape[1]).subarray(0,i);return this.disposeData(u.dataId),h}async time(t){const e=this.activeTimers,n=[];let s=!1;null==this.programTimersStack?(this.programTimersStack=n,s=!0):this.activeTimers.push(n),this.activeTimers=n,t();const i=r.flatten(this.activeTimers.map(t=>t.query)).filter(t=>null!=t),o=r.flatten(this.activeTimers.map(t=>t.name)).filter(t=>null!=t);this.activeTimers=e,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(i);a.kernelMs=r.sum(t),a.getExtraProfileInfo=()=>t.map((t,e)=>({name:o[e],ms:t})).map(t=>`${t.name}: ${t.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU}}startTimer(){return Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:r.now(),endMs:null}}endTimer(t){return Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=r.now(),t)}async getQueryTime(t){return Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.waitForQueryAndGetTime(t):t.endMs-t.startMs}disposeData(t){if(this.pendingDisposal.has(t))return;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),void this.pendingDeletes++;if(!this.texData.has(t))return;this.releaseGPUData(t);const{complexTensors:e}=this.texData.get(t);null!=e&&(e.real.dispose(),e.imag.dispose()),this.texData.delete(t)}releaseGPUData(t){const{texture:e,dtype:n,texShape:r,usage:s,isPacked:i,slice:o}=this.texData.get(t),a=o&&o.origDataId||t,l=this.dataRefCount.get(a);l>1?this.dataRefCount.set(a,l-1):(this.dataRefCount.delete(a),null!=e&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(e,r,s,i)));const u=this.texData.get(t);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture}getDataInfo(t){return this.texData.get(t)}getCPUBackend(){return Np().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=cx().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(t,e=128){return null!=this.getCPUBackend()&&t.every(t=>null==this.texData.get(t.dataId).texture&&r.sizeFromShape(t.shape)<e)}getGPGPUContext(){return this.gpgpu}complex(t,e){const n=this.makeOutput(t.shape,"complex64");return this.texData.get(n.dataId).complexTensors={real:cx().keep(t.clone()),imag:cx().keep(e.clone())},n}real(t){return this.texData.get(t.dataId).complexTensors.real.clone()}imag(t){return this.texData.get(t.dataId).complexTensors.imag.clone()}slice(t,e,n){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.slice(t,e,n);if(0===r.sizeFromShape(n))return Am([],n,t.dtype);const{isPacked:s}=this.texData.get(t.dataId),i=o.isSliceContinous(t.shape,e,n);if(s||!i){const r=Np().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _$(n):new C$(n),s=r.getCustomSetupFunc(e);return this.compileAndRun(r,[t],null,s)}return this.uploadToGPU(t.dataId),this.shallowSlice(t,e,n)}shallowSlice(t,e,n){const r=this.texData.get(t.dataId),s=this.makeOutput(n,t.dtype),i=this.texData.get(s.dataId);Object.assign(i,r),i.shape=n,i.dtype=t.dtype;let a=o.computeFlatOffset(e,t.strides);r.slice&&(a+=r.slice.flatOffset),i.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||t.dataId};const l=this.dataRefCount.get(i.slice.origDataId)||1;return this.dataRefCount.set(i.slice.origDataId,l+1),s}stridedSlice(t,e,n,r){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.stridedSlice(t,e,n,r);const s=o.computeOutShape(e,n,r);if(s.some(t=>0===t))return Am([],s);const i=new E$(e,r,s);return this.compileAndRun(i,[t])}reverse(t,e){const n=Np().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new b$(t.shape,e):new y$(t.shape,e);return this.compileAndRun(n,[t])}concat(t,e){if("complex64"===t[0].dtype){const n=t.map(t=>km(t)),r=t.map(t=>Em(t));return _m(this.concat(n,e),this.concat(r,e))}if(this.shouldExecuteOnCPU(t))return this.cpuBackend.concat(t,e);if(1===t.length)return t[0];if(t.length>Np().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const n=Math.floor(t.length/2),r=this.concat(t.slice(0,n),e),s=this.concat(t.slice(n),e);return this.concat([r,s],e)}if(Np().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].rank>1){const n=new xR(t.map(t=>t.shape),e);return this.compileAndRun(n,t)}const n=b.computeOutShape(t.map(t=>t.shape),e),s=t.map(t=>t.as2D(-1,r.sizeFromShape(t.shape.slice(e)))),i=new vR(s.map(t=>t.shape));return this.compileAndRun(i,s).reshape(n)}neg(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.neg(t);if(Np().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,F$,t.dtype);const e=new T$(t.shape,F$);return this.compileAndRun(e,[t])}batchMatMul(t,e,n,r){const s=n?t.shape[2]:t.shape[1],i=r?e.shape[1]:e.shape[2],o=n?t.shape[1]:t.shape[2],[a,,]=t.shape;if((1===s||1===i)&&o>1e3){n&&(t=Fy(t,[0,2,1])),r&&(e=Fy(e,[0,2,1]));const s=1===i?t:t.as3D(a,o,1),l=1===i?2:1,u=1===i?e.as3D(a,1,o):e;return this.multiply(s,u).sum(l,!0)}const l=tm(t.dtype,e.dtype),u=new n$(t.shape,[a,s,i],n,r);return this.compileAndRun(u,[t,e],l)}fusedBatchMatMul({a:t,b:e,transposeA:n,transposeB:r,bias:s,activation:i,preluActivationWeights:o}){const a=n?t.shape[2]:t.shape[1],l=r?e.shape[1]:e.shape[2],[u,,]=t.shape,c=tm(t.dtype,e.dtype),h=null!=s,d=null!=o,p=i?Q$(i,!0):null,f=new n$(t.shape,[u,a,l],n,r,h,p,d),m=[t,e];return s&&m.push(s),o&&m.push(o),this.compileAndRun(f,m,c)}multiply(t,e){if("complex64"===t.dtype){const n=this.texData.get(t.dataId),r=this.texData.get(e.dataId),s=new lR("return areal * breal - aimag * bimag;",t.shape,e.shape),i=new lR("return areal * bimag + aimag * breal;",t.shape,e.shape),o=[this.makeComplexComponentTensorInfo(t,n.complexTensors.real),this.makeComplexComponentTensorInfo(t,n.complexTensors.imag),this.makeComplexComponentTensorInfo(e,r.complexTensors.real),this.makeComplexComponentTensorInfo(e,r.complexTensors.imag)],a=this.compileAndRun(s,o),l=this.compileAndRun(i,o),u=this.complex(a,l);return a.dispose(),l.dispose(),u}if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.multiply(t,e);if(Np().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,hR,t.dtype);const n=new pR(hR,t.shape,e.shape);return this.compileAndRun(n,[t,e],t.dtype)}batchNorm(t,e,n,r,s,i){const o=[t,e,n];let a=null;null!=r&&(a=r.shape,o.push(r));let l=null;if(null!=s&&(l=s.shape,o.push(s)),Np().getBool("WEBGL_PACK_NORMALIZATION")){const r=new aR(t.shape,e.shape,n.shape,a,l,i);return this.compileAndRun(r,o)}const u=new oR(t.shape,e.shape,n.shape,a,l,i);return this.compileAndRun(u,o)}localResponseNormalization4D(t,e,n,r,s){const i=Np().getBool("WEBGL_PACK_NORMALIZATION")?new QR(t.shape,e,n,r,s):new ZR(t.shape,e,n,r,s);return this.compileAndRun(i,[t])}LRNGrad(t,e,n,r,s,i,o){const a=new JR(e.shape,r,s,i,o);return this.compileAndRun(a,[e,n,t])}tile(t,e){if("string"===t.dtype){const n=this.readSync(t.dataId).map(t=>r.decodeString(t)),s=jm(t.shape,t.dtype,n);return X$(s,e)}const n=new N$(t.shape,e);return this.compileAndRun(n,[t])}pad(t,e,n){const r=Np().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new a$(t.shape,e,n):new o$(t.shape,e,n);return this.compileAndRun(r,[t])}gather(t,e,n){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.gather(t,e,n);const r=new HR(t.shape,e.size,n);return this.compileAndRun(r,[t,e])}batchToSpaceND(t,e,n){r.assert(t.rank<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const s=e.reduce((t,e)=>t*e),i=b.getReshaped(t.shape,e,s),o=b.getPermuted(i.length,e.length),a=b.getReshapedPermuted(t.shape,e,s),l=b.getSliceBeginCoords(n,e.length),u=b.getSliceSize(a,n,e.length);return Fy(t.reshape(i),o).reshape(a).slice(l,u)}spaceToBatchND(t,e,n){r.assert(t.rank<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const s=e.reduce((t,e)=>t*e),i=[[0,0]];i.push(...n);for(let r=1+e.length;r<t.shape.length;++r)i.push([0,0]);const o=t.pad(i),a=b.getReshaped(o.shape,e,s,!1),l=b.getPermuted(a.length,e.length,!1),u=b.getReshapedPermuted(o.shape,e,s,!1);return Fy(o.reshape(a),l).reshape(u)}reduce(t,e,n){const r=t.shape[0],s=t.shape[1],i=b.computeOptimalWindowSize(s),o=new c$({windowSize:i,inSize:s,batchSize:r},e),a=this.compileAndRun(o,[t],n);return 1===a.shape[1]?a:this.reduce(a,e,n)}argReduce(t,e,n=null){let r=t.shape[0],s=t.shape[1];null!=n&&(r=n.shape[0],s=n.shape[1]);const i=b.computeOptimalWindowSize(s),o=new BT({windowSize:i,inSize:s,batchSize:r},e,null==n),a=[t];null!=n&&a.push(n);const l=this.compileAndRun(o,a,"int32");return 1===l.shape[1]?l:this.argReduce(t,e,l)}argReducePacked(t,e,n=null){const r=null!=n?n.shape:t.shape,s=b.computeOptimalWindowSize(r[r.length-1]),i=new rR(r,s,e,null==n),o=this.compileAndRun(i,null==n?[t]:[t,n],"int32");return o.rank===t.rank?this.argReducePacked(t,e,o):o}sum(t,e){b.assertAxesAreInnerMostDims("sum",e,t.rank);const[n,s]=b.computeOutAndReduceShapes(t.shape,e),i=r.sizeFromShape(s),o=t.as2D(-1,i),a=em(t.dtype);return this.reduce(o,"sum",a).reshape(n)}prod(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.prod(t,e);const[n,s]=b.computeOutAndReduceShapes(t.shape,e),i=r.sizeFromShape(s),o=t.as2D(-1,i),a=em(t.dtype);return this.reduce(o,"prod",a).reshape(n)}unsortedSegmentSum(t,e,n){let s=0;const i=b.getAxesPermutation([s],t.rank);let o=t;null!=i&&(o=Fy(t,i),s=b.getInnerMostAxes(1,t.rank)[0]);const a=G$.computeOutShape(o.shape,s,n),l=r.sizeFromShape([o.shape[s]]),u=o.as2D(-1,l),c=em(t.dtype);let h=this.segOpCompute(u,"unsortedSegmentSum",e,c,n).reshape(a);return null!=i&&(h=Fy(h,b.getUndoAxesPermutation(i))),h}segOpCompute(t,e,n,r,s){const i=t.shape[0],o=t.shape[1],a=G$.segOpComputeOptimalWindowSize(o,s),l=new x$({windowSize:a,inSize:o,batchSize:i,numSegments:s},e),u=this.compileAndRun(l,[t,n],r);return u.shape[1]===s?u:(n=Bm(0,s).tile([o/a]),this.segOpCompute(u,e,n,r,s))}argMinMaxReduce(t,e,n){const s=[e];if(b.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),s,t.rank),!Np().getBool("WEBGL_PACK_REDUCE")||t.rank<=2){const[e,i]=b.computeOutAndReduceShapes(t.shape,s),o=r.sizeFromShape(i),a=t.as2D(-1,o);return this.argReduce(a,n).reshape(e)}return this.argReducePacked(t,n)}argMin(t,e){return this.argMinMaxReduce(t,e,"min")}argMax(t,e){return this.argMinMaxReduce(t,e,"max")}cumsum(t,e,n,r){if(e!==t.rank-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${t.rank-1} but got axis=`+e);const s=new DR(t.shape,n,r);return this.compileAndRun(s,[t])}equal(t,e){if(Np().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(equal(a, b));\n","bool");const n=new pR("return float(a == b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}notEqual(t,e){if(Np().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(notEqual(a, b));\n","bool");const n=new pR("return float(a != b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}less(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.less(t,e);if(Np().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThan(a, b));\n","bool");const n=new pR("return float(a < b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}lessEqual(t,e){if(Np().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThanEqual(a, b));\n","bool");const n=new pR("return float(a <= b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}greater(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.greater(t,e);if(Np().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThan(a, b));\n","bool");const n=new pR("return float(a > b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}greaterEqual(t,e){if(Np().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThanEqual(a, b));\n","bool");const n=new pR("return float(a >= b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}logicalNot(t){const e=new T$(t.shape,"return float(!(x >= 1.0));");return this.compileAndRun(e,[t])}logicalAnd(t,e){if(Np().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");const n=new pR("return float(a >= 1.0 && b >= 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}logicalOr(t,e){if(Np().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");const n=new pR("return float(a >= 1.0 || b >= 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}select(t,e,n){const r=new w$(t.rank,e.shape,e.rank);return this.compileAndRun(r,[t,e,n],tm(e.dtype,n.dtype))}where(t){b.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return Z$(t.shape,e)}topk(t,e,n){const r=t.dataSync();return Y$(r,t.shape,t.dtype,e,n)}min(t,e){b.assertAxesAreInnerMostDims("min",e,t.rank);const[n,s]=b.computeOutAndReduceShapes(t.shape,e),i=r.sizeFromShape(s),o=t.as2D(-1,i);return this.reduce(o,"min",o.dtype).reshape(n)}minimum(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.minimum(t,e);const n=Np().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mR("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new pR("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])}mod(t,e){const n=Np().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mR("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new pR("if (b == 0.0) return NAN;\n  return mod(a, b);",t.shape,e.shape);return this.compileAndRun(n,[t,e])}maximum(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.maximum(t,e);const n=Np().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mR("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new pR("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])}all(t,e){b.assertAxesAreInnerMostDims("all",e,t.rank);const[n,s]=b.computeOutAndReduceShapes(t.shape,e),i=r.sizeFromShape(s),o=t.as2D(-1,i);return this.reduce(o,"all",o.dtype).reshape(n)}any(t,e){b.assertAxesAreInnerMostDims("any",e,t.rank);const[n,s]=b.computeOutAndReduceShapes(t.shape,e),i=r.sizeFromShape(s),o=t.as2D(-1,i);return this.reduce(o,"any",o.dtype).reshape(n)}floorDiv(t,e){if(Np().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n","int32");const n=new pR("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",t.shape,e.shape);return this.compileAndRun(n,[t,e],"int32")}add(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,uR);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.add(t,e);const n=tm(t.dtype,e.dtype);if(Np().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,uR,n);const r=new pR(uR,t.shape,e.shape);return this.compileAndRun(r,[t,e],n)}packedUnaryOp(t,e,n){const r=new H$(t.shape,e);return this.compileAndRun(r,[t],n)}packedBinaryOp(t,e,n,r,s=!1){const i=new mR(n,t.shape,e.shape,s);return this.compileAndRun(i,[t,e],r)}complexSeparableBinaryOp(t,e,n){const r=this.texData.get(t.dataId),s=this.texData.get(e.dataId),[i,o]=[[r.complexTensors.real,s.complexTensors.real],[r.complexTensors.imag,s.complexTensors.imag]].map(r=>{const[s,i]=r,o=this.makeComplexComponentTensorInfo(t,s),a=this.makeComplexComponentTensorInfo(e,i),l=new pR(n,t.shape,e.shape);return this.compileAndRun(l,[o,a],tm(s.dtype,i.dtype))}),a=this.complex(i,o);return i.dispose(),o.dispose(),a}makeComplexComponentTensorInfo(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}addN(t){if(1===t.length)return t[0];if(t.length>Np().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(t.length/2),n=this.addN(t.slice(0,e)),r=this.addN(t.slice(e));return this.addN([n,r])}const e=t.map(t=>t.dtype).reduce((t,e)=>tm(t,e)),n=t.map(t=>t.shape),r=Np().getBool("WEBGL_PACK")?new zT(t[0].shape,n):new PT(t[0].shape,n);return this.compileAndRun(r,t,e)}subtract(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,cR);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.subtract(t,e);const n=tm(t.dtype,e.dtype);if(Np().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,cR,t.dtype);const r=new pR(cR,t.shape,e.shape);return this.compileAndRun(r,[t,e],n)}pow(t,e){const n=Np().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mR("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new pR("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",t.shape,e.shape),r=tm(t.dtype,e.dtype);return this.compileAndRun(n,[t,e],r)}ceil(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.ceil(t);if(Np().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,M$,t.dtype);const e=new T$(t.shape,M$);return this.compileAndRun(e,[t])}floor(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.floor(t);if(Np().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,L$,t.dtype);const e=new T$(t.shape,L$);return this.compileAndRun(e,[t])}sign(t){const e=new T$(t.shape,"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(e,[t])}isNaN(t){const e=new T$(t.shape,"return float(isnan(x));");return this.compileAndRun(e,[t],"bool")}isInf(t){const e=new T$(t.shape,"return float(isinf(x));");return this.compileAndRun(e,[t],"bool")}isFinite(t){const e=new T$(t.shape,"return float(!isnan(x) && !isinf(x));");return this.compileAndRun(e,[t],"bool")}round(t){const e=new T$(t.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(e,[t])}exp(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.exp(t);if(Np().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,P$,t.dtype);const e=new T$(t.shape,P$);return this.compileAndRun(e,[t])}expm1(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.expm1(t);if(Np().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,z$,t.dtype);const e=new T$(t.shape,z$);return this.compileAndRun(e,[t])}softmax(t,e){const n=r.parseAxisParam([e],t.shape),s=Gx(t,n),i=b.expandShapeToKeepDim(s.shape,n),o=this.subtract(t,s.reshape(i)),a=this.exp(o),l=this.sum(a,n).reshape(i);return tg(a,l)}log(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.log(t);if(Np().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",t.dtype);const e=new T$(t.shape,"if (x < 0.0) return NAN;\n  return log(x);");return this.compileAndRun(e,[t])}log1p(t){const e=new T$(t.shape,"return log(1.0 + x);");return this.compileAndRun(e,[t])}sqrt(t){const e=new T$(t.shape,"return sqrt(x);");return this.compileAndRun(e,[t])}rsqrt(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.rsqrt(t);const e=new T$(t.shape,"return inversesqrt(x);");return this.compileAndRun(e,[t])}reciprocal(t){const e=new T$(t.shape,"return 1.0 / x;");return this.compileAndRun(e,[t])}relu(t){let e;return e=Np().getBool("WEBGL_PACK")?new H$(t.shape,U$):new T$(t.shape,$$),this.compileAndRun(e,[t])}relu6(t){let e;return e=Np().getBool("WEBGL_PACK")?new H$(t.shape,W$):new T$(t.shape,D$),this.compileAndRun(e,[t])}prelu(t,e){const n=Np().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mR(fR,t.shape,e.shape):new pR(dR,t.shape,e.shape);return this.compileAndRun(n,[t,e])}elu(t){if(Np().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,j$,t.dtype);const e=new T$(t.shape,"return (x >= 0.0) ? x : (exp(x) - 1.0);");return this.compileAndRun(e,[t])}eluDer(t,e){const n=Np().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mR("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",t.shape,e.shape):new pR("return (b >= 1.0) ? a : a * (b + 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e])}selu(t){const e=new T$(t.shape,O$);return this.compileAndRun(e,[t])}int(t){const e=new T$(t.shape,"return float(int(x));");return this.compileAndRun(e,[t],"int32")}clip(t,e,n){let r;r=Np().getBool("WEBGL_PACK_CLIP")?new yR(t.shape):new gR(t.shape);const s=r.getCustomSetupFunc(e,n);return this.compileAndRun(r,[t],null,s)}abs(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.abs(t);if(Np().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,R$,t.dtype);const e=new T$(t.shape,R$);return this.compileAndRun(e,[t])}complexAbs(t){const e=this.texData.get(t.dataId),n=new bR(t.shape),r=[this.makeComplexComponentTensorInfo(t,e.complexTensors.real),this.makeComplexComponentTensorInfo(t,e.complexTensors.imag)];return this.compileAndRun(n,r)}sigmoid(t){const e=new T$(t.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(e,[t])}softplus(t){const e=new T$(t.shape,"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");return this.compileAndRun(e,[t])}sin(t){const e=new T$(t.shape,"if (isnan(x)) return x;\n  return sin(x);\n");return this.compileAndRun(e,[t])}cos(t){const e=new T$(t.shape,"if (isnan(x)) return x;\n  return cos(x);\n");return this.compileAndRun(e,[t])}tan(t){const e=new T$(t.shape,"return tan(x);");return this.compileAndRun(e,[t])}asin(t){const e=new T$(t.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n");return this.compileAndRun(e,[t])}acos(t){const e=new T$(t.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n");return this.compileAndRun(e,[t])}atan(t){const e=new T$(t.shape,"if (isnan(x)) return x;\n  return atan(x);\n");return this.compileAndRun(e,[t])}atan2(t,e){const n=Np().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mR("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new pR("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])}sinh(t){const e=new T$(t.shape,"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])}cosh(t){const e=new T$(t.shape,"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])}tanh(t){const e=new T$(t.shape,"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(e,[t])}asinh(t){const e=new T$(t.shape,"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));");return this.compileAndRun(e,[t])}acosh(t){const e=new T$(t.shape,"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));");return this.compileAndRun(e,[t])}atanh(t){const e=new T$(t.shape,"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;");return this.compileAndRun(e,[t])}erf(t){const e=new T$(t.shape,B$);return this.compileAndRun(e,[t])}step(t,e){const n=new T$(t.shape,function(t=0){return`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t});\n  `}(e));return this.compileAndRun(n,[t])}conv2dByMatMul(t,e,n,s,i,o){const a=t.shape,l=this.texData.get(t.dataId),u="channelsLast"===n.dataFormat,c=a[2]%2!=0&&!!l.isPacked;if((1==a[0]*a[1]*a[2]||1===n.outChannels)&&n.inChannels>1e3||!Np().getBool("WEBGL_LAZILY_UNPACK")||!Np().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!c){const r=this.reshape(t,[1,u?a[0]*a[1]*a[2]:a[0]*a[2]*a[3],n.inChannels]),l=this.reshape(e,[1,n.inChannels,n.outChannels]);return this.reshape(this.fusedBatchMatMul({a:r,b:l,transposeA:!1,transposeB:!1,bias:s,activation:i,preluActivationWeights:o}),n.outShape)}const h={dataId:t.dataId,shape:[1,u?a[0]*a[1]*(a[2]+1):a[0]*a[2]*(a[3]+1),n.inChannels],dtype:t.dtype},d=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,r.assert(RT(l.shape,h.shape),()=>`packed reshape ${l.shape} to ${h.shape} isn't free`);const p=this.reshape(e,[1,n.inChannels,n.outChannels]),f=this.fusedBatchMatMul({a:h,b:p,transposeA:!1,transposeB:!1,bias:s,activation:i,preluActivationWeights:o}),m=this.texData.get(f.dataId);return r.assert(m.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=d,m.shape=n.outShape,cx().makeTensorFromDataId(f.dataId,n.outShape,f.dtype)}conv2dWithIm2Row(t,e,n,r,s,i){const{filterWidth:o,filterHeight:a,inChannels:l,outWidth:u,outHeight:c,dataFormat:h}=n,d="channelsLast"===h,p=o*a*l,f=c*u,m=[p,f],g=t.squeeze([0]),y=e.reshape([1,p,-1]),b=new YR(m,g.shape,n),v=this.compileAndRun(b,[g]).reshape([1,m[0],m[1]]),x=null!=r,w=null!=i,C=s?Q$(s,!0):null,S=new n$(v.shape,[1,f,n.outChannels],!0,!1,x,C,w),_=[v,y];return r&&_.push(r),w&&_.push(i),this.compileAndRun(S,_).reshape(d?[1,c,u,n.outChannels]:[1,n.outChannels,c,u])}fusedConv2d({input:t,filter:e,convInfo:n,bias:r,activation:s,preluActivationWeights:i}){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(t,e,n,r,s,i);if(Np().getBool("WEBGL_CONV_IM2COL")&&1===t.shape[0])return this.conv2dWithIm2Row(t,e,n,r,s,i);const o=null!=r,a=null!=i,l=s?Q$(s,!1):null,u=new IR(n,o,l,a),c=[t,e];return r&&c.push(r),i&&c.push(i),this.compileAndRun(u,c)}conv2d(t,e,n){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(t,e,n);if(Np().getBool("WEBGL_CONV_IM2COL")&&1===t.shape[0])return this.conv2dWithIm2Row(t,e,n);const r=new IR(n);return this.compileAndRun(r,[t,e])}conv2dDerInput(t,e,n){const r=new SR(n);return this.compileAndRun(r,[t,e])}conv2dDerFilter(t,e,n){const r=new CR(n);return this.compileAndRun(r,[t,e])}fusedDepthwiseConv2D({input:t,filter:e,convInfo:n,bias:r,activation:s,preluActivationWeights:i}){const o=Np().getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1,a=s?Q$(s,o):null,l=[t,e],u=null!=r,c=null!=i;let h;return u&&l.push(r),c&&l.push(i),o?(h=new RR(n,u,a,c),this.compileAndRun(h,l)):(h=new TR(n,u,a,c),this.compileAndRun(h,l))}depthwiseConv2D(t,e,n){let r;return Np().getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1?(r=new RR(n),this.compileAndRun(r,[t,e])):(r=new TR(n),this.compileAndRun(r,[t,e]))}depthwiseConv2DDerInput(t,e,n){const r=new AR(n);return this.compileAndRun(r,[t,e])}depthwiseConv2DDerFilter(t,e,n){const r=new kR(n);return this.compileAndRun(r,[t,e])}conv3d(t,e,n){const r=new NR(n);return this.compileAndRun(r,[t,e])}conv3dDerInput(t,e,n){const r=new ER(n);return this.compileAndRun(r,[t,e])}conv3dDerFilter(t,e,n){const r=new _R(n);return this.compileAndRun(r,[t,e])}maxPool(t,e){const n=new l$(e,"max",!1);return this.compileAndRun(n,[t])}avgPool(t,e){const n=new l$(e,"avg",!1);return this.compileAndRun(n,[t],"float32")}maxPoolBackprop(t,e,n,r){const s=new l$(r,"max",!0),i=this.compileAndRun(s,[e]),o=new t$(r),a=this.compileAndRun(o,[t,i],e.dtype);return i.dispose(),a}avgPoolBackprop(t,e,n){const r=new sR(n);return this.compileAndRun(r,[t],e.dtype)}cast(t,e){return b.castTensor(t,e,this)}unstack(t,e){const n=t.shape[e],r=new Array(t.rank-1);let s=0;for(let l=0;l<t.rank;l++)l!==e&&(r[s++]=t.shape[l]);const i=new Array(t.rank).fill(0),o=t.shape.slice();o[e]=1;const a=new Array(n);for(let l=0;l<a.length;l++)i[e]=l,a[l]=this.slice(t,i,o).reshape(r);return a}avgPool3d(t,e){const n=new u$(e,"avg",!1);return this.compileAndRun(n,[t],"float32")}avgPool3dBackprop(t,e,n){const r=new iR(n);return this.compileAndRun(r,[t],e.dtype)}maxPool3d(t,e){const n=new u$(e,"max",!1);return this.compileAndRun(n,[t],"float32")}maxPool3dBackprop(t,e,n,r){const s=new u$(r,"max",!0),i=this.compileAndRun(s,[e]),o=new e$(r),a=this.compileAndRun(o,[t,i],e.dtype);return i.dispose(),a}reshape(t,e){const n=this.texData.get(t.dataId);if(n.isPacked&&!RT(t.shape,e)&&(null===n.texture||!RT(n.shape,e))){const n=this.packedReshape(t,e);return cx().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}return b.reshapeTensor(t,e)}resizeBilinear(t,e,n,r){const s=Np().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new f$(t.shape,e,n,r):new p$(t.shape,e,n,r);return this.compileAndRun(s,[t],"float32")}resizeBilinearBackprop(t,e,n){const r=new d$(t,e,n);return this.compileAndRun(r,[t])}resizeNearestNeighbor(t,e,n,r){const s=new g$(t.shape,e,n,r);return this.compileAndRun(s,[t])}resizeNearestNeighborBackprop(t,e,n){const r=new m$(t,e,n);return this.compileAndRun(r,[t])}multinomial(t,e,n,r){const s=e?t:Jw(t),i=new r$(s.shape[0],s.shape[1],n),o=i.getCustomSetupFunc(r);return this.compileAndRun(i,[s],"int32",o)}oneHot(t,e,n,r){const s=new s$(t.size,e,n,r);return this.compileAndRun(s,[t])}diag(t){const e=new PR(t.size);return this.compileAndRun(e,[t])}cropAndResize(t,e,n,r,s,i){const o=new $R(t.shape,e.shape,r,s,i);return this.compileAndRun(o,[t,e,n],"float32")}depthToSpace(t,e,n){r.assert(e>1,()=>"blockSize should be > 1 for depthToSpace, but was: "+e);const s=t.shape[0],i=("NHWC"===n?t.shape[1]:t.shape[2])*e,o=("NHWC"===n?t.shape[2]:t.shape[3])*e,a=("NHWC"===n?t.shape[3]:t.shape[1])/(e*e),l=new LR("NHWC"===n?[s,i,o,a]:[s,a,i,o],e,n);return this.compileAndRun(l,[t])}split(t,e,n){return K$(t,e,n)}scatterND(t,e,n){const{sliceRank:r,numUpdates:s,sliceSize:i,strides:o,outputSize:a}=b.calculateShapes(e,t,n),l=[a/i,i],u=t.reshape([s,r]),c=e.reshape([s,i]);if(0===a)return b.reshapeTensor(Am([]),n);const h=Nm(0),d=new v$(s,r,u.rank,c.rank,o,l);return this.compileAndRun(d,[c,u,h]).reshape(n)}sparseToDense(t,e,n,r){const{sliceRank:s,numUpdates:i,strides:o,outputSize:a}=b.calculateShapes(e,t,n),l=new v$(i,s,t.rank,e.rank,o,[a,1],!1);return this.compileAndRun(l,[e,t,r]).reshape(n)}fft(t){return this.fftImpl(t,!1)}ifft(t){return this.fftImpl(t,!0)}fftImpl(t,e){const n=this.texData.get(t.dataId),r=new WR("return real * expR - imag * expI;",t.shape,e),s=new WR("return real * expI + imag * expR;",t.shape,e),i=[this.makeComplexComponentTensorInfo(t,n.complexTensors.real),this.makeComplexComponentTensorInfo(t,n.complexTensors.imag)],o=this.compileAndRun(r,i),a=this.compileAndRun(s,i),l=this.complex(o,a).as2D(t.shape[0],t.shape[1]);return o.dispose(),a.dispose(),l}gatherND(t,e){const n=e.shape,r=n[n.length-1],[s,i,o,a]=b.prepareAndValidate(t,e),l=e.reshape([i,r]),u=t.reshape([t.size/o,o]),c=new qR(r,a,[i,o]);return this.compileAndRun(c,[u,l]).reshape(s)}fill(t,e,n){if("string"===(n=n||r.inferDtype(e))){const s=r.getArrayFromDType(n,r.sizeFromShape(t));return s.fill(e),cx().makeTensor(s,t,n,this)}{const r=new jR(t,e),s=r.getCustomSetupFunc(e);return this.compileAndRun(r,[],n,s)}}onesLike(t){if("string"===t.dtype)throw new Error("onesLike is not supported under string dtype");return this.fill(t.shape,1,t.dtype)}zerosLike(t){return this.fill(t.shape,"string"===t.dtype?"":0,t.dtype)}linspace(t,e,n){return b.linspaceImpl(t,e,n)}makeTensorInfo(t,e){const n=this.write(null,t,e);return this.texData.get(n).usage=null,{dataId:n,shape:t,dtype:e}}makeOutput(t,e){const{dataId:n}=this.makeTensorInfo(t,e);return cx().makeTensorFromDataId(n,t,e,this)}unpackTensor(t){const e=new q$(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new i$(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[AT(t.shape),...IT(t.shape)],r={dtype:t.dtype,shape:n,dataId:t.dataId},s=[AT(e),...IT(e)],i=new h$(s,n),o=this.runWebGLProgram(i,[r],t.dtype,null,!0);return{dataId:o.dataId,shape:e,dtype:o.dtype}}decode(t){const e=this.texData.get(t),{isPacked:n,shape:r,dtype:s}=e,i=NT(r);let o;return o=n?new MR(i):new FR(i),{dtype:s,shape:r,dataId:this.runWebGLProgram(o,[{shape:i,dtype:s,dataId:t}],s,null,!0).dataId}}runWebGLProgram(t,e,n,s,i=!1){const o=this.makeTensorInfo(t.outputShape,n),a=this.texData.get(o.dataId);if(t.packedOutput&&(a.isPacked=!0),t.outPackingScheme===cT.DENSE){const e=fT(t.outputShape);a.texShape=e.map(t=>2*t)}if(null!=t.outTexUsage&&(a.usage=t.outTexUsage),0===r.sizeFromShape(o.shape))return a.values=r.getTypedArrayFromDType(o.dtype,0),o;const l=[],u=e.map(e=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&r.sizeFromShape(e.shape)<=Np().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}else if(!!n.isPacked!=!!t.packedInputs)e=n.isPacked?this.unpackTensor(e):this.packTensor(e),l.push(e),n=this.texData.get(e.dataId);else if(n.isPacked&&!RT(n.shape,e.shape)){const t=e,r=e.shape;e.shape=n.shape,e=this.packedReshape(e,r),l.push(e),n=this.texData.get(e.dataId),t.shape=r}return this.uploadToGPU(e.dataId),{shape:e.shape,texData:n,isUniform:!1}});this.uploadToGPU(o.dataId);const c={shape:o.shape,texData:a,isUniform:!1},h=function(t,e,n){let r="";e.concat(n).forEach(t=>{r+=`${t.shape}_${t.isUniform?"uniform":t.texData.texShape}_${null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0}`});let s=t.constructor.name;return s+="_"+r+"_"+t.userCode,s}(t,u,c),d=this.getAndSaveBinary(h,()=>function(t,e,n,s){const i=e.userCode,o=n.map((t,n)=>{const r={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(r.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:r}}),a=o.map(t=>t.shapeInfo),l={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},u=function(t,e,n,s){const i=[];t.forEach(t=>{const e=r.sizeFromShape(t.shapeInfo.logicalShape);t.shapeInfo.isUniform?i.push(`uniform float ${t.name}${e>1?`[${e}]`:""};`):(i.push(`uniform sampler2D ${t.name};`),i.push(`uniform int offset${t.name};`))});const o=i.join("\n"),a=t.map(t=>function(t,e,n=!1){let s="";return s+=n?function t(e){switch(e.shapeInfo.logicalShape.length){case 0:return function(t){const e=t.name;return`\n    vec4 ${"get"+e.charAt(0).toUpperCase()+e.slice(1)}() {\n      return ${WT().texture2D}(${e}, halfCR);\n    }\n  `}(e);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t.shapeInfo.texShape,s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],i=WT();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${s[0]}, ${s[1]}, index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `}(e);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),i=t.shapeInfo.texShape,o=i[0],a=i[1],l=WT();if(null!=i&&r.arraysEqual(e,i))return`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);\n\n        return ${l.texture2D}(${n}, uv);\n      }\n    `;const u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${n}, uv);\n    }\n  `}(e);case 3:return function(e){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===n[0]){const r=[1,2],i=eR(e,n.slice(1)),o=["b","row","col"];return`\n        ${t(i)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${nR(o,r)});\n        }\n      `}const a=o[0],l=o[1],u=Math.ceil(n[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${a}, ${l}, ${u*Math.ceil(n[1]/2)}, ${u}, b, row, col);\n      return ${WT().texture2D}(${r}, uv);\n    }\n  `}(e);default:return function(t){const e=t.shapeInfo.logicalShape,n=e.length,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],a=o[0],l=o[1],u=Math.ceil(e[n-1]/2);let c=u*Math.ceil(e[n-2]/2),h="int b, int row, int col",d=`b * ${c} + (row / 2) * ${u} + (col / 2)`;for(let p=2;p<n-1;p++)h=`int b${p}, `+h,c*=e[n-p-1],d=`b${p} * ${c} + `+d;return`\n    vec4 ${s}(${h}) {\n      int index = ${d};\n      int texR = index / ${l};\n      int texC = index - texR * ${l};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${a});\n      return ${WT().texture2D}(${r}, uv);\n    }\n  `}(e)}}(t):function t(e){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`float ${n}() {return ${e};}`;const[r,s]=t.shapeInfo.texShape;if(1===r&&1===s)return`\n      float ${n}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const[i,o]=t.shapeInfo.texShape;return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${i}, ${o}, ${JT(e)});\n      return sampleTexture(${e}, uv);\n    }\n  `}(e);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${QT(t)}\n      }\n    `;const r=t.shapeInfo.texShape,s=r[0],i=r[1];if(1===i&&1===s)return`\n      float ${n}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const o=JT(e);return 1===i?`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===s?`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `}(e);case 2:return function(e){const n=e.shapeInfo.logicalShape,s=e.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),o=e.shapeInfo.texShape;if(null!=o&&r.arraysEqual(n,o))return`\n    float ${i}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${o[1]}.0, ${o[0]}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `;const{newShape:a,keptDims:l}=r.squeezeShape(n);if(a.length<n.length){const n=eR(e,a),r=["row","col"];return`\n      ${t(n)}\n      float ${i}(int row, int col) {\n        return ${i}(${nR(r,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${QT(e)}\n      }\n    `;const u=o[0],c=o[1],h=JT(s);return 1===c?`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `:1===u?`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${s}, uv);\n    }\n  `:`\n  float ${i}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${s}, uv);\n  }\n`}(e);case 3:return function(e){const n=e.shapeInfo.logicalShape,s=e.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n[1]*n[2],a=n[2],{newShape:l,keptDims:u}=r.squeezeShape(n);if(l.length<n.length){const n=eR(e,l),r=["row","col","depth"];return`\n        ${t(n)}\n        float ${i}(int row, int col, int depth) {\n          return ${i}(${nR(r,u)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${o}, ${a}, 1)));\n        ${QT(e)}\n      }\n    `;const c=e.shapeInfo.texShape,h=c[0],d=c[1],p=e.shapeInfo.flatOffset;return d===o&&null==p?`\n        float ${i}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${h}.0);\n          return sampleTexture(${s}, uv);\n        }\n      `:d===a&&null==p?`\n    float ${i}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `:`\n      float ${i}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${o} + col * ${a} + depth + ${JT(s)};\n        vec2 uv = uvFromFlat(${h}, ${d}, index);\n        return sampleTexture(${s}, uv);\n      }\n  `}(e);case 4:return function(e){const n=e.shapeInfo.logicalShape,s=e.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n[3],a=n[2]*o,l=n[1]*a,{newShape:u,keptDims:c}=r.squeezeShape(n);if(u.length<n.length){const n=eR(e,u),r=["row","col","depth","depth2"];return`\n      ${t(n)}\n      float ${i}(int row, int col, int depth, int depth2) {\n        return ${i}(${nR(r,c)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${l}, ${a}, ${o}, 1)));\n        ${QT(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];return f===l&&null==h?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `:f===o&&null==h?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${a} +\n          depth * ${o} + depth2;\n      vec2 uv = uvFromFlat(${p}, ${f}, index + ${JT(s)});\n      return sampleTexture(${s}, uv);\n    }\n  `}(e);case 5:return function(e){const n=e.shapeInfo.logicalShape,s=e.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n[4],a=n[3]*o,l=n[2]*a,u=n[1]*l,{newShape:c,keptDims:h}=r.squeezeShape(n);if(c.length<n.length){const n=eR(e,c),r=["row","col","depth","depth2","depth3"];return`\n      ${t(n)}\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        return ${i}(${nR(r,h)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${l}, ${a}, ${o})) +\n          depth3;\n        ${QT(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,f=p[0],m=p[1];return m===u&&null==d?`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${l}, ${a}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${f}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `:m===o&&null==d?`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${f}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${l} + depth * ${a} +\n          depth2 * ${o} + depth3 + ${JT(s)};\n      vec2 uv = uvFromFlat(${f}, ${m}, index);\n      return sampleTexture(${s}, uv);\n    }\n  `}(e);case 6:return function(e){const n=e.shapeInfo.logicalShape,s=e.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),{newShape:o,keptDims:a}=r.squeezeShape(n);if(o.length<n.length){const n=eR(e,o),r=["row","col","depth","depth2","depth3","depth4"];return`\n      ${t(n)}\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${i}(${nR(r,a)});\n      }\n    `}const l=n[5],u=n[4]*l,c=n[3]*u,h=n[2]*c,d=n[1]*h;if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${d}, ${h}, ${c}, ${u})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${l}, 1)));\n        ${QT(e)}\n      }\n    `;const p=e.shapeInfo.flatOffset,f=e.shapeInfo.texShape,m=f[0],g=f[1];return g===d&&null==p?`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${h}, ${c}, ${u}, ${l})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${g}.0, ${m}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `:g===l&&null==p?`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${g}.0, ${m}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${h} + depth * ${c} +\n          depth2 * ${u} + depth3 * ${l} + depth4 + ${JT(s)};\n      vec2 uv = uvFromFlat(${m}, ${g}, index);\n      return sampleTexture(${s}, uv);\n    }\n  `}(e);default:throw new Error(n.length+"-D input sampling is not yet supported")}}(t),t.shapeInfo.logicalShape.length<=e.logicalShape.length&&(s+=n?function(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),i="get"+s+"AtOutCoords",o=t.shapeInfo.logicalShape.length,a=e.logicalShape.length,l=GT(t.shapeInfo.logicalShape,e.logicalShape),u=tR(a),c=a-o;let h;const d=["x","y","z","w","u","v"];h=0===o?"":a<2&&l.length>=1?"coords = 0;":l.map(t=>`coords.${d[t+c]} = 0;`).join("\n");let p="";p=a<2&&o>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>"coords."+d[e+c]).join(", ");let f="return outputValue;";const m=1===r.sizeFromShape(t.shapeInfo.logicalShape),g=1===r.sizeFromShape(e.logicalShape);if(1!==o||m||g){if(m&&!g)f=1===a?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){const t=o-2,e=o-1;l.indexOf(t)>-1&&l.indexOf(e)>-1?f="return vec4(outputValue.x);":l.indexOf(t)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(e)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${i}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      vec4 outputValue = get${s}(${p});\n      ${f}\n    }\n  `}(t,e):function(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),i="get"+s+"AtOutCoords",o=t.shapeInfo.logicalShape.length,a=e.logicalShape.length;if(!t.shapeInfo.isUniform&&o===a&&null==t.shapeInfo.flatOffset&&r.arraysEqual(t.shapeInfo.texShape,e.texShape))return`\n      float ${i}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const l=tR(a),u=GT(t.shapeInfo.logicalShape,e.logicalShape),c=a-o;let h;const d=["x","y","z","w","u","v"];h=0===o?"":a<2&&u.length>=1?"coords = 0;":u.map(t=>`coords.${d[t+c]} = 0;`).join("\n");let p="";return p=a<2&&o>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>"coords."+d[e+c]).join(", "),`\n    float ${i}() {\n      ${l} coords = getOutputCoords();\n      ${h}\n      return get${s}(${p});\n    }\n  `}(t,e)),s}(t,e,s)).join("\n"),l=e.texShape,u=WT(),c=function(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(u);let h,d,p=function(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${KT}\n    ${XT}\n    ${YT}\n  `}(u);return e.isPacked?(h=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return 1===n[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,e);case 2:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(r.arraysEqual(t,e))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const s=Math.ceil(t[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[2]/2),s=r*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,e);default:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),s=r*Math.ceil(t[t.length-2]/2);let i=s,o="",a="b, r, c";for(let l=2;l<t.length-1;l++)i*=t[t.length-l-1],o=`\n      int b${l} = index / ${i};\n      index -= b${l} * ${i};\n    `+o,a=`b${l}, `+a;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${t.length}(${a});\n    }\n  `}(t,e)}}(e.logicalShape,l),d=function(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(u)):(h=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(n=e)[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `;case 2:return function(t,e){return r.arraysEqual(t,e)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));\n      }\n    `:1===t[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=jT(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(t,e);case 4:return function(t,e){const n=jT(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,e);case 5:return function(t,e){const n=jT(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},\n                             ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,e);case 6:return function(t,e){const n=jT(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,e);default:throw new Error(t.length+"-D output sampling is not yet supported")}var n}(e.logicalShape,l),d=function(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),s&&(p+=ZT),[p,c,d,o,h,a,n].join("\n")}(o,l,i,e.packedInputs),c=t.createProgram(u);let h=null;const d=t.getUniformLocation(c,"NAN",!1);1===Np().getNumber("WEBGL_VERSION")&&(h=t.getUniformLocation(c,"INFINITY",!1));const p={};for(let r=0;r<e.variableNames.length;r++){const n=e.variableNames[r],s=!1;p[n]=t.getUniformLocation(c,n,s),p["offset"+n]=t.getUniformLocation(c,"offset"+n,s)}return{program:e,source:u,webGLProgram:c,uniformLocations:p,inShapeInfos:a,outShapeInfo:l,infLoc:h,nanLoc:d}}(this.gpgpu,t,u,c)),p=null!=this.activeTimers;let f;if(p&&(f=this.startTimer()),function(t,e,n,s,i){XR(e.inShapeInfos,n),XR([e.outShapeInfo],[s]);const o=s.texData.texture,a=s.texData.texShape;s.texData.isPacked?t.setOutputPackedMatrixTexture(o,a[0],a[1]):t.setOutputMatrixTexture(o,a[0],a[1]),t.setProgram(e.webGLProgram),1===Np().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach((n,s)=>{const i=e.program.variableNames[s],o=e.uniformLocations[i],a=e.uniformLocations["offset"+i];if(null!=o)if(n.isUniform)if(r.sizeFromShape(n.shape)<2)t.gl.uniform1f(o,n.uniformValues[0]);else{let e=n.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(o,e)}else null!=n.texData.slice&&null!=a&&t.gl.uniform1i(a,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture,o,s)}),null!=i&&i(t,e.webGLProgram),t.executeProgram()}(this.gpgpu,d,u,c,s),l.forEach(t=>this.disposeData(t.dataId)),p&&(f=this.endTimer(f),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(f)})),!Np().getBool("WEBGL_LAZILY_UNPACK")&&a.isPacked&&!1===i){const t=this.unpackTensor(o);return this.disposeData(o.dataId),t}return o}compileAndRun(t,e,n,r,s=!1){const i=this.runWebGLProgram(t,e,n=n||e[0].dtype,r,s);return cx().makeTensorFromDataId(i.dataId,i.shape,i.dtype)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Np().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=dx(()=>{if(!Np().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=Np().getBool("DEBUG");Np().set("DEBUG",!1);const e=this.abs(Nm(1e-8)).dataSync()[0];if(Np().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:s,values:i,texture:o,usage:a,isPacked:l}=e;if(null!=o)return;const u=null!=this.activeTimers;let c;u&&(c=r.now());let h=e.texShape;if(null==h&&(h=function(t,e=!1){let n=Np().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e&&(n*=2,1===(t=t.map((e,n)=>n>=t.length-2?r.nearestLargerEven(t[n]):t[n])).length&&(t=[2,t[0]])),2!==t.length){const e=r.squeezeShape(t);t=e.newShape}let s=r.sizeFromShape(t);if(t.length<=1&&s<=n)return[1,s];if(2===t.length&&t[0]<=n&&t[1]<=n)return t;if(3===t.length&&t[0]*t[1]<=n&&t[2]<=n)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=n&&t[1]*t[2]<=n)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=n&&t[3]<=n)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=n&&t[1]*t[2]*t[3]<=n)return[t[0],t[1]*t[2]*t[3]];if(e){const e=AT(t);let n=2,i=2;return t.length&&([n,i]=IT(t)),s=e*(n/2)*(i/2),r.sizeToSquarishShape(s).map(t=>2*t)}return r.sizeToSquarishShape(s)}(n,l),e.texShape=h),null!=i){const t=NT(n);let o,a=h[1],d=h[0];const p=i instanceof Uint8Array;l?([a,d]=mT(h[0],h[1]),o=new UR(t,[d,a],p)):o=new VR(t,[d,a],p);const f=this.makeTensorInfo([d,a],s);this.texData.get(f.dataId).usage=p?hT.PIXELS:hT.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),a,d,i);const m=this.runWebGLProgram(o,[f],s,null,!0),g=this.texData.get(m.dataId);e.texture=g.texture,e.texShape=g.texShape,e.isPacked=g.isPacked,e.usage=g.usage,this.disposeData(f.dataId),this.texData.delete(m.dataId),e.values=null,u&&(this.uploadWaitMs+=r.now()-c)}else{const t=this.acquireTexture(h,a,s,l);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:r}=n;return this.releaseGPUData(t),null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){const n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length);for(let e=0;e<n.length;++e)n[e]=Math.round(t[e]);return n}throw new Error("Unknown dtype "+e)}(e,r)),n.values}acquireTexture(t,e,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${t} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,r)}computeBytes(t,e){return t[0]*t[1]*r.bytesPerElement(e)}}const eD={kernelName:"Div",backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{a:n,b:r}=t;return function(t,e,n){let r=new pR("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",t.shape,e.shape);return Np().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&(r=new mR("\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",t.shape,e.shape,!0)),n.runWebGLProgram(r,[t,e],"float32")}(n,r,e)}};class nD{constructor(t){this.variableNames=["A"];const e=WT(),[n,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class rD{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=WT(),[n,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const sD={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:s}=e;const{numChannels:i}=r,o="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,a="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[l,u]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],h=[u,l,i];(a||o)&&(null==iD&&(iD=document.createElement("canvas").getContext("2d")),iD.canvas.width=l,iD.canvas.height=u,iD.drawImage(s,0,0,l,u),s=iD.canvas);const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=hT.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);const p=Np().getBool("WEBGL_PACK")?new rD(h):new nD(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let iD;const{maxImpl:oD,transposeImpl:aD}=M;function lD(t,e,n){const r=n.texData.get(t.dataId);return!r.isPacked||RT(t.shape,e)||null!==r.texture&&RT(r.shape,e)?{dataId:t.dataId,shape:e,dtype:t.dtype}:function(t,e,n){const r=[AT(t.shape),...IT(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},i=[AT(e),...IT(e)],o=new h$(i,r),a=n.runWebGLProgram(o,[s],t.dtype,null,!0);return{dataId:a.dataId,shape:e,dtype:a.dtype}}(t,e,n)}class uD{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[e[i]];this.outputShape=n,this.rank=n.length;const r=tR(this.rank),s=function(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let s=0;s<t.length;s++)r[t[s]]=n[s];return r.join()}(e);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class cD{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let u=0;u<n.length;u++)n[u]=t[e[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=tR(this.rank),s=VT("rc",this.rank),i=new Array(this.rank);for(let u=0;u<e.length;u++)i[e[u]]=s[u];const o=`vec2(${i.slice(-2).join()})`,a=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${a}) {\n        result[1] = ${l};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${a}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function hD(t,e,n){const r=Np().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cD(t.shape,e):new uD(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}const dD={kernelName:"NonMaxSuppressionV3",backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{b.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:a}=n,l=e,u=l.readSync(r.dataId),c=l.readSync(s.dataId);return v.nonMaxSuppressionV3(u,c,i,o,a)}},pD=v.nonMaxSuppressionV5,fD=[{kernelName:"Max",backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{reductionIndices:i}=e,o=n,a=s.shape.length;let l=r.parseAxisParam(i,s.shape);const u=b.getAxesPermutation(l,a),c=null!=u,h=o.shouldExecuteOnCPU([s]);let d=s;if(c){if(h){const t=o.texData.get(d.dataId).values,e=new Array(a);for(let r=0;r<e.length;r++)e[r]=s.shape[u[r]];const n=aD(t,s.shape,s.dtype,u,e);d=o.makeTensorInfo(e,s.dtype),o.texData.get(d.dataId).values=n}else d=hD(s,u,o);l=b.getInnerMostAxes(l.length,a)}b.assertAxesAreInnerMostDims("max",l,a);const[p,f]=b.computeOutAndReduceShapes(d.shape,l);let m;if(h){const t=o.texData.get(d.dataId),e=oD(t.values,r.sizeFromShape(f),p,s.dtype);m=o.makeTensorInfo(p,s.dtype),o.texData.get(m.dataId).values=e}else m=function(t,e,n,s){const i=r.sizeFromShape(e),o=lD(t,[r.sizeFromShape(t.shape)/i,i],s),a=function t(e,n,r,s){const[i,o]=e.shape,a=b.computeOptimalWindowSize(o),l=new c$({windowSize:a,inSize:o,batchSize:i},r),u=s.runWebGLProgram(l,[e],n);return 1===u.shape[1]?u:t(u,n,r,s)}(o,t.dtype,"max",s);return o.dataId!==t.dataId&&s.disposeData(o.dataId),lD(a,n,s)}(d,f,p,o);return c&&o.disposeData(d.dataId),m}},sD,eD,dD,{kernelName:"NonMaxSuppressionV5",backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{b.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}=n,u=e,c=u.readSync(r.dataId),h=u.readSync(s.dataId),d=i,p=o,f=a,m=l,{selectedIndices:g,selectedScores:y}=pD(c,h,d,p,f,m);return[g,y]}},{kernelName:"Square",backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e,s=new T$(n.shape,"return x * x;");return r.runWebGLProgram(s,[n],n.dtype)}},{kernelName:"SquaredDifference",backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{a:n,b:r}=t,s=e,i=Np().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mR("return (a - b) * (a - b);",n.shape,r.shape):new pR("return (a - b) * (a - b);",n.shape,r.shape);return s.compileAndRun(i,[n,r])}},{kernelName:"Transpose",backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{perm:s}=e,i=n,o=new Array(r.shape.length);for(let l=0;l<o.length;l++)o[l]=r.shape[s[l]];let a;if(i.shouldExecuteOnCPU([r])){const t=i.texData.get(r.dataId),e=aD(t.values,r.shape,r.dtype,s,o);a=i.makeTensorInfo(o,r.dtype),i.texData.get(a.dataId).values=e}else a=hD(r,s,i);return a}},{kernelName:"MaxPoolWithArgmax",backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:i,strides:o,pad:a,includeBatchInIndex:l}=e,u=n;r.assert(4===s.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];r.assert(b.eitherStridesOrDilationsAreOne(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=b.computePool2DInfo(s.shape,i,o,c,a),[d,p]=function(t,e,n,r){let s=new l$(n,"max",!1);const i=r.runWebGLProgram(s,[t],"float32");return s=new l$(n,"max",!0,!0,e),[i,r.runWebGLProgram(s,[t],"float32")]}(s,l,h,u);return[d,p]}}];for(const CF of fD)zp(CF);i.isBrowser()&&mx("webgl",()=>new tD,2);var mD=n("EVdn");function gD(t,e){return new J(n=>{const r=t.length;if(0===r)return void n.complete();const s=new Array(r);let i=0,o=0;for(let a=0;a<r;a++){const l=vt(t[a]);let u=!1;n.add(l.subscribe({next:t=>{u||(u=!0,o++),s[a]=t},error:t=>n.error(t),complete:()=>{i++,i!==r&&u||(o===r&&n.next(e?e.reduce((t,e,n)=>(t[e]=s[n],t),{}):s),n.complete())}}))}})}const yD=new me("NgValueAccessor"),bD={provide:yD,useExisting:te(()=>vD),multi:!0};let vD=(()=>{class t{constructor(t,e){this._renderer=t,this._elementRef=e,this.onChange=t=>{},this.onTouched=()=>{}}writeValue(t){this._renderer.setProperty(this._elementRef.nativeElement,"checked",t)}registerOnChange(t){this.onChange=t}registerOnTouched(t){this.onTouched=t}setDisabledState(t){this._renderer.setProperty(this._elementRef.nativeElement,"disabled",t)}}return t.\u0275fac=function(e){return new(e||t)(ro(ra),ro(Qo))},t.\u0275dir=Xe({type:t,selectors:[["input","type","checkbox","formControlName",""],["input","type","checkbox","formControl",""],["input","type","checkbox","ngModel",""]],hostBindings:function(t,e){1&t&&ho("change",(function(t){return e.onChange(t.target.checked)}))("blur",(function(){return e.onTouched()}))},features:[Xo([bD])]}),t})();const xD={provide:yD,useExisting:te(()=>CD),multi:!0},wD=new me("CompositionEventMode");let CD=(()=>{class t{constructor(t,e,n){this._renderer=t,this._elementRef=e,this._compositionMode=n,this.onChange=t=>{},this.onTouched=()=>{},this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function(){const t=Jl()?Jl().getUserAgent():"";return/android (\d+)/.test(t.toLowerCase())}())}writeValue(t){this._renderer.setProperty(this._elementRef.nativeElement,"value",null==t?"":t)}registerOnChange(t){this.onChange=t}registerOnTouched(t){this.onTouched=t}setDisabledState(t){this._renderer.setProperty(this._elementRef.nativeElement,"disabled",t)}_handleInput(t){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(t)}_compositionStart(){this._composing=!0}_compositionEnd(t){this._composing=!1,this._compositionMode&&this.onChange(t)}}return t.\u0275fac=function(e){return new(e||t)(ro(ra),ro(Qo),ro(wD,8))},t.\u0275dir=Xe({type:t,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(t,e){1&t&&ho("input",(function(t){return e._handleInput(t.target.value)}))("blur",(function(){return e.onTouched()}))("compositionstart",(function(){return e._compositionStart()}))("compositionend",(function(t){return e._compositionEnd(t.target.value)}))},features:[Xo([xD])]}),t})(),SD=(()=>{class t{get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}reset(t){this.control&&this.control.reset(t)}hasError(t,e){return!!this.control&&this.control.hasError(t,e)}getError(t,e){return this.control?this.control.getError(t,e):null}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Xe({type:t}),t})(),_D=(()=>{class t extends SD{get formDirective(){return null}get path(){return null}}return t.\u0275fac=function(e){return ED(e||t)},t.\u0275dir=Xe({type:t,features:[Lo]}),t})();const ED=Pr(_D);function kD(){throw new Error("unimplemented")}class AD extends SD{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null,this._rawValidators=[],this._rawAsyncValidators=[]}get validator(){return kD()}get asyncValidator(){return kD()}}let ID=(()=>{class t extends class{constructor(t){this._cd=t}get ngClassUntouched(){return!!this._cd.control&&this._cd.control.untouched}get ngClassTouched(){return!!this._cd.control&&this._cd.control.touched}get ngClassPristine(){return!!this._cd.control&&this._cd.control.pristine}get ngClassDirty(){return!!this._cd.control&&this._cd.control.dirty}get ngClassValid(){return!!this._cd.control&&this._cd.control.valid}get ngClassInvalid(){return!!this._cd.control&&this._cd.control.invalid}get ngClassPending(){return!!this._cd.control&&this._cd.control.pending}}{constructor(t){super(t)}}return t.\u0275fac=function(e){return new(e||t)(ro(AD,2))},t.\u0275dir=Xe({type:t,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(t,e){2&t&&Co("ng-untouched",e.ngClassUntouched)("ng-touched",e.ngClassTouched)("ng-pristine",e.ngClassPristine)("ng-dirty",e.ngClassDirty)("ng-valid",e.ngClassValid)("ng-invalid",e.ngClassInvalid)("ng-pending",e.ngClassPending)},features:[Lo]}),t})();function ND(t){return null==t||0===t.length}function TD(t){return null!=t&&"number"==typeof t.length}const RD=new me("NgValidators"),$D=new me("NgAsyncValidators"),DD=/^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;class OD{static min(t){return e=>{if(ND(e.value)||ND(t))return null;const n=parseFloat(e.value);return!isNaN(n)&&n<t?{min:{min:t,actual:e.value}}:null}}static max(t){return e=>{if(ND(e.value)||ND(t))return null;const n=parseFloat(e.value);return!isNaN(n)&&n>t?{max:{max:t,actual:e.value}}:null}}static required(t){return ND(t.value)?{required:!0}:null}static requiredTrue(t){return!0===t.value?null:{required:!0}}static email(t){return ND(t.value)||DD.test(t.value)?null:{email:!0}}static minLength(t){return e=>ND(e.value)||!TD(e.value)?null:e.value.length<t?{minlength:{requiredLength:t,actualLength:e.value.length}}:null}static maxLength(t){return e=>TD(e.value)&&e.value.length>t?{maxlength:{requiredLength:t,actualLength:e.value.length}}:null}static pattern(t){if(!t)return OD.nullValidator;let e,n;return"string"==typeof t?(n="","^"!==t.charAt(0)&&(n+="^"),n+=t,"$"!==t.charAt(t.length-1)&&(n+="$"),e=new RegExp(n)):(n=t.toString(),e=t),t=>{if(ND(t.value))return null;const r=t.value;return e.test(r)?null:{pattern:{requiredPattern:n,actualValue:r}}}}static nullValidator(t){return null}static compose(t){if(!t)return null;const e=t.filter(FD);return 0==e.length?null:function(t){return LD(function(t,e){return e.map(e=>e(t))}(t,e))}}static composeAsync(t){if(!t)return null;const e=t.filter(FD);return 0==e.length?null:function(t){return function(...t){if(1===t.length){const e=t[0];if(U(e))return gD(e,null);if(W(e)&&Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);return gD(t.map(t=>e[t]),t)}}if("function"==typeof t[t.length-1]){const e=t.pop();return gD(t=1===t.length&&U(t[0])?t[0]:t,null).pipe(mt(t=>e(...t)))}return gD(t,null)}(function(t,e){return e.map(e=>e(t))}(t,e).map(MD)).pipe(mt(LD))}}}function FD(t){return null!=t}function MD(t){const e=uo(t)?vt(t):t;if(!co(e))throw new Error("Expected validator to return Promise or Observable.");return e}function LD(t){let e={};return t.forEach(t=>{e=null!=t?Object.assign(Object.assign({},e),t):e}),0===Object.keys(e).length?null:e}function PD(t){return t.validate?e=>t.validate(e):t}function zD(t){return t.validate?e=>t.validate(e):t}const BD={provide:yD,useExisting:te(()=>VD),multi:!0};let VD=(()=>{class t{constructor(t,e){this._renderer=t,this._elementRef=e,this.onChange=t=>{},this.onTouched=()=>{}}writeValue(t){this._renderer.setProperty(this._elementRef.nativeElement,"value",null==t?"":t)}registerOnChange(t){this.onChange=e=>{t(""==e?null:parseFloat(e))}}registerOnTouched(t){this.onTouched=t}setDisabledState(t){this._renderer.setProperty(this._elementRef.nativeElement,"disabled",t)}}return t.\u0275fac=function(e){return new(e||t)(ro(ra),ro(Qo))},t.\u0275dir=Xe({type:t,selectors:[["input","type","number","formControlName",""],["input","type","number","formControl",""],["input","type","number","ngModel",""]],hostBindings:function(t,e){1&t&&ho("input",(function(t){return e.onChange(t.target.value)}))("blur",(function(){return e.onTouched()}))},features:[Xo([BD])]}),t})();const UD={provide:yD,useExisting:te(()=>jD),multi:!0};let WD=(()=>{class t{constructor(){this._accessors=[]}add(t,e){this._accessors.push([t,e])}remove(t){for(let e=this._accessors.length-1;e>=0;--e)if(this._accessors[e][1]===t)return void this._accessors.splice(e,1)}select(t){this._accessors.forEach(e=>{this._isSameGroup(e,t)&&e[1]!==t&&e[1].fireUncheck(t.value)})}_isSameGroup(t,e){return!!t[0].control&&t[0]._parent===e._control._parent&&t[1].name===e.name}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Vt({token:t,factory:t.\u0275fac}),t})(),jD=(()=>{class t{constructor(t,e,n,r){this._renderer=t,this._elementRef=e,this._registry=n,this._injector=r,this.onChange=()=>{},this.onTouched=()=>{}}ngOnInit(){this._control=this._injector.get(AD),this._checkName(),this._registry.add(this._control,this)}ngOnDestroy(){this._registry.remove(this)}writeValue(t){this._state=t===this.value,this._renderer.setProperty(this._elementRef.nativeElement,"checked",this._state)}registerOnChange(t){this._fn=t,this.onChange=()=>{t(this.value),this._registry.select(this)}}fireUncheck(t){this.writeValue(t)}registerOnTouched(t){this.onTouched=t}setDisabledState(t){this._renderer.setProperty(this._elementRef.nativeElement,"disabled",t)}_checkName(){this.name&&this.formControlName&&this.name!==this.formControlName&&this._throwNameError(),!this.name&&this.formControlName&&(this.name=this.formControlName)}_throwNameError(){throw new Error('\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type="radio" formControlName="food" name="food">\n    ')}}return t.\u0275fac=function(e){return new(e||t)(ro(ra),ro(Qo),ro(WD),ro(Ki))},t.\u0275dir=Xe({type:t,selectors:[["input","type","radio","formControlName",""],["input","type","radio","formControl",""],["input","type","radio","ngModel",""]],hostBindings:function(t,e){1&t&&ho("change",(function(){return e.onChange()}))("blur",(function(){return e.onTouched()}))},inputs:{name:"name",formControlName:"formControlName",value:"value"},features:[Xo([UD])]}),t})();const HD={provide:yD,useExisting:te(()=>qD),multi:!0};let qD=(()=>{class t{constructor(t,e){this._renderer=t,this._elementRef=e,this.onChange=t=>{},this.onTouched=()=>{}}writeValue(t){this._renderer.setProperty(this._elementRef.nativeElement,"value",parseFloat(t))}registerOnChange(t){this.onChange=e=>{t(""==e?null:parseFloat(e))}}registerOnTouched(t){this.onTouched=t}setDisabledState(t){this._renderer.setProperty(this._elementRef.nativeElement,"disabled",t)}}return t.\u0275fac=function(e){return new(e||t)(ro(ra),ro(Qo))},t.\u0275dir=Xe({type:t,selectors:[["input","type","range","formControlName",""],["input","type","range","formControl",""],["input","type","range","ngModel",""]],hostBindings:function(t,e){1&t&&ho("change",(function(t){return e.onChange(t.target.value)}))("input",(function(t){return e.onChange(t.target.value)}))("blur",(function(){return e.onTouched()}))},features:[Xo([HD])]}),t})();const GD='\n    <div [formGroup]="myGroup">\n       <div formGroupName="person">\n          <input formControlName="firstName">\n       </div>\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       person: new FormGroup({ firstName: new FormControl() })\n    });',KD='\n    <form>\n       <div ngModelGroup="person">\n          <input [(ngModel)]="person.name" name="firstName">\n       </div>\n    </form>',XD={provide:yD,useExisting:te(()=>YD),multi:!0};let YD=(()=>{class t{constructor(t,e){this._renderer=t,this._elementRef=e,this._optionMap=new Map,this._idCounter=0,this.onChange=t=>{},this.onTouched=()=>{},this._compareWith=Object.is}set compareWith(t){if("function"!=typeof t)throw new Error("compareWith must be a function, but received "+JSON.stringify(t));this._compareWith=t}writeValue(t){this.value=t;const e=this._getOptionId(t);null==e&&this._renderer.setProperty(this._elementRef.nativeElement,"selectedIndex",-1);const n=function(t,e){return null==t?""+e:(e&&"object"==typeof e&&(e="Object"),`${t}: ${e}`.slice(0,50))}(e,t);this._renderer.setProperty(this._elementRef.nativeElement,"value",n)}registerOnChange(t){this.onChange=e=>{this.value=this._getOptionValue(e),t(this.value)}}registerOnTouched(t){this.onTouched=t}setDisabledState(t){this._renderer.setProperty(this._elementRef.nativeElement,"disabled",t)}_registerOption(){return(this._idCounter++).toString()}_getOptionId(t){for(const e of Array.from(this._optionMap.keys()))if(this._compareWith(this._optionMap.get(e),t))return e;return null}_getOptionValue(t){const e=function(t){return t.split(":")[0]}(t);return this._optionMap.has(e)?this._optionMap.get(e):t}}return t.\u0275fac=function(e){return new(e||t)(ro(ra),ro(Qo))},t.\u0275dir=Xe({type:t,selectors:[["select","formControlName","",3,"multiple",""],["select","formControl","",3,"multiple",""],["select","ngModel","",3,"multiple",""]],hostBindings:function(t,e){1&t&&ho("change",(function(t){return e.onChange(t.target.value)}))("blur",(function(){return e.onTouched()}))},inputs:{compareWith:"compareWith"},features:[Xo([XD])]}),t})();const ZD={provide:yD,useExisting:te(()=>JD),multi:!0};let JD=(()=>{class t{constructor(t,e){this._renderer=t,this._elementRef=e,this._optionMap=new Map,this._idCounter=0,this.onChange=t=>{},this.onTouched=()=>{},this._compareWith=Object.is}set compareWith(t){if("function"!=typeof t)throw new Error("compareWith must be a function, but received "+JSON.stringify(t));this._compareWith=t}writeValue(t){let e;if(this.value=t,Array.isArray(t)){const n=t.map(t=>this._getOptionId(t));e=(t,e)=>{t._setSelected(n.indexOf(e.toString())>-1)}}else e=(t,e)=>{t._setSelected(!1)};this._optionMap.forEach(e)}registerOnChange(t){this.onChange=e=>{const n=[];if(void 0!==e.selectedOptions){const t=e.selectedOptions;for(let e=0;e<t.length;e++){const r=t.item(e),s=this._getOptionValue(r.value);n.push(s)}}else{const t=e.options;for(let e=0;e<t.length;e++){const r=t.item(e);if(r.selected){const t=this._getOptionValue(r.value);n.push(t)}}}this.value=n,t(n)}}registerOnTouched(t){this.onTouched=t}setDisabledState(t){this._renderer.setProperty(this._elementRef.nativeElement,"disabled",t)}_registerOption(t){const e=(this._idCounter++).toString();return this._optionMap.set(e,t),e}_getOptionId(t){for(const e of Array.from(this._optionMap.keys()))if(this._compareWith(this._optionMap.get(e)._value,t))return e;return null}_getOptionValue(t){const e=function(t){return t.split(":")[0]}(t);return this._optionMap.has(e)?this._optionMap.get(e)._value:t}}return t.\u0275fac=function(e){return new(e||t)(ro(ra),ro(Qo))},t.\u0275dir=Xe({type:t,selectors:[["select","multiple","","formControlName",""],["select","multiple","","formControl",""],["select","multiple","","ngModel",""]],hostBindings:function(t,e){1&t&&ho("change",(function(t){return e.onChange(t.target)}))("blur",(function(){return e.onTouched()}))},inputs:{compareWith:"compareWith"},features:[Xo([ZD])]}),t})();function QD(t,e){return[...e.path,t]}function tO(t,e){t||nO(e,"Cannot find control with"),e.valueAccessor||nO(e,"No value accessor for form control with"),t.validator=OD.compose([t.validator,e.validator]),t.asyncValidator=OD.composeAsync([t.asyncValidator,e.asyncValidator]),e.valueAccessor.writeValue(t.value),function(t,e){e.valueAccessor.registerOnChange(n=>{t._pendingValue=n,t._pendingChange=!0,t._pendingDirty=!0,"change"===t.updateOn&&eO(t,e)})}(t,e),function(t,e){t.registerOnChange((t,n)=>{e.valueAccessor.writeValue(t),n&&e.viewToModelUpdate(t)})}(t,e),function(t,e){e.valueAccessor.registerOnTouched(()=>{t._pendingTouched=!0,"blur"===t.updateOn&&t._pendingChange&&eO(t,e),"submit"!==t.updateOn&&t.markAsTouched()})}(t,e),e.valueAccessor.setDisabledState&&t.registerOnDisabledChange(t=>{e.valueAccessor.setDisabledState(t)}),e._rawValidators.forEach(e=>{e.registerOnValidatorChange&&e.registerOnValidatorChange(()=>t.updateValueAndValidity())}),e._rawAsyncValidators.forEach(e=>{e.registerOnValidatorChange&&e.registerOnValidatorChange(()=>t.updateValueAndValidity())})}function eO(t,e){t._pendingDirty&&t.markAsDirty(),t.setValue(t._pendingValue,{emitModelToViewChange:!1}),e.viewToModelUpdate(t._pendingValue),t._pendingChange=!1}function nO(t,e){let n;throw n=t.path.length>1?`path: '${t.path.join(" -> ")}'`:t.path[0]?`name: '${t.path}'`:"unspecified name attribute",new Error(`${e} ${n}`)}function rO(t){return null!=t?OD.compose(t.map(PD)):null}function sO(t){return null!=t?OD.composeAsync(t.map(zD)):null}const iO=[vD,qD,VD,YD,JD,jD];function oO(t){const e=lO(t)?t.validators:t;return Array.isArray(e)?rO(e):e||null}function aO(t,e){const n=lO(e)?e.asyncValidators:t;return Array.isArray(n)?sO(n):n||null}function lO(t){return null!=t&&!Array.isArray(t)&&"object"==typeof t}class uO{constructor(t,e){this.validator=t,this.asyncValidator=e,this._onCollectionChange=()=>{},this.pristine=!0,this.touched=!1,this._onDisabledChange=[]}get parent(){return this._parent}get valid(){return"VALID"===this.status}get invalid(){return"INVALID"===this.status}get pending(){return"PENDING"==this.status}get disabled(){return"DISABLED"===this.status}get enabled(){return"DISABLED"!==this.status}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(t){this.validator=oO(t)}setAsyncValidators(t){this.asyncValidator=aO(t)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(t={}){this.touched=!0,this._parent&&!t.onlySelf&&this._parent.markAsTouched(t)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(t=>t.markAllAsTouched())}markAsUntouched(t={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(t=>{t.markAsUntouched({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}markAsDirty(t={}){this.pristine=!1,this._parent&&!t.onlySelf&&this._parent.markAsDirty(t)}markAsPristine(t={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(t=>{t.markAsPristine({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}markAsPending(t={}){this.status="PENDING",!1!==t.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!t.onlySelf&&this._parent.markAsPending(t)}disable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status="DISABLED",this.errors=null,this._forEachChild(e=>{e.disable(Object.assign(Object.assign({},t),{onlySelf:!0}))}),this._updateValue(),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors(Object.assign(Object.assign({},t),{skipPristineCheck:e})),this._onDisabledChange.forEach(t=>t(!0))}enable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status="VALID",this._forEachChild(e=>{e.enable(Object.assign(Object.assign({},t),{onlySelf:!0}))}),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent}),this._updateAncestors(Object.assign(Object.assign({},t),{skipPristineCheck:e})),this._onDisabledChange.forEach(t=>t(!1))}_updateAncestors(t){this._parent&&!t.onlySelf&&(this._parent.updateValueAndValidity(t),t.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(t){this._parent=t}updateValueAndValidity(t={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),"VALID"!==this.status&&"PENDING"!==this.status||this._runAsyncValidator(t.emitEvent)),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!t.onlySelf&&this._parent.updateValueAndValidity(t)}_updateTreeValidity(t={emitEvent:!0}){this._forEachChild(e=>e._updateTreeValidity(t)),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?"DISABLED":"VALID"}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(t){if(this.asyncValidator){this.status="PENDING";const e=MD(this.asyncValidator(this));this._asyncValidationSubscription=e.subscribe(e=>this.setErrors(e,{emitEvent:t}))}}_cancelExistingSubscription(){this._asyncValidationSubscription&&this._asyncValidationSubscription.unsubscribe()}setErrors(t,e={}){this.errors=t,this._updateControlsErrors(!1!==e.emitEvent)}get(t){return function(t,e,n){if(null==e)return null;if(Array.isArray(e)||(e=e.split(".")),Array.isArray(e)&&0===e.length)return null;let r=t;return e.forEach(t=>{r=r instanceof hO?r.controls.hasOwnProperty(t)?r.controls[t]:null:r instanceof dO&&r.at(t)||null}),r}(this,t)}getError(t,e){const n=e?this.get(e):this;return n&&n.errors?n.errors[t]:null}hasError(t,e){return!!this.getError(t,e)}get root(){let t=this;for(;t._parent;)t=t._parent;return t}_updateControlsErrors(t){this.status=this._calculateStatus(),t&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(t)}_initObservables(){this.valueChanges=new Wa,this.statusChanges=new Wa}_calculateStatus(){return this._allControlsDisabled()?"DISABLED":this.errors?"INVALID":this._anyControlsHaveStatus("PENDING")?"PENDING":this._anyControlsHaveStatus("INVALID")?"INVALID":"VALID"}_anyControlsHaveStatus(t){return this._anyControls(e=>e.status===t)}_anyControlsDirty(){return this._anyControls(t=>t.dirty)}_anyControlsTouched(){return this._anyControls(t=>t.touched)}_updatePristine(t={}){this.pristine=!this._anyControlsDirty(),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}_updateTouched(t={}){this.touched=this._anyControlsTouched(),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}_isBoxedValue(t){return"object"==typeof t&&null!==t&&2===Object.keys(t).length&&"value"in t&&"disabled"in t}_registerOnCollectionChange(t){this._onCollectionChange=t}_setUpdateStrategy(t){lO(t)&&null!=t.updateOn&&(this._updateOn=t.updateOn)}_parentMarkedDirty(t){return!t&&this._parent&&this._parent.dirty&&!this._parent._anyControlsDirty()}}class cO extends uO{constructor(t=null,e,n){super(oO(e),aO(n,e)),this._onChange=[],this._applyFormState(t),this._setUpdateStrategy(e),this.updateValueAndValidity({onlySelf:!0,emitEvent:!1}),this._initObservables()}setValue(t,e={}){this.value=this._pendingValue=t,this._onChange.length&&!1!==e.emitModelToViewChange&&this._onChange.forEach(t=>t(this.value,!1!==e.emitViewToModelChange)),this.updateValueAndValidity(e)}patchValue(t,e={}){this.setValue(t,e)}reset(t=null,e={}){this._applyFormState(t),this.markAsPristine(e),this.markAsUntouched(e),this.setValue(this.value,e),this._pendingChange=!1}_updateValue(){}_anyControls(t){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(t){this._onChange.push(t)}_clearChangeFns(){this._onChange=[],this._onDisabledChange=[],this._onCollectionChange=()=>{}}registerOnDisabledChange(t){this._onDisabledChange.push(t)}_forEachChild(t){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(t){this._isBoxedValue(t)?(this.value=this._pendingValue=t.value,t.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=t}}class hO extends uO{constructor(t,e,n){super(oO(e),aO(n,e)),this.controls=t,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!1})}registerControl(t,e){return this.controls[t]?this.controls[t]:(this.controls[t]=e,e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange),e)}addControl(t,e){this.registerControl(t,e),this.updateValueAndValidity(),this._onCollectionChange()}removeControl(t){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],this.updateValueAndValidity(),this._onCollectionChange()}setControl(t,e){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],e&&this.registerControl(t,e),this.updateValueAndValidity(),this._onCollectionChange()}contains(t){return this.controls.hasOwnProperty(t)&&this.controls[t].enabled}setValue(t,e={}){this._checkAllValuesPresent(t),Object.keys(t).forEach(n=>{this._throwIfControlMissing(n),this.controls[n].setValue(t[n],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(t,e={}){Object.keys(t).forEach(n=>{this.controls[n]&&this.controls[n].patchValue(t[n],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}reset(t={},e={}){this._forEachChild((n,r)=>{n.reset(t[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this._reduceChildren({},(t,e,n)=>(t[n]=e instanceof cO?e.value:e.getRawValue(),t))}_syncPendingControls(){let t=this._reduceChildren(!1,(t,e)=>!!e._syncPendingControls()||t);return t&&this.updateValueAndValidity({onlySelf:!0}),t}_throwIfControlMissing(t){if(!Object.keys(this.controls).length)throw new Error("\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");if(!this.controls[t])throw new Error(`Cannot find form control with name: ${t}.`)}_forEachChild(t){Object.keys(this.controls).forEach(e=>t(this.controls[e],e))}_setUpControls(){this._forEachChild(t=>{t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(t){for(const e of Object.keys(this.controls)){const n=this.controls[e];if(this.contains(e)&&t(n))return!0}return!1}_reduceValue(){return this._reduceChildren({},(t,e,n)=>((e.enabled||this.disabled)&&(t[n]=e.value),t))}_reduceChildren(t,e){let n=t;return this._forEachChild((t,r)=>{n=e(n,t,r)}),n}_allControlsDisabled(){for(const t of Object.keys(this.controls))if(this.controls[t].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_checkAllValuesPresent(t){this._forEachChild((e,n)=>{if(void 0===t[n])throw new Error(`Must supply a value for form control with name: '${n}'.`)})}}class dO extends uO{constructor(t,e,n){super(oO(e),aO(n,e)),this.controls=t,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!1})}at(t){return this.controls[t]}push(t){this.controls.push(t),this._registerControl(t),this.updateValueAndValidity(),this._onCollectionChange()}insert(t,e){this.controls.splice(t,0,e),this._registerControl(e),this.updateValueAndValidity()}removeAt(t){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),this.controls.splice(t,1),this.updateValueAndValidity()}setControl(t,e){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),this.controls.splice(t,1),e&&(this.controls.splice(t,0,e),this._registerControl(e)),this.updateValueAndValidity(),this._onCollectionChange()}get length(){return this.controls.length}setValue(t,e={}){this._checkAllValuesPresent(t),t.forEach((t,n)=>{this._throwIfControlMissing(n),this.at(n).setValue(t,{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(t,e={}){t.forEach((t,n)=>{this.at(n)&&this.at(n).patchValue(t,{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}reset(t=[],e={}){this._forEachChild((n,r)=>{n.reset(t[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this.controls.map(t=>t instanceof cO?t.value:t.getRawValue())}clear(){this.controls.length<1||(this._forEachChild(t=>t._registerOnCollectionChange(()=>{})),this.controls.splice(0),this.updateValueAndValidity())}_syncPendingControls(){let t=this.controls.reduce((t,e)=>!!e._syncPendingControls()||t,!1);return t&&this.updateValueAndValidity({onlySelf:!0}),t}_throwIfControlMissing(t){if(!this.controls.length)throw new Error("\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");if(!this.at(t))throw new Error("Cannot find form control at index "+t)}_forEachChild(t){this.controls.forEach((e,n)=>{t(e,n)})}_updateValue(){this.value=this.controls.filter(t=>t.enabled||this.disabled).map(t=>t.value)}_anyControls(t){return this.controls.some(e=>e.enabled&&t(e))}_setUpControls(){this._forEachChild(t=>this._registerControl(t))}_checkAllValuesPresent(t){this._forEachChild((e,n)=>{if(void 0===t[n])throw new Error(`Must supply a value for form control at index: ${n}.`)})}_allControlsDisabled(){for(const t of this.controls)if(t.enabled)return!1;return this.controls.length>0||this.disabled}_registerControl(t){t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange)}}const pO={provide:_D,useExisting:te(()=>mO)},fO=(()=>Promise.resolve(null))();let mO=(()=>{class t extends _D{constructor(t,e){super(),this.submitted=!1,this._directives=[],this.ngSubmit=new Wa,this.form=new hO({},rO(t),sO(e))}ngAfterViewInit(){this._setUpdateStrategy()}get formDirective(){return this}get control(){return this.form}get path(){return[]}get controls(){return this.form.controls}addControl(t){fO.then(()=>{const e=this._findContainer(t.path);t.control=e.registerControl(t.name,t.control),tO(t.control,t),t.control.updateValueAndValidity({emitEvent:!1}),this._directives.push(t)})}getControl(t){return this.form.get(t.path)}removeControl(t){fO.then(()=>{const e=this._findContainer(t.path);e&&e.removeControl(t.name),function(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}(this._directives,t)})}addFormGroup(t){fO.then(()=>{const e=this._findContainer(t.path),n=new hO({});(function(t,e){null==t&&nO(e,"Cannot find control with"),t.validator=OD.compose([t.validator,e.validator]),t.asyncValidator=OD.composeAsync([t.asyncValidator,e.asyncValidator])})(n,t),e.registerControl(t.name,n),n.updateValueAndValidity({emitEvent:!1})})}removeFormGroup(t){fO.then(()=>{const e=this._findContainer(t.path);e&&e.removeControl(t.name)})}getFormGroup(t){return this.form.get(t.path)}updateModel(t,e){fO.then(()=>{this.form.get(t.path).setValue(e)})}setValue(t){this.control.setValue(t)}onSubmit(t){return this.submitted=!0,e=this._directives,this.form._syncPendingControls(),e.forEach(t=>{const e=t.control;"submit"===e.updateOn&&e._pendingChange&&(t.viewToModelUpdate(e._pendingValue),e._pendingChange=!1)}),this.ngSubmit.emit(t),!1;var e}onReset(){this.resetForm()}resetForm(t){this.form.reset(t),this.submitted=!1}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.form._updateOn=this.options.updateOn)}_findContainer(t){return t.pop(),t.length?this.form.get(t):this.form}}return t.\u0275fac=function(e){return new(e||t)(ro(RD,10),ro($D,10))},t.\u0275dir=Xe({type:t,selectors:[["form",3,"ngNoForm","",3,"formGroup",""],["ng-form"],["","ngForm",""]],hostBindings:function(t,e){1&t&&ho("submit",(function(t){return e.onSubmit(t)}))("reset",(function(){return e.onReset()}))},inputs:{options:["ngFormOptions","options"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[Xo([pO]),Lo]}),t})(),gO=(()=>{class t extends _D{ngOnInit(){this._checkParentType(),this.formDirective.addFormGroup(this)}ngOnDestroy(){this.formDirective&&this.formDirective.removeFormGroup(this)}get control(){return this.formDirective.getFormGroup(this)}get path(){return QD(null==this.name?this.name:this.name.toString(),this._parent)}get formDirective(){return this._parent?this._parent.formDirective:null}get validator(){return rO(this._validators)}get asyncValidator(){return sO(this._asyncValidators)}_checkParentType(){}}return t.\u0275fac=function(e){return yO(e||t)},t.\u0275dir=Xe({type:t,features:[Lo]}),t})();const yO=Pr(gO);class bO{static modelParentException(){throw new Error('\n      ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\n      formGroup\'s partner directive "formControlName" instead.  Example:\n\n      \n    <div [formGroup]="myGroup">\n      <input formControlName="firstName">\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       firstName: new FormControl()\n    });\n\n      Or, if you\'d like to avoid registering this form control, indicate that it\'s standalone in ngModelOptions:\n\n      Example:\n\n      \n    <div [formGroup]="myGroup">\n       <input formControlName="firstName">\n       <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">\n    </div>\n  ')}static formGroupNameException(){throw new Error(`\n      ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\n\n      Option 1: Use formControlName instead of ngModel (reactive strategy):\n\n      ${GD}\n\n      Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\n\n      ${KD}`)}static missingNameException(){throw new Error('If ngModel is used within a form tag, either the name attribute must be set or the form\n      control must be defined as \'standalone\' in ngModelOptions.\n\n      Example 1: <input [(ngModel)]="person.firstName" name="first">\n      Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">')}static modelGroupParentException(){throw new Error(`\n      ngModelGroup cannot be used with a parent formGroup directive.\n\n      Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\n\n      ${GD}\n\n      Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\n\n      ${KD}`)}}const vO={provide:_D,useExisting:te(()=>xO)};let xO=(()=>{class t extends gO{constructor(t,e,n){super(),this._parent=t,this._validators=e,this._asyncValidators=n}_checkParentType(){this._parent instanceof t||this._parent instanceof mO||bO.modelGroupParentException()}}return t.\u0275fac=function(e){return new(e||t)(ro(_D,5),ro(RD,10),ro($D,10))},t.\u0275dir=Xe({type:t,selectors:[["","ngModelGroup",""]],inputs:{name:["ngModelGroup","name"]},exportAs:["ngModelGroup"],features:[Xo([vO]),Lo]}),t})();const wO={provide:AD,useExisting:te(()=>SO)},CO=(()=>Promise.resolve(null))();let SO=(()=>{class t extends AD{constructor(t,e,n,r){super(),this.control=new cO,this._registered=!1,this.update=new Wa,this._parent=t,this._rawValidators=e||[],this._rawAsyncValidators=n||[],this.valueAccessor=function(t,e){if(!e)return null;Array.isArray(e)||nO(t,"Value accessor was not provided as an array for form control with");let n=void 0,r=void 0,s=void 0;return e.forEach(e=>{var i;e.constructor===CD?n=e:(i=e,iO.some(t=>i.constructor===t)?(r&&nO(t,"More than one built-in value accessor matches form control with"),r=e):(s&&nO(t,"More than one custom value accessor matches form control with"),s=e))}),s||r||n||(nO(t,"No valid value accessor for form control with"),null)}(this,r)}ngOnChanges(t){this._checkForErrors(),this._registered||this._setUpControl(),"isDisabled"in t&&this._updateDisabled(t),function(t,e){if(!t.hasOwnProperty("model"))return!1;const n=t.model;return!!n.isFirstChange()||!Object.is(e,n.currentValue)}(t,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._parent?QD(this.name,this._parent):[this.name]}get formDirective(){return this._parent?this._parent.formDirective:null}get validator(){return rO(this._rawValidators)}get asyncValidator(){return sO(this._rawAsyncValidators)}viewToModelUpdate(t){this.viewModel=t,this.update.emit(t)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){tO(this.control,this),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){!(this._parent instanceof xO)&&this._parent instanceof gO?bO.formGroupNameException():this._parent instanceof xO||this._parent instanceof mO||bO.modelParentException()}_checkName(){this.options&&this.options.name&&(this.name=this.options.name),this._isStandalone()||this.name||bO.missingNameException()}_updateValue(t){CO.then(()=>{this.control.setValue(t,{emitViewToModelChange:!1})})}_updateDisabled(t){const e=t.isDisabled.currentValue,n=""===e||e&&"false"!==e;CO.then(()=>{n&&!this.control.disabled?this.control.disable():!n&&this.control.disabled&&this.control.enable()})}}return t.\u0275fac=function(e){return new(e||t)(ro(_D,9),ro(RD,10),ro($D,10),ro(yD,10))},t.\u0275dir=Xe({type:t,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:["disabled","isDisabled"],model:["ngModel","model"],options:["ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],features:[Xo([wO]),Lo,ln]}),t})(),_O=(()=>{class t{}return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)}}),t})(),EO=(()=>{class t{}return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},providers:[WD],imports:[_O]}),t})();function kO(t,e,n,r){return L(n)&&(r=n,n=void 0),r?kO(t,e,n).pipe(mt(t=>U(t)?r(...t):r(t))):new J(r=>{!function t(e,n,r,s,i){let o;if(function(t){return t&&"function"==typeof t.addEventListener&&"function"==typeof t.removeEventListener}(e)){const t=e;e.addEventListener(n,r,i),o=()=>t.removeEventListener(n,r,i)}else if(function(t){return t&&"function"==typeof t.on&&"function"==typeof t.off}(e)){const t=e;e.on(n,r),o=()=>t.off(n,r)}else if(function(t){return t&&"function"==typeof t.addListener&&"function"==typeof t.removeListener}(e)){const t=e;e.addListener(n,r),o=()=>t.removeListener(n,r)}else{if(!e||!e.length)throw new TypeError("Invalid event target");for(let o=0,a=e.length;o<a;o++)t(e[o],n,r,s,i)}s.add(o)}(t,e,(function(t){r.next(arguments.length>1?Array.prototype.slice.call(arguments):t)}),r,n)})}function AO(t){return e=>e.lift(new IO(t))}class IO{constructor(t){this.notifier=t}call(t,e){const n=new NO(t),r=pt(n,this.notifier);return r&&!n.seenValue?(n.add(r),e.subscribe(n)):n}}class NO extends ft{constructor(t){super(t),this.seenValue=!1}notifyNext(t,e,n,r,s){this.seenValue=!0,this.complete()}notifyComplete(){}}function TO(...t){return e=>{let n;return"function"==typeof t[t.length-1]&&(n=t.pop()),e.lift(new RO(t,n))}}class RO{constructor(t,e){this.observables=t,this.project=e}call(t,e){return e.subscribe(new $O(t,this.observables,this.project))}}class $O extends ft{constructor(t,e,n){super(t),this.observables=e,this.project=n,this.toRespond=[];const r=e.length;this.values=new Array(r);for(let s=0;s<r;s++)this.toRespond.push(s);for(let s=0;s<r;s++){let t=e[s];this.add(pt(this,t,t,s))}}notifyNext(t,e,n,r,s){this.values[n]=e;const i=this.toRespond;if(i.length>0){const t=i.indexOf(n);-1!==t&&i.splice(t,1)}}notifyComplete(){}_next(t){if(0===this.toRespond.length){const e=[t,...this.values];this.project?this._tryProject(e):this.destination.next(e)}}_tryProject(t){let e;try{e=this.project.apply(this,t)}catch(wF){return void this.destination.error(wF)}this.destination.next(e)}}$localize`:@@ngb.alert.close␟f4e529ae5ffd73001d1ff4bbdeeb0a72e342e5c8␟7819314041543176992:Close`;const DO=["*"];$localize`:@@ngb.carousel.previous␟680d5c75b7fd8d37961083608b9fcdc4167b4c43␟4452427314943113135:Previous`,$localize`:@@ngb.carousel.next␟f732c304c7433e5a83ffcd862c3dce709a0f4982␟3885497195825665706:Next`,$localize`:@@ngb.datepicker.previous-month␟c3b08b07b5ab98e7cdcf18df39355690ab7d3884␟8586908745456864217:Previous month`,$localize`:@@ngb.datepicker.previous-month␟c3b08b07b5ab98e7cdcf18df39355690ab7d3884␟8586908745456864217:Previous month`,$localize`:@@ngb.datepicker.next-month␟4bd046985cfe13040d5ef0cd881edce0968a111a␟3628374603023447227:Next month`,$localize`:@@ngb.datepicker.next-month␟4bd046985cfe13040d5ef0cd881edce0968a111a␟3628374603023447227:Next month`,$localize`:@@ngb.datepicker.select-month␟1dbc84807f35518112f62e5775d1daebd3d8462b␟2253869508135064750:Select month`,$localize`:@@ngb.datepicker.select-month␟1dbc84807f35518112f62e5775d1daebd3d8462b␟2253869508135064750:Select month`,$localize`:@@ngb.datepicker.select-year␟8ceb09d002bf0c5d1cac171dfbffe1805d2b3962␟8852264961585484321:Select year`,$localize`:@@ngb.datepicker.select-year␟8ceb09d002bf0c5d1cac171dfbffe1805d2b3962␟8852264961585484321:Select year`;const OO=["dialog"];function FO(t){return null!=t}$localize`:@@ngb.pagination.first␟656506dfd46380956a655f919f1498d018f75ca0␟6867721956102594380:««`,$localize`:@@ngb.pagination.previous␟6e52b6ee77a4848d899dd21b591c6fd499e3aef3␟6479320895410098858:«`,$localize`:@@ngb.pagination.next␟ba9cbb4ff311464308a3627e4f1c3345d9fe6d7d␟5458177150283468089:»`,$localize`:@@ngb.pagination.last␟49f27a460bc97e7e00be5b37098bfa79884fc7d9␟5277020320267646988:»»`,$localize`:@@ngb.pagination.first-aria␟f2f852318759c6396b5d3d17031d53817d7b38cc␟2241508602425256033:First`,$localize`:@@ngb.pagination.previous-aria␟680d5c75b7fd8d37961083608b9fcdc4167b4c43␟4452427314943113135:Previous`,$localize`:@@ngb.pagination.next-aria␟f732c304c7433e5a83ffcd862c3dce709a0f4982␟3885497195825665706:Next`,$localize`:@@ngb.pagination.last-aria␟5c729788ba138508aca1bec050b610f7bf81db3e␟4882268002141858767:Last`,$localize`:@@ngb.progressbar.value␟f8e9a947b9db4252c0e9905765338712f2fd032f␟3720830768741091151:${"\ufffd0\ufffd"}:INTERPOLATION:`,$localize`:@@ngb.timepicker.HH␟ce676ab1d6d98f85c836381cf100a4a91ef95a1f␟4043638465245303811:HH`,$localize`:@@ngb.timepicker.hours␟3bbce5fef7e1151da052a4e529453edb340e3912␟8070396816726827304:Hours`,$localize`:@@ngb.timepicker.MM␟72c8edf6a50068a05bde70991e36b1e881f4ca54␟1647282246509919852:MM`,$localize`:@@ngb.timepicker.minutes␟41e62daa962947c0d23ded0981975d1bddf0bf38␟5531237363767747080:Minutes`,$localize`:@@ngb.timepicker.increment-hours␟cb74bc1d625a6c1742f0d7d47306cf495780c218␟5939278348542933629:Increment hours`,$localize`:@@ngb.timepicker.decrement-hours␟147c7a19429da7d999e247d22e33fee370b1691b␟3651829882940481818:Decrement hours`,$localize`:@@ngb.timepicker.increment-minutes␟f5a4a3bc05e053f6732475d0e74875ec01c3a348␟180147720391025024:Increment minutes`,$localize`:@@ngb.timepicker.decrement-minutes␟c1a6899e529c096da5b660385d4e77fe1f7ad271␟7447789825403243588:Decrement minutes`,$localize`:@@ngb.timepicker.SS␟ebe38d36a40a2383c5fefa9b4608ffbda08bd4a3␟3628127143071124194:SS`,$localize`:@@ngb.timepicker.seconds␟4f2ed9e71a7c981db3e50ae2fedb28aff2ec4e6c␟8874012390997067175:Seconds`,$localize`:@@ngb.timepicker.increment-seconds␟912322ecee7d659d04dcf494a70e22e49d334b26␟5364772110539092174:Increment seconds`,$localize`:@@ngb.timepicker.decrement-seconds␟5db47ac104294243a70eb9124fbea9d0004ddf69␟753633511487974857:Decrement seconds`,$localize`:@@ngb.timepicker.PM␟8d6e691e10306c1b34c6b26805151aaea320ef7f␟3564199131264287502:${"\ufffd0\ufffd"}:INTERPOLATION:`,$localize`:@@ngb.timepicker.AM␟69a1f176a93998876952adac57c3bc3863b6105e␟4592818992509942761:${"\ufffd0\ufffd"}:INTERPOLATION:`,$localize`:@@ngb.toast.close-aria␟f4e529ae5ffd73001d1ff4bbdeeb0a72e342e5c8␟7819314041543176992:Close`,"undefined"==typeof Element||Element.prototype.closest||(Element.prototype.matches||(Element.prototype.matches=Element.prototype.msMatchesSelector||Element.prototype.webkitMatchesSelector),Element.prototype.closest=function(t){let e=this;if(!document.documentElement.contains(e))return null;do{if(e.matches(t))return e;e=e.parentElement||e.parentNode}while(null!==e&&1===e.nodeType);return null});let MO=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},imports:[[xu]]}),t})(),LO=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},imports:[[xu]]}),t})(),PO=(()=>{let t=class{};return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Xe({type:t,selectors:[["","ngbButtonLabel",""]],hostVars:8,hostBindings:function(t,e){2&t&&Co("btn",!0)("active",e.active)("disabled",e.disabled)("focus",e.focused)}}),t})();const zO={provide:yD,useExisting:te(()=>BO),multi:!0};let BO=(()=>{let t=class{constructor(t,e){this._label=t,this._cd=e,this.disabled=!1,this.valueChecked=!0,this.valueUnChecked=!1,this.onChange=t=>{},this.onTouched=()=>{}}set focused(t){this._label.focused=t,t||this.onTouched()}onInputChange(t){const e=t.target.checked?this.valueChecked:this.valueUnChecked;this.onChange(e),this.onTouched(),this.writeValue(e)}registerOnChange(t){this.onChange=t}registerOnTouched(t){this.onTouched=t}setDisabledState(t){this.disabled=t,this._label.disabled=t}writeValue(t){this.checked=t===this.valueChecked,this._label.active=this.checked,this._cd.markForCheck()}};return t.\u0275fac=function(e){return new(e||t)(ro(PO),ro(Ri))},t.\u0275dir=Xe({type:t,selectors:[["","ngbButton","","type","checkbox"]],hostVars:2,hostBindings:function(t,e){1&t&&ho("change",(function(t){return e.onInputChange(t)}))("focus",(function(){return e.focused=!0}))("blur",(function(){return e.focused=!1})),2&t&&Fo("checked",e.checked)("disabled",e.disabled)},inputs:{disabled:"disabled",valueChecked:"valueChecked",valueUnChecked:"valueUnChecked"},features:[Xo([zO])]}),t})(),VO=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)}}),t})(),UO=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},imports:[[xu]]}),t})(),WO=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)}}),t})();var jO=function(t){return t[t.Tab=9]="Tab",t[t.Enter=13]="Enter",t[t.Escape=27]="Escape",t[t.Space=32]="Space",t[t.PageUp=33]="PageUp",t[t.PageDown=34]="PageDown",t[t.End=35]="End",t[t.Home=36]="Home",t[t.ArrowLeft=37]="ArrowLeft",t[t.ArrowUp=38]="ArrowUp",t[t.ArrowRight=39]="ArrowRight",t[t.ArrowDown=40]="ArrowDown",t}({});const HO=["a[href]","button:not([disabled])",'input:not([disabled]):not([type="hidden"])',"select:not([disabled])","textarea:not([disabled])","[contenteditable]",'[tabindex]:not([tabindex="-1"])'].join(", ");function qO(t){const e=Array.from(t.querySelectorAll(HO)).filter(t=>-1!==t.tabIndex);return[e[0],e[e.length-1]]}let GO=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},imports:[[xu,EO]]}),t})(),KO=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)}}),t})(),XO=(()=>{let t=class{constructor(){this.backdrop=!0,this.keyboard=!0}};return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Vt({factory:function(){return new t},token:t,providedIn:"root"}),t})();class YO{constructor(t,e,n){this.nodes=t,this.viewRef=e,this.componentRef=n}}const ZO=()=>{};let JO=(()=>{let t=class{constructor(t){this._document=t}compensate(){const t=this._getWidth();return this._isPresent(t)?this._adjustBody(t):ZO}_adjustBody(t){const e=this._document.body,n=e.style.paddingRight,r=parseFloat(window.getComputedStyle(e)["padding-right"]);return e.style["padding-right"]=r+t+"px",()=>e.style["padding-right"]=n}_isPresent(t){const e=this._document.body.getBoundingClientRect();return window.innerWidth-(e.left+e.right)>=t-.1*t}_getWidth(){const t=this._document.createElement("div");t.className="modal-scrollbar-measure";const e=this._document.body;e.appendChild(t);const n=t.getBoundingClientRect().width-t.clientWidth;return e.removeChild(t),n}};return t.\u0275fac=function(e){return new(e||t)(Ee(Ql))},t.\u0275prov=Vt({factory:function(){return new t(Ee(Ql))},token:t,providedIn:"root"}),t})(),QO=(()=>{let t=class{};return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=We({type:t,selectors:[["ngb-modal-backdrop"]],hostAttrs:[2,"z-index","1050"],hostVars:2,hostBindings:function(t,e){2&t&&So("modal-backdrop fade show"+(e.backdropClass?" "+e.backdropClass:""))},inputs:{backdropClass:"backdropClass"},decls:0,vars:0,template:function(t,e){},encapsulation:2}),t})();class tF{close(t){}dismiss(t){}}class eF{constructor(t,e,n,r){this._windowCmptRef=t,this._contentRef=e,this._backdropCmptRef=n,this._beforeDismiss=r,t.instance.dismissEvent.subscribe(t=>{this.dismiss(t)}),this.result=new Promise((t,e)=>{this._resolve=t,this._reject=e}),this.result.then(null,()=>{})}get componentInstance(){if(this._contentRef&&this._contentRef.componentRef)return this._contentRef.componentRef.instance}close(t){this._windowCmptRef&&(this._resolve(t),this._removeModalElements())}_dismiss(t){this._reject(t),this._removeModalElements()}dismiss(t){if(this._windowCmptRef)if(this._beforeDismiss){const e=this._beforeDismiss();e&&e.then?e.then(e=>{!1!==e&&this._dismiss(t)},()=>{}):!1!==e&&this._dismiss(t)}else this._dismiss(t)}_removeModalElements(){const t=this._windowCmptRef.location.nativeElement;if(t.parentNode.removeChild(t),this._windowCmptRef.destroy(),this._backdropCmptRef){const t=this._backdropCmptRef.location.nativeElement;t.parentNode.removeChild(t),this._backdropCmptRef.destroy()}this._contentRef&&this._contentRef.viewRef&&this._contentRef.viewRef.destroy(),this._windowCmptRef=null,this._backdropCmptRef=null,this._contentRef=null}}var nF=function(t){return t[t.BACKDROP_CLICK=0]="BACKDROP_CLICK",t[t.ESC=1]="ESC",t}({});let rF=(()=>{let t=class{constructor(t,e,n){this._document=t,this._elRef=e,this._zone=n,this._closed$=new rt,this._elWithFocus=null,this.backdrop=!0,this.keyboard=!0,this.dismissEvent=new Wa}dismiss(t){this.dismissEvent.emit(t)}ngOnInit(){this._elWithFocus=this._document.activeElement}ngAfterViewInit(){const{nativeElement:t}=this._elRef;if(this._zone.runOutsideAngular(()=>{kO(t,"keydown").pipe(AO(this._closed$),ac(t=>t.which===jO.Escape&&this.keyboard)).subscribe(t=>requestAnimationFrame(()=>{t.defaultPrevented||this._zone.run(()=>this.dismiss(nF.ESC))}));let e=!1;kO(this._dialogEl.nativeElement,"mousedown").pipe(AO(this._closed$),Nc(()=>e=!1),Oc(()=>kO(t,"mouseup").pipe(AO(this._closed$),_c(1))),ac(({target:e})=>t===e)).subscribe(()=>{e=!0}),kO(t,"click").pipe(AO(this._closed$)).subscribe(({target:n})=>{!0!==this.backdrop||t!==n||e||this._zone.run(()=>this.dismiss(nF.BACKDROP_CLICK)),e=!1})}),!t.contains(document.activeElement)){const e=t.querySelector("[ngbAutofocus]"),n=qO(t)[0];(e||n||t).focus()}}ngOnDestroy(){const t=this._document.body,e=this._elWithFocus;let n;n=e&&e.focus&&t.contains(e)?e:t,this._zone.runOutsideAngular(()=>{setTimeout(()=>n.focus()),this._elWithFocus=null}),this._closed$.next()}};return t.\u0275fac=function(e){return new(e||t)(ro(Ql),ro(Qo),ro(Cl))},t.\u0275cmp=We({type:t,selectors:[["ngb-modal-window"]],viewQuery:function(t,e){var n,r,s,i,o,a;1&t&&(i=OO,o=!0,function(t,e,n,r,s,i){t.firstCreatePass&&(function(t,e,n){null===t.queries&&(t.queries=new Xa),t.queries.track(new Ya(e,-1))}(t,new Ka(n,r,!0,s)),t.staticViewQueries=!0),function(t,e){const n=new Ha;Ns(t,e,n,n.destroy),null===e[19]&&(e[19]=new Ga),e[19].queries.push(new qa(n))}(t,e)}(Tn(),Nn(),i,o,a)),2&t&&function(t){const e=Nn(),n=Tn(),r=Vn();Un(r+1);const s=tl(n,r);if(t.dirty&&Cn(e)===s.metadata.isStatic){if(null===s.matches)t.reset([]);else{const i=s.crossesNgTemplate?function t(e,n,r,s){const i=e.queries.getByIndex(r),o=i.matches;if(null!==o){const a=Qa(e,n,i,r);for(let e=0;e<o.length;e+=2){const r=o[e];if(r>0)s.push(a[e/2]);else{const i=o[e+1],a=n[-r];for(let e=10;e<a.length;e++){const n=a[e];n[17]===n[3]&&t(n[1],n,i,s)}if(null!==a[9]){const e=a[9];for(let n=0;n<e.length;n++){const r=e[n];t(r[1],r,i,s)}}}}}return s}(n,e,r,[]):Qa(n,e,s,r);t.reset(i),t.notifyOnChanges()}return!0}return!1}((r=Nn(),s=Vn(),n=r[19].queries[s].queryList))&&(e._dialogEl=n.first)},hostAttrs:["role","dialog","tabindex","-1"],hostVars:5,hostBindings:function(t,e){2&t&&(no("aria-modal",!0)("aria-labelledby",e.ariaLabelledBy)("aria-describedby",e.ariaDescribedBy),So("modal fade show d-block"+(e.windowClass?" "+e.windowClass:"")))},inputs:{backdrop:"backdrop",keyboard:"keyboard",ariaLabelledBy:"ariaLabelledBy",ariaDescribedBy:"ariaDescribedBy",centered:"centered",scrollable:"scrollable",size:"size",windowClass:"windowClass"},outputs:{dismissEvent:"dismiss"},ngContentSelectors:DO,decls:4,vars:2,consts:[["role","document"],["dialog",""],[1,"modal-content"]],template:function(t,e){1&t&&(function(t){const e=Nn()[16][6];if(!e.projection){const t=e.projection=Oe(1,null),n=t.slice();let r=e.child;for(;null!==r;){const e=0;null!==e&&(n[e]?n[e].projectionNext=r:t[e]=r,n[e]=r),r=r.next}}}(),oo(0,"div",0,1),oo(2,"div",2),function(t,e=0,n){const r=Nn(),s=Tn(),i=Cs(s,r[6],t,1,null,n||null);null===i.projection&&(i.projection=e),On(),function(t,e,n){xi(e[11],0,e,n,ci(t,n,e),mi(n.parent||e[6],e))}(s,r,i)}(3),ao(),ao()),2&t&&So("modal-dialog"+(e.size?" modal-"+e.size:"")+(e.centered?" modal-dialog-centered":"")+(e.scrollable?" modal-dialog-scrollable":""))},styles:["ngb-modal-window .component-host-scrollable{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;overflow:hidden}"],encapsulation:2}),t})(),sF=(()=>{let t=class{constructor(t,e,n,r,s,i){this._applicationRef=t,this._injector=e,this._document=n,this._scrollBar=r,this._rendererFactory=s,this._ngZone=i,this._activeWindowCmptHasChanged=new rt,this._ariaHiddenValues=new Map,this._backdropAttributes=["backdropClass"],this._modalRefs=[],this._windowAttributes=["ariaLabelledBy","ariaDescribedBy","backdrop","centered","keyboard","scrollable","size","windowClass"],this._windowCmpts=[],this._activeInstances=new Wa,this._activeWindowCmptHasChanged.subscribe(()=>{if(this._windowCmpts.length){const t=this._windowCmpts[this._windowCmpts.length-1];((t,e,n,r=!1)=>{this._ngZone.runOutsideAngular(()=>{const t=kO(e,"focusin").pipe(AO(n),mt(t=>t.target));kO(e,"keydown").pipe(AO(n),ac(t=>t.which===jO.Tab),TO(t)).subscribe(([t,n])=>{const[r,s]=qO(e);n!==r&&n!==e||!t.shiftKey||(s.focus(),t.preventDefault()),n!==s||t.shiftKey||(r.focus(),t.preventDefault())}),r&&kO(e,"click").pipe(AO(n),TO(t),mt(t=>t[1])).subscribe(t=>t.focus())})})(0,t.location.nativeElement,this._activeWindowCmptHasChanged),this._revertAriaHidden(),this._setAriaHidden(t.location.nativeElement)}})}open(t,e,n,r){const s=r.container instanceof HTMLElement?r.container:FO(r.container)?this._document.querySelector(r.container):this._document.body,i=this._rendererFactory.createRenderer(null,null),o=this._scrollBar.compensate(),a=()=>{this._modalRefs.length||(i.removeClass(this._document.body,"modal-open"),this._revertAriaHidden())};if(!s)throw new Error(`The specified modal container "${r.container||"body"}" was not found in the DOM.`);const l=new tF,u=this._getContentRef(t,r.injector||e,n,l,r);let c=!1!==r.backdrop?this._attachBackdrop(t,s):void 0,h=this._attachWindowComponent(t,s,u),d=new eF(h,u,c,r.beforeDismiss);return this._registerModalRef(d),this._registerWindowCmpt(h),d.result.then(o,o),d.result.then(a,a),l.close=t=>{d.close(t)},l.dismiss=t=>{d.dismiss(t)},this._applyWindowOptions(h.instance,r),1===this._modalRefs.length&&i.addClass(this._document.body,"modal-open"),c&&c.instance&&this._applyBackdropOptions(c.instance,r),d}get activeInstances(){return this._activeInstances}dismissAll(t){this._modalRefs.forEach(e=>e.dismiss(t))}hasOpenModals(){return this._modalRefs.length>0}_attachBackdrop(t,e){let n=t.resolveComponentFactory(QO).create(this._injector);return this._applicationRef.attachView(n.hostView),e.appendChild(n.location.nativeElement),n}_attachWindowComponent(t,e,n){let r=t.resolveComponentFactory(rF).create(this._injector,n.nodes);return this._applicationRef.attachView(r.hostView),e.appendChild(r.location.nativeElement),r}_applyWindowOptions(t,e){this._windowAttributes.forEach(n=>{FO(e[n])&&(t[n]=e[n])})}_applyBackdropOptions(t,e){this._backdropAttributes.forEach(n=>{FO(e[n])&&(t[n]=e[n])})}_getContentRef(t,e,n,r,s){return n?n instanceof Sa?this._createFromTemplateRef(n,r):"string"==typeof n?this._createFromString(n):this._createFromComponent(t,e,n,r,s):new YO([])}_createFromTemplateRef(t,e){const n=t.createEmbeddedView({$implicit:e,close(t){e.close(t)},dismiss(t){e.dismiss(t)}});return this._applicationRef.attachView(n),new YO([n.rootNodes],n)}_createFromString(t){const e=this._document.createTextNode(""+t);return new YO([[e]])}_createFromComponent(t,e,n,r,s){const i=t.resolveComponentFactory(n),o=Ki.create({providers:[{provide:tF,useValue:r}],parent:e}),a=i.create(o),l=a.location.nativeElement;return s.scrollable&&l.classList.add("component-host-scrollable"),this._applicationRef.attachView(a.hostView),new YO([[l]],a.hostView,a)}_setAriaHidden(t){const e=t.parentElement;e&&t!==this._document.body&&(Array.from(e.children).forEach(e=>{e!==t&&"SCRIPT"!==e.nodeName&&(this._ariaHiddenValues.set(e,e.getAttribute("aria-hidden")),e.setAttribute("aria-hidden","true"))}),this._setAriaHidden(e))}_revertAriaHidden(){this._ariaHiddenValues.forEach((t,e)=>{t?e.setAttribute("aria-hidden",t):e.removeAttribute("aria-hidden")}),this._ariaHiddenValues.clear()}_registerModalRef(t){const e=()=>{const e=this._modalRefs.indexOf(t);e>-1&&(this._modalRefs.splice(e,1),this._activeInstances.emit(this._modalRefs))};this._modalRefs.push(t),this._activeInstances.emit(this._modalRefs),t.result.then(e,e)}_registerWindowCmpt(t){this._windowCmpts.push(t),this._activeWindowCmptHasChanged.next(),t.onDestroy(()=>{const e=this._windowCmpts.indexOf(t);e>-1&&(this._windowCmpts.splice(e,1),this._activeWindowCmptHasChanged.next())})}};return t.\u0275fac=function(e){return new(e||t)(Ee(Vl),Ee(Ki),Ee(Ql),Ee(JO),Ee(ea),Ee(Cl))},t.\u0275prov=Vt({factory:function(){return new t(Ee(Vl),Ee(ge),Ee(Ql),Ee(JO),Ee(ea),Ee(Cl))},token:t,providedIn:"root"}),t})(),iF=(()=>{let t=class{constructor(t,e,n,r){this._moduleCFR=t,this._injector=e,this._modalStack=n,this._config=r}open(t,e={}){const n=Object.assign({},this._config,e);return this._modalStack.open(this._moduleCFR,this._injector,t,n)}get activeInstances(){return this._modalStack.activeInstances}dismissAll(t){this._modalStack.dismissAll(t)}hasOpenModals(){return this._modalStack.hasOpenModals()}};return t.\u0275fac=function(e){return new(e||t)(Ee(Jo),Ee(Ki),Ee(sF),Ee(XO))},t.\u0275prov=Vt({factory:function(){return new t(Ee(Jo),Ee(ge),Ee(sF),Ee(XO))},token:t,providedIn:"root"}),t})(),oF=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},providers:[iF]}),t})(),aF=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},imports:[[xu]]}),t})(),lF=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},imports:[[xu]]}),t})(),uF=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},imports:[[xu]]}),t})(),cF=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},imports:[[xu]]}),t})(),hF=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},imports:[[xu]]}),t})(),dF=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},imports:[[xu]]}),t})(),pF=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},imports:[[xu]]}),t})(),fF=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},imports:[[xu]]}),t})(),mF=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)}}),t})(),gF=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},imports:[[xu]]}),t})();const yF=[MO,LO,VO,UO,WO,GO,KO,oF,aF,lF,uF,cF,hF,pF,fF,mF,gF,dF];let bF=(()=>{let t=class{};return t.\u0275mod=Ge({type:t}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},imports:[yF,MO,LO,VO,UO,WO,GO,KO,oF,aF,lF,uF,cF,hF,pF,fF,mF,gF,dF]}),t})(),vF=(()=>{class t{constructor(){this.title="Twitter Sentiment App",this.sentimenttext="Put something here",this.sentiment="",this.threshold=.5,this.prediction=0}ngOnInit(){this.loadModel()}loadModel(){return Ap(this,void 0,void 0,(function*(){var t;this.dict=yield mD.ajax({url:"./assets/dict.csv",dataType:"text"}),console.log("dict type",typeof this.dict),this.model=yield(null==t&&(t={}),async function(t,e){if(null==e&&(e={}),"string"==typeof t){const n=a.getLoadHandlers(t,e);if(0===n.length)n.push(a.browserHTTPRequest(t,e));else if(n.length>1)throw new XS(`Found more than one (${n.length}) load handlers for URL '${t}'`);t=n[0]}return async function(t,e,n){if(null==n&&(n={}),null==t.load)throw new XS("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await t.load();let s=r.modelTopology;null!=s.model_config&&(s=s.model_config);const i=null==n.strict||n.strict,o=null!=r.weightData&&null!=r.weightSpecs&&i,l=sk(Nk(s),void 0,o),u=r.trainingConfig;if(null!=u&&l.loadTrainingConfig(u),null!=r.userDefinedMetadata&&l.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new XS("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:t,optimizerWeights:e}=function(t,e){const n=a.decodeWeights(t,e),r={},s=[];return e.forEach(t=>{"optimizer"===t.group?s.push({name:t.name,tensor:n[t.name]}):r[t.name]=n[t.name]}),{modelWeights:r,optimizerWeights:s}}(r.weightData,r.weightSpecs);l.loadWeights(t,i),null!=l.optimizer&&e.length>0&&await l.optimizer.setWeights(e),px(t),px(e.map(t=>t.tensor))}return l}(t,0,e)}("./assets/model.json",t)),console.log("model type",typeof this.model),this.word_index=yield this.success(this.dict),console.log("word_index type",typeof this.word_index)}))}success(t){return Ap(this,void 0,void 0,(function*(){for(var e=new Object,n=t.split(/\r?\n|\r/),r=0;r<n.length;r++){var s=n[r].split(",")[0],i=n[r].split(",")[1];""!=s&&(e[s]=parseInt(i))}return e}))}process(t){var e=t.replace(/[^a-zA-Z0-9\s]/,"");e=e.trim().split(/\s+/);for(var n=0;n<e.length;n++)e[n]=e[n].toLowerCase();return e}create_sequences(t){for(var e=this.process(t),n=Array.from(Array(40),()=>0),r=40-e.length,s=0;s<e.length;s++)Object.keys(this.word_index).includes(e[s])&&(n[s+r]=this.word_index[e[s]]);return n}textchanged(t){this.sentimenttext=t}predict(){this.prediction=0,console.log("Button Clicked");var t=this.create_sequences(this.sentimenttext);console.log("Seq Created");var e=Am(t);e=e.expandDims(0),console.log("Input Created");const n=this.model.predict(e);this.predictions=Array.from(n.dataSync()),console.log("predictions type",typeof this.predictions),this.prediction=this.predictions[0],this.sentiment=this.prediction<this.threshold?"Negative":"Positive",console.log("Model output")}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=We({type:t,selectors:[["app-root"]],decls:44,vars:7,consts:[["role","banner",1,"toolbar"],["width","40","alt","Angular Logo","src","data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTAgMjUwIj4KICAgIDxwYXRoIGZpbGw9IiNERDAwMzEiIGQ9Ik0xMjUgMzBMMzEuOSA2My4ybDE0LjIgMTIzLjFMMTI1IDIzMGw3OC45LTQzLjcgMTQuMi0xMjMuMXoiIC8+CiAgICA8cGF0aCBmaWxsPSIjQzMwMDJGIiBkPSJNMTI1IDMwdjIyLjItLjFWMjMwbDc4LjktNDMuNyAxNC4yLTEyMy4xTDEyNSAzMHoiIC8+CiAgICA8cGF0aCAgZmlsbD0iI0ZGRkZGRiIgZD0iTTEyNSA1Mi4xTDY2LjggMTgyLjZoMjEuN2wxMS43LTI5LjJoNDkuNGwxMS43IDI5LjJIMTgzTDEyNSA1Mi4xem0xNyA4My4zaC0zNGwxNy00MC45IDE3IDQwLjl6IiAvPgogIDwvc3ZnPg=="],[1,"spacer"],["aria-label","Angular on twitter","target","_blank","rel","noopener","href","https://twitter.com/angular","title","Twitter"],["id","twitter-logo","height","24","data-name","Logo","xmlns","http://www.w3.org/2000/svg","viewBox","0 0 400 400"],["width","400","height","400","fill","none"],["d","M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23","fill","#fff"],["role","main",1,"content"],[1,"card","highlight-card","card-small"],["id","rocket","alt","Rocket Ship","xmlns","http://www.w3.org/2000/svg","width","101.678","height","101.678","viewBox","0 0 101.678 101.678"],["id","Group_83","data-name","Group 83","transform","translate(-141 -696)"],["id","Ellipse_8","data-name","Ellipse 8","cx","50.839","cy","50.839","r","50.839","transform","translate(141 696)","fill","#dd0031"],["id","Group_47","data-name","Group 47","transform","translate(165.185 720.185)"],["id","Path_33","data-name","Path 33","d","M3.4,42.615a3.084,3.084,0,0,0,3.553,3.553,21.419,21.419,0,0,0,12.215-6.107L9.511,30.4A21.419,21.419,0,0,0,3.4,42.615Z","transform","translate(0.371 3.363)","fill","#fff"],["id","Path_34","data-name","Path 34","d","M53.3,3.221A3.09,3.09,0,0,0,50.081,0,48.227,48.227,0,0,0,18.322,13.437c-6-1.666-14.991-1.221-18.322,7.218A33.892,33.892,0,0,1,9.439,25.1l-.333.666a3.013,3.013,0,0,0,.555,3.553L23.985,43.641a2.9,2.9,0,0,0,3.553.555l.666-.333A33.892,33.892,0,0,1,32.647,53.3c8.55-3.664,8.884-12.326,7.218-18.322A48.227,48.227,0,0,0,53.3,3.221ZM34.424,9.772a6.439,6.439,0,1,1,9.106,9.106,6.368,6.368,0,0,1-9.106,0A6.467,6.467,0,0,1,34.424,9.772Z","transform","translate(0 0.005)","fill","#fff"],["id","rocket-smoke","alt","Rocket Ship Smoke","xmlns","http://www.w3.org/2000/svg","width","516.119","height","1083.632","viewBox","0 0 516.119 1083.632"],["id","Path_40","data-name","Path 40","d","M644.6,141S143.02,215.537,147.049,870.207s342.774,201.755,342.774,201.755S404.659,847.213,388.815,762.2c-27.116-145.51-11.551-384.124,271.9-609.1C671.15,139.365,644.6,141,644.6,141Z","transform","translate(-147.025 -140.939)","fill","#f5f5f5"],[1,"card","card-small"],[1,"card-body"],["id","sentimenttext2",3,"value","ngModel","ngModelChange"],[1,"terminal"],[1,"btn-group","btn-group-toggle"],["ngbButtonLabel","",1,"btn-primary"],["type","checkbox","ngbButton","",3,"click"],["id","clouds","alt","Gray Clouds Background","xmlns","http://www.w3.org/2000/svg","width","2611.084","height","485.677","viewBox","0 0 2611.084 485.677"],["id","Path_39","data-name","Path 39","d","M2379.709,863.793c10-93-77-171-168-149-52-114-225-105-264,15-75,3-140,59-152,133-30,2.83-66.725,9.829-93.5,26.25-26.771-16.421-63.5-23.42-93.5-26.25-12-74-77-130-152-133-39-120-212-129-264-15-54.084-13.075-106.753,9.173-138.488,48.9-31.734-39.726-84.4-61.974-138.487-48.9-52-114-225-105-264,15a162.027,162.027,0,0,0-103.147,43.044c-30.633-45.365-87.1-72.091-145.206-58.044-52-114-225-105-264,15-75,3-140,59-152,133-53,5-127,23-130,83-2,42,35,72,70,86,49,20,106,18,157,5a165.625,165.625,0,0,0,120,0c47,94,178,113,251,33,61.112,8.015,113.854-5.72,150.492-29.764a165.62,165.62,0,0,0,110.861-3.236c47,94,178,113,251,33,31.385,4.116,60.563,2.495,86.487-3.311,25.924,5.806,55.1,7.427,86.488,3.311,73,80,204,61,251-33a165.625,165.625,0,0,0,120,0c51,13,108,15,157-5a147.188,147.188,0,0,0,33.5-18.694,147.217,147.217,0,0,0,33.5,18.694c49,20,106,18,157,5a165.625,165.625,0,0,0,120,0c47,94,178,113,251,33C2446.709,1093.793,2554.709,922.793,2379.709,863.793Z","transform","translate(142.69 -634.312)","fill","#eee"]],template:function(t,e){1&t&&(oo(0,"div",0),lo(1,"img",1),oo(2,"span"),Do(3,"Welcome"),ao(),lo(4,"div",2),oo(5,"a",3),Qn(),oo(6,"svg",4),lo(7,"rect",5),lo(8,"path",6),ao(),ao(),ao(),tr(),oo(9,"div",7),oo(10,"div",8),Qn(),oo(11,"svg",9),oo(12,"g",10),lo(13,"circle",11),oo(14,"g",12),lo(15,"path",13),lo(16,"path",14),ao(),ao(),ao(),tr(),oo(17,"span"),Do(18),ao(),Qn(),oo(19,"svg",15),lo(20,"path",16),ao(),ao(),tr(),oo(21,"h2"),Do(22,"Try some text below"),ao(),oo(23,"div",17),oo(24,"div",18),oo(25,"input",19),ho("ngModelChange",(function(t){return e.textchanged(t)})),ao(),ao(),ao(),oo(26,"div",20),oo(27,"div"),oo(28,"p"),Do(29),ao(),oo(30,"p"),Do(31),ao(),oo(32,"p"),Do(33),ao(),oo(34,"p"),Do(35),ao(),ao(),ao(),oo(36,"footer"),oo(37,"div",21),oo(38,"label",22),oo(39,"input",23),ho("click",(function(){return e.predict()})),ao(),Do(40," Click for Sentiment "),ao(),ao(),ao(),Qn(),oo(41,"svg",24),lo(42,"path",25),ao(),ao(),tr(),lo(43,"router-outlet")),2&t&&(hs(18),Oo("",e.title," app is running!"),hs(7),so("value",e.sentimenttext)("ngModel",e.sentimenttext),hs(4),Oo(" Text input: ",e.sentimenttext," "),hs(2),Oo(" Lenth: ",e.sentimenttext.length," "),hs(2),Oo(" Prediction Score: ",e.prediction," "),hs(2),Oo(" Sentiment: ",e.sentiment," "))},directives:[CD,ID,SO,PO,BO,op],styles:["",'[_nghost-%COMP%] {\n    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";\n    font-size: 14px;\n    color: #333;\n    box-sizing: border-box;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n  }\n\n  h1[_ngcontent-%COMP%], h2[_ngcontent-%COMP%], h3[_ngcontent-%COMP%], h4[_ngcontent-%COMP%], h5[_ngcontent-%COMP%], h6[_ngcontent-%COMP%] {\n    margin: 8px 0;\n  }\n\n  p[_ngcontent-%COMP%] {\n    margin: 0;\n  }\n\n  .spacer[_ngcontent-%COMP%] {\n    flex: 1;\n  }\n\n  .toolbar[_ngcontent-%COMP%] {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 60px;\n    display: flex;\n    align-items: center;\n    background-color: #1976d2;\n    color: white;\n    font-weight: 600;\n  }\n\n  .toolbar[_ngcontent-%COMP%]   img[_ngcontent-%COMP%] {\n    margin: 0 16px;\n  }\n\n  .toolbar[_ngcontent-%COMP%]   #twitter-logo[_ngcontent-%COMP%] {\n    height: 40px;\n    margin: 0 16px;\n  }\n\n  .toolbar[_ngcontent-%COMP%]   #twitter-logo[_ngcontent-%COMP%]:hover {\n    opacity: 0.8;\n  }\n\n  .content[_ngcontent-%COMP%] {\n    display: flex;\n    margin: 82px auto 32px;\n    padding: 0 16px;\n    max-width: 960px;\n    flex-direction: column;\n    align-items: center;\n  }\n\n  svg.material-icons[_ngcontent-%COMP%] {\n    height: 24px;\n    width: auto;\n  }\n\n  svg.material-icons[_ngcontent-%COMP%]:not(:last-child) {\n    margin-right: 8px;\n  }\n\n  .card[_ngcontent-%COMP%]   svg.material-icons[_ngcontent-%COMP%]   path[_ngcontent-%COMP%] {\n    fill: #888;\n  }\n\n  .card-container[_ngcontent-%COMP%] {\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: center;\n    margin-top: 16px;\n  }\n\n  .card[_ngcontent-%COMP%] {\n    border-radius: 4px;\n    border: 1px solid #eee;\n    background-color: #fafafa;\n    height: 40px;\n    width: 200px;\n    margin: 0 8px 16px;\n    padding: 16px;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    transition: all 0.2s ease-in-out;\n    line-height: 24px;\n  }\n\n  .card-container[_ngcontent-%COMP%]   .card[_ngcontent-%COMP%]:not(:last-child) {\n    margin-right: 0;\n  }\n\n  .card.card-small[_ngcontent-%COMP%] {\n    height: 16px;\n    width: 168px;\n  }\n\n  .card-container[_ngcontent-%COMP%]   .card[_ngcontent-%COMP%]:not(.highlight-card) {\n    cursor: pointer;\n  }\n\n  .card-container[_ngcontent-%COMP%]   .card[_ngcontent-%COMP%]:not(.highlight-card):hover {\n    transform: translateY(-3px);\n    box-shadow: 0 4px 17px rgba(0, 0, 0, 0.35);\n  }\n\n  .card-container[_ngcontent-%COMP%]   .card[_ngcontent-%COMP%]:not(.highlight-card):hover   .material-icons[_ngcontent-%COMP%]   path[_ngcontent-%COMP%] {\n    fill: rgb(105, 103, 103);\n  }\n\n  .card.highlight-card[_ngcontent-%COMP%] {\n    background-color: #1976d2;\n    color: white;\n    font-weight: 600;\n    border: none;\n    width: auto;\n    min-width: 30%;\n    position: relative;\n  }\n\n  .card.card.highlight-card[_ngcontent-%COMP%]   span[_ngcontent-%COMP%] {\n    margin-left: 60px;\n  }\n\n  svg#rocket[_ngcontent-%COMP%] {\n    width: 80px;\n    position: absolute;\n    left: -10px;\n    top: -24px;\n  }\n\n  svg#rocket-smoke[_ngcontent-%COMP%] {\n    height: calc(100vh - 95px);\n    position: absolute;\n    top: 10px;\n    right: 180px;\n    z-index: -10;\n  }\n\n  a[_ngcontent-%COMP%], a[_ngcontent-%COMP%]:visited, a[_ngcontent-%COMP%]:hover {\n    color: #1976d2;\n    text-decoration: none;\n  }\n\n  a[_ngcontent-%COMP%]:hover {\n    color: #125699;\n  }\n\n  .terminal[_ngcontent-%COMP%] {\n    position: relative;\n    width: 80%;\n    max-width: 600px;\n    border-radius: 6px;\n    padding-top: 45px;\n    margin-top: 8px;\n    overflow: hidden;\n    background-color: rgb(15, 15, 16);\n  }\n\n  .terminal[_ngcontent-%COMP%]::before {\n    content: "\\2022 \\2022 \\2022";\n    position: absolute;\n    top: 0;\n    left: 0;\n    height: 4px;\n    background: rgb(58, 58, 58);\n    color: #c2c3c4;\n    width: 100%;\n    font-size: 2rem;\n    line-height: 0;\n    padding: 14px 0;\n    text-indent: 4px;\n  }\n\n  .terminal[_ngcontent-%COMP%]   pre[_ngcontent-%COMP%] {\n    font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;\n    color: white;\n    padding: 0 1rem 1rem;\n    margin: 0;\n  }\n  .terminal[_ngcontent-%COMP%]   div[_ngcontent-%COMP%] {\n    font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;\n    color: white;\n    padding: 0 1rem 1rem;\n    margin: 0;\n  }\n\n  .circle-link[_ngcontent-%COMP%] {\n    height: 40px;\n    width: 40px;\n    border-radius: 40px;\n    margin: 8px;\n    background-color: white;\n    border: 1px solid #eeeeee;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    cursor: pointer;\n    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);\n    transition: 1s ease-out;\n  }\n\n  .circle-link[_ngcontent-%COMP%]:hover {\n    transform: translateY(-0.25rem);\n    box-shadow: 0px 3px 15px rgba(0, 0, 0, 0.2);\n  }\n\n  footer[_ngcontent-%COMP%] {\n    margin-top: 8px;\n    display: flex;\n    align-items: center;\n    line-height: 20px;\n  }\n\n  footer[_ngcontent-%COMP%]   a[_ngcontent-%COMP%] {\n    display: flex;\n    align-items: center;\n  }\n\n  .github-star-badge[_ngcontent-%COMP%] {\n    color: #24292e;\n    display: flex;\n    align-items: center;\n    font-size: 12px;\n    padding: 3px 10px;\n    border: 1px solid rgba(27,31,35,.2);\n    border-radius: 3px;\n    background-image: linear-gradient(-180deg,#fafbfc,#eff3f6 90%);\n    margin-left: 4px;\n    font-weight: 600;\n    font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;\n  }\n\n  .github-star-badge[_ngcontent-%COMP%]:hover {\n    background-image: linear-gradient(-180deg,#f0f3f6,#e6ebf1 90%);\n    border-color: rgba(27,31,35,.35);\n    background-position: -.5em;\n  }\n\n  .github-star-badge[_ngcontent-%COMP%]   .material-icons[_ngcontent-%COMP%] {\n    height: 16px;\n    width: 16px;\n    margin-right: 4px;\n  }\n\n  svg#clouds[_ngcontent-%COMP%] {\n    position: fixed;\n    bottom: -160px;\n    left: -230px;\n    z-index: -10;\n    width: 1920px;\n  }\n\n\n  \n  @media screen and (max-width: 767px) {\n\n    .card-container[_ngcontent-%COMP%]    > *[_ngcontent-%COMP%]:not(.circle-link), .terminal[_ngcontent-%COMP%] {\n      width: 100%;\n    }\n\n    .card[_ngcontent-%COMP%]:not(.highlight-card) {\n      height: 16px;\n      margin: 8px 0;\n    }\n\n    .card.highlight-card[_ngcontent-%COMP%]   span[_ngcontent-%COMP%] {\n      margin-left: 72px;\n    }\n\n    svg#rocket-smoke[_ngcontent-%COMP%] {\n      right: 120px;\n      transform: rotate(-5deg);\n    }\n  }\n\n  @media screen and (max-width: 575px) {\n    svg#rocket-smoke[_ngcontent-%COMP%] {\n      display: none;\n      visibility: hidden;\n    }\n  }']}),t})(),xF=(()=>{class t{}return t.\u0275mod=Ge({type:t,bootstrap:[vF]}),t.\u0275inj=Ut({factory:function(e){return new(e||t)},providers:[],imports:[[Yu,kp,EO,bF]]}),t})();(function(){if(Hr)throw new Error("Cannot enable prod mode after platform setup.");jr=!1})(),Ku().bootstrapModule(xF).catch(t=>console.error(t))},zn8P:function(t,e){function n(t){return Promise.resolve().then((function(){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}))}n.keys=function(){return[]},n.resolve=n,t.exports=n,n.id="zn8P"}},[[0,0]]]);